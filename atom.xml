<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-02-25T14:33:16.866Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-栈和队列</title>
    <link href="https://cheng102e.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html"/>
    <id>https://cheng102e.github.io/数据结构-栈和队列.html</id>
    <published>2020-02-25T12:42:00.000Z</published>
    <updated>2020-02-25T14:33:16.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构-栈和队列"><a href="#数据结构-栈和队列" class="headerlink" title="数据结构-栈和队列"></a>数据结构-栈和队列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈和队列是两种特殊的线性表。<br>栈(Stack)是一种后进先出的数据结构,可以想象成一个瓶子，先进去的在下层，要后出来。<br>而队列(Queue)则是先进先出，就像排队一样，先进队伍的先出来。</p><h3 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h3><ol><li>Stack<t>()  创建一个空的栈</t></li><li>void push(T s)  往栈中添加一个新的元素</li><li>T pop()  移除并返回最近添加的元素</li><li>T peek()  返回最近添加的元素，不删除</li><li>boolean isempty()  栈是否为空</li><li>int size()  栈中元素的个数</li></ol><h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><ol><li>Queue<t>()  创建一个空的栈</t></li><li>T Add()  往队列中添加一个新的元素</li><li>T remove()  移除最早添加的元素</li><li>T element()  返回最早添加的元素，不删除</li><li>boolean isempty()  队列是否为空</li><li>int size()   队列中元素的个数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构-栈和队列&quot;&gt;&lt;a href=&quot;#数据结构-栈和队列&quot; class=&quot;headerlink&quot; title=&quot;数据结构-栈和队列&quot;&gt;&lt;/a&gt;数据结构-栈和队列&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cheng102e.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构-线性表</title>
    <link href="https://cheng102e.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8.html"/>
    <id>https://cheng102e.github.io/数据结构-线性表.html</id>
    <published>2020-02-25T11:42:00.000Z</published>
    <updated>2020-02-25T13:36:55.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构-线性表"><a href="#数据结构-线性表" class="headerlink" title="数据结构-线性表"></a>数据结构-线性表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p><p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol><li>集合中必存在唯一的一个“第一元素”。</li><li>集合中必存在唯一的一个 “最后元素” 。</li><li>除最后一个元素之外，均有唯一的后继(后件)。</li><li>除第一个元素之外，均有唯一的前驱(前件)。</li></ol><h3 id="存储方式与优缺点"><a href="#存储方式与优缺点" class="headerlink" title="存储方式与优缺点"></a>存储方式与优缺点</h3><ol><li>顺序存储(顺序表)<br> 优点：<br> 1.空间利用率高<br> 2.存取速度快<br> 缺点：<br> 1.插入删除操作较慢<br> 2.初始要定义长度，可能溢出</li><li>链式存储(链表)<br> 优点：<br> 1.插入删除操作较快<br> 2.没有空间限制<br> 缺点：<br> 1.空间消耗多<br> 2.存取速度慢</li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li>求当前元素个数</li><li>插入</li><li>删除</li><li>查找</li><li>判断是否为空</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构-线性表&quot;&gt;&lt;a href=&quot;#数据结构-线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构-线性表&quot;&gt;&lt;/a&gt;数据结构-线性表&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cheng102e.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 3.从尾到头打印链表</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%203.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html"/>
    <id>https://cheng102e.github.io/剑指offer 3.从尾到头打印链表.html</id>
    <published>2020-02-24T11:42:00.000Z</published>
    <updated>2020-02-24T11:45:53.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路给了两种，一种是递归，先到下一个结点再输出自身的值，但是可能会存在溢出情况。还有一种就是用栈，先进后出，负负得正，就行了。<br>(两个问题，1.牛客网在线评测头文件要自己打，这个真没想到 2.注意空链表的判断)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">  Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line">  ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">  if (listNode == null) &#123;</span><br><span class="line">    return arrayList;</span><br><span class="line">  &#125;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    int temp = listNode.val;</span><br><span class="line">    stack.push(temp);</span><br><span class="line">    if (listNode.next == null) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode = listNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  while (!stack.isEmpty()) &#123;</span><br><span class="line">    arrayList.add(stack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  return arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-从尾到头打印链表&quot;&gt;&lt;a href=&quot;#3-从尾到头打印链表&quot; class=&quot;headerlink&quot; title=&quot;3.从尾到头打印链表&quot;&gt;&lt;/a&gt;3.从尾到头打印链表&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 2.替换空格</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%202.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html"/>
    <id>https://cheng102e.github.io/剑指offer 2.替换空格.html</id>
    <published>2020-02-24T11:00:00.000Z</published>
    <updated>2020-02-24T11:43:29.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>书上的思路，是先记录空格位置，然后从后往前转移字符串，遇到空格就输出%20，但是java的字符串简单了很多，用一个StringBuffer就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">  StringBuffer ans = new StringBuffer();</span><br><span class="line">  for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">    if (str.charAt(i) != &apos; &apos;) &#123;</span><br><span class="line">      ans.append(str.charAt(i));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ans.append(&quot;%20&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2-替换空格&quot;&gt;&lt;a href=&quot;#2-替换空格&quot; class=&quot;headerlink&quot; title=&quot;2.替换空格&quot;&gt;&lt;/a&gt;2.替换空格&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 1.二维数组中的查找</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%201.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html"/>
    <id>https://cheng102e.github.io/剑指offer 1.二维数组中的查找.html</id>
    <published>2020-02-24T10:42:00.000Z</published>
    <updated>2020-02-24T10:49:38.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1.二维数组中的查找"></a>1.二维数组中的查找</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路主要是，从左下或者右上两个角落开始比较，找到了自然就不用继续了，找不到的话一次可以排除一行或一列，这里我变量命名有些随意，但应该不影响阅读。</p><p>（新坑，剑指offer上面的题目的java解法，用博客记录，每个代码都是牛客网上面能通过的，希望能给大家带来些许帮助）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean Find(int target, int[][] array) &#123;</span><br><span class="line">  int x0 = 0, y0 = 0;</span><br><span class="line">  int x1 = array.length - 1, y1 = array[0].length - 1;</span><br><span class="line">  boolean ans = false;</span><br><span class="line">  while (x1 &gt;= x0 &amp;&amp; y1 &gt;= y0) &#123;</span><br><span class="line">    if (array[x0][y1] == target) &#123;</span><br><span class="line">      ans = true;</span><br><span class="line">      break;</span><br><span class="line">    &#125; else if (array[x0][y1] &lt; target) &#123;</span><br><span class="line">      x0++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      y1--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-二维数组中的查找&quot;&gt;&lt;a href=&quot;#1-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;1.二维数组中的查找&quot;&gt;&lt;/a&gt;1.二维数组中的查找&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap和Hashtable的区别</title>
    <link href="https://cheng102e.github.io/HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>https://cheng102e.github.io/HashMap和Hashtable的区别.html</id>
    <published>2020-02-22T12:00:00.000Z</published>
    <updated>2020-02-22T12:20:52.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><p>HashMap和Hashtable这两个是集合框架中比较常见的问题，所以我做了些总结便于回顾。</p><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>Hashtable 继承自 Dictiionary 而 HashMap继承自AbstractMap</p><h3 id="2-键值要求"><a href="#2-键值要求" class="headerlink" title="2.键值要求"></a>2.键值要求</h3><p>hashtable不允许空值与空键，但是hashmap允许一个空键和任意数量空值。</p><h3 id="3-contains方法"><a href="#3-contains方法" class="headerlink" title="3.contains方法"></a>3.contains方法</h3><p>hashmap去除了contains方法，改为了containsValue和containsKey，但是hashtable这三个方法都有。</p><h3 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4.线程安全"></a>4.线程安全</h3><p>HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable。</p><h3 id="5-使用建议"><a href="#5-使用建议" class="headerlink" title="5.使用建议"></a>5.使用建议</h3><p>正常情况下建议使用hashmap，如果是多线程建议选择concurrentHashMap。<br>源码部分等到我更深入的学习的时候会添加。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap和Hashtable的区别&quot;&gt;&lt;a href=&quot;#HashMap和Hashtable的区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap和Hashtable的区别&quot;&gt;&lt;/a&gt;HashMap和Hashtable的区别&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="https://cheng102e.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>不知道来源的题目1</title>
    <link href="https://cheng102e.github.io/%E4%B8%8D%E7%9F%A5%E9%81%93%E6%9D%A5%E6%BA%90%E7%9A%84%E9%A2%98%E7%9B%AE1.html"/>
    <id>https://cheng102e.github.io/不知道来源的题目1.html</id>
    <published>2020-02-22T12:00:00.000Z</published>
    <updated>2020-02-22T11:57:08.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不知道来源的题目1"><a href="#不知道来源的题目1" class="headerlink" title="不知道来源的题目1"></a>不知道来源的题目1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有两个数组 A、B，长度都为 N，值为任意整数，无序，要求，通过交换 A、B 中的元素，使得 A 数组元素之和与 B 数组元素之和之间的差值最小。完成代码的同时，写出数组 [100,99,98,1,2, 3]和[1,2,3,4,5,40]交换后的结果。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解法多种多样，但是我真没想出来什么特别合适的，采用了一种比较繁琐的方法。<br>首先计算两个数组的差值，之后尝试交换，只要能让差值减小，就交换，一直到没有这种可能性再结束，理论上这就是要的答案。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void change(int[] a, int[] b, int n, int before) &#123;</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">      int after = before - 2 * (a[i] - b[j]);</span><br><span class="line">      if (Math.abs(after) &lt; Math.abs(before)) &#123;</span><br><span class="line">        int temp = a[i];</span><br><span class="line">        a[i] = b[j];</span><br><span class="line">        b[j] = temp;</span><br><span class="line">        change(a, b, n, after);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  int[] a = new int[]&#123;100, 99, 98, 1, 2, 3&#125;;</span><br><span class="line">  int[] b = new int[]&#123;1, 2, 3, 4, 5, 40&#125;;</span><br><span class="line">  int suma = 0;</span><br><span class="line">  int sumb = 0;</span><br><span class="line">  int len = a.length;</span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    suma += a[i];</span><br><span class="line">    sumb += b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  change(a, b, len, Math.abs(suma - sumb));</span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    System.out.print(b[i] + &quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不知道来源的题目1&quot;&gt;&lt;a href=&quot;#不知道来源的题目1&quot; class=&quot;headerlink&quot; title=&quot;不知道来源的题目1&quot;&gt;&lt;/a&gt;不知道来源的题目1&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="其他" scheme="https://cheng102e.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>非对称加密-RSA算法</title>
    <link href="https://cheng102e.github.io/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-RSA%E7%AE%97%E6%B3%95.html"/>
    <id>https://cheng102e.github.io/非对称加密-RSA算法.html</id>
    <published>2020-02-22T10:00:00.000Z</published>
    <updated>2020-02-22T10:03:12.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非对称加密-RSA算法"><a href="#非对称加密-RSA算法" class="headerlink" title="非对称加密-RSA算法"></a>非对称加密-RSA算法</h2><h3 id="非对称"><a href="#非对称" class="headerlink" title="非对称"></a>非对称</h3><p>传统算法是对称加密，共用密钥，非对称加密就使用了两个秘钥，一个公钥加密，一个私钥解密。</p><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><ol><li>随机选取两个质数 p，q</li><li>计算公共模数 n = p*q</li><li>欧拉函数 φ(n) = (p-1) * (q-1)</li><li>计算公钥 e &lt; φ(n),二者互质</li><li>计算私钥 d 使得 e * d % φ(n) = 1</li><li>公钥使用(e,n)私钥使用(d,n)</li><li>公钥加密 c = m^e mod n(m是原文内容，c是加密后的内容)</li><li>私钥解密 m = c^d mod n</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>至于RSA算法为什么有效，这些比较专业的我不是太了解，我只了解了大概用法。<br>我这里只写了一个帮助理顺思路的模拟代码，真的要用的话建议使用官方的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void rsa() &#123;</span><br><span class="line">  int p = 3;</span><br><span class="line">  int q = 11;</span><br><span class="line"></span><br><span class="line">  int n = p * q;</span><br><span class="line"></span><br><span class="line">  //假装q就是那个符号</span><br><span class="line">  int qn = (p - 1) * (q - 1);</span><br><span class="line"></span><br><span class="line">  //公钥私钥</span><br><span class="line">  int e = 3;</span><br><span class="line">  int d = 7;</span><br><span class="line"></span><br><span class="line">  //原文</span><br><span class="line">  int m = 9;</span><br><span class="line"></span><br><span class="line">  //加密后的</span><br><span class="line">  int c = (int) (Math.pow(m, e) % n);</span><br><span class="line">  System.out.println(c);</span><br><span class="line"></span><br><span class="line">  //解密后的</span><br><span class="line">  int m1 = (int) (Math.pow(c, d) % n);</span><br><span class="line">  System.out.println(m1);</span><br><span class="line">  </span><br><span class="line">  if (m == m1) &#123;</span><br><span class="line">    System.out.println(&quot;解密成功&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非对称加密-RSA算法&quot;&gt;&lt;a href=&quot;#非对称加密-RSA算法&quot; class=&quot;headerlink&quot; title=&quot;非对称加密-RSA算法&quot;&gt;&lt;/a&gt;非对称加密-RSA算法&lt;/h2&gt;&lt;h3 id=&quot;非对称&quot;&gt;&lt;a href=&quot;#非对称&quot; class=&quot;he
      
    
    </summary>
    
      <category term="算法" scheme="https://cheng102e.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>递归迭代与斐波那契数列</title>
    <link href="https://cheng102e.github.io/%E9%80%92%E5%BD%92%E8%BF%AD%E4%BB%A3%E4%B8%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html"/>
    <id>https://cheng102e.github.io/递归迭代与斐波那契数列.html</id>
    <published>2020-02-22T09:00:00.000Z</published>
    <updated>2020-02-22T09:03:35.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归迭代与斐波那契数列"><a href="#递归迭代与斐波那契数列" class="headerlink" title="递归迭代与斐波那契数列"></a>递归迭代与斐波那契数列</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>递归: 程序调用自身的编程技巧称为递归,是函数自己调用自己.</p><p>迭代: 利用变量的原值推算出变量的一个新值.</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>如果递归是自己调用自己(A调用A)的话,迭代就是A不停的调用B.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这里用了斐波那契数列数列，第一项为0第二项为1，之后每一项都是前两项的和。<br>对于递归反复调用自己，这里其实可以拿一个数组存储答案的。<br>迭代的话一直都是三个变量，一直在循环运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static int fic_1(int n) &#123;</span><br><span class="line">  //递归</span><br><span class="line">  if (n == 1) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125; else if (n == 2) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return fic_1(n - 1) + fic_1(n - 2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int fic_2(int n) &#123;</span><br><span class="line">  //迭代</span><br><span class="line">  int a2 = 0;</span><br><span class="line">  if (n == 1) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125; else if (n == 2) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    int a0 = 0, a1 = 1;</span><br><span class="line">    for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">      a2 = a0 + a1;</span><br><span class="line">      a0 = a1;</span><br><span class="line">      a1 = a2;</span><br><span class="line">    &#125;</span><br><span class="line">    return a2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;递归迭代与斐波那契数列&quot;&gt;&lt;a href=&quot;#递归迭代与斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;递归迭代与斐波那契数列&quot;&gt;&lt;/a&gt;递归迭代与斐波那契数列&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;head
      
    
    </summary>
    
      <category term="算法" scheme="https://cheng102e.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>java大数加法乘法</title>
    <link href="https://cheng102e.github.io/java%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95%E4%B9%98%E6%B3%95.html"/>
    <id>https://cheng102e.github.io/java大数加法乘法.html</id>
    <published>2020-02-22T08:00:00.000Z</published>
    <updated>2020-02-22T08:06:01.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java大数加法乘法"><a href="#java大数加法乘法" class="headerlink" title="java大数加法乘法"></a>java大数加法乘法</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>正常情况下我们调用加法乘法使用符号就行了，但是如果超出限制了，那就只能调用BigDecimal里面的函数了，但是有的时候oj考察的就是希望自己实现，所以就可以采用别的方法。</p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>加法比较简单，直接字符串转置，差的位补0，然后一位一位加，最后注意进位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static String add(String s1, String s2) &#123;</span><br><span class="line">  StringBuilder a = new StringBuilder(s1);</span><br><span class="line">  StringBuilder b = new StringBuilder(s2);</span><br><span class="line">  a.reverse();</span><br><span class="line">  b.reverse();</span><br><span class="line"></span><br><span class="line">  int m = a.length();</span><br><span class="line">  int n = b.length();</span><br><span class="line">  int max = Math.max(m, n);</span><br><span class="line">  if (m &lt; n) &#123;</span><br><span class="line">    for (int i = m; i &lt; n; i++) &#123;</span><br><span class="line">      a.append(&apos;0&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (int i = n; i &lt; m; i++) &#123;</span><br><span class="line">      b.append(&apos;0&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int[] ans = new int[max + 1];</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">    ans[i] = (a.charAt(i) - &apos;0&apos;) + (b.charAt(i) - &apos;0&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">    ans[i + 1] += ans[i] / 10;</span><br><span class="line">    ans[i] %= 10;</span><br><span class="line">  &#125;</span><br><span class="line">  StringBuilder result = new StringBuilder();</span><br><span class="line">  for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">    result.append(ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  if(ans[max]!=0)</span><br><span class="line">  &#123;</span><br><span class="line">    result.append(ans[max]);</span><br><span class="line">  &#125;</span><br><span class="line">  return result.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>以12*12为例子，第1位的两个2相乘，结果应该放在第1位，是4，然后第一个数的1和第二个数的2相乘是2，应该是第二位，2+2，然后两个1相乘，1应该放在第3位，结果是144，这个没有进位，如果有进位需要遍历一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static String mul(String s1, String s2) &#123;</span><br><span class="line">    StringBuilder a = new StringBuilder(s1);</span><br><span class="line">    StringBuilder b = new StringBuilder(s2);</span><br><span class="line">    a.reverse();</span><br><span class="line">    b.reverse();</span><br><span class="line"></span><br><span class="line">    int m = a.length();</span><br><span class="line">    int n = b.length();</span><br><span class="line"></span><br><span class="line">    int[] ans = new int[m + n];</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">      for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        ans[i + j] += (a.charAt(i) - &apos;0&apos;) * (b.charAt(j) - &apos;0&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; ans.length - 1; i++) &#123;</span><br><span class="line">      ans[i + 1] += ans[i] / 10;</span><br><span class="line">      ans[i] %= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; ans.length - 1; i++) &#123;</span><br><span class="line">      result.append(ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.reverse().toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java大数加法乘法&quot;&gt;&lt;a href=&quot;#java大数加法乘法&quot; class=&quot;headerlink&quot; title=&quot;java大数加法乘法&quot;&gt;&lt;/a&gt;java大数加法乘法&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="java" scheme="https://cheng102e.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java进制转换</title>
    <link href="https://cheng102e.github.io/java%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.html"/>
    <id>https://cheng102e.github.io/java进制转换.html</id>
    <published>2020-02-22T04:00:00.000Z</published>
    <updated>2020-02-22T05:20:17.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java进制转换"><a href="#java进制转换" class="headerlink" title="java进制转换"></a>java进制转换</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们正常使用的是十进制，计算机使用的是二进制，初次之外还有很多不同的进制，但是转换方法都相似，这里就整理一下java的进制转换。</p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>  十进制转十六进制<br>  Integer.toHexString(int i)</p><p>  十进制转八进制<br>  Integer.toOctalString(int i)</p><p>  十进制转二进制<br>  Integer.toBinaryString(int i)</p><p>  十六进制转十进制(二进制八进制类似)<br>  Integer.valueOf(“FFFF”,16).toString()</p><h3 id="写的代码"><a href="#写的代码" class="headerlink" title="写的代码"></a>写的代码</h3><p>这里还写了一段java代码，可以用于进行16进制之内的转换，如果想要增加，只要修改radix数组即可。<br>两个函数，一个是其他进制转十进制的，一个是十进制转任意进制的。用的都是基础算法，按位乘和取余。<br>(话说我没有考虑过输入异常，比如0进制什么的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static char[] radix = new char[]&#123;&apos;0&apos;,&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;,</span><br><span class="line">    &apos;e&apos;, &apos;f&apos;&#125;;</span><br><span class="line"></span><br><span class="line">static int transRadixtoTen(String num, int fromRadix) &#123;</span><br><span class="line">  StringBuilder s = new StringBuilder(num);</span><br><span class="line">  int number = 0;</span><br><span class="line">  for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">    char temp = s.charAt(i);</span><br><span class="line">    if (temp &lt;= &apos;9&apos; &amp;&amp; temp &gt;= &apos;0&apos;) &#123;</span><br><span class="line">      number += temp - &apos;0&apos;;</span><br><span class="line"></span><br><span class="line">    &#125; else if (temp &lt;= &apos;z&apos; &amp;&amp; temp &gt;= &apos;a&apos;) &#123;</span><br><span class="line">      number += temp - &apos;a&apos; + 10;</span><br><span class="line"></span><br><span class="line">    &#125; else if (temp &lt;= &apos;Z&apos; &amp;&amp; temp &gt;= &apos;A&apos;) &#123;</span><br><span class="line">      number += temp - &apos;A&apos; + 10;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (i != s.length() - 1) &#123;</span><br><span class="line">      number *= fromRadix;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static String transRadixtoOther(String num, int fromRadix, int toRadix) &#123;</span><br><span class="line">  int number = transRadixtoTen(num, fromRadix);</span><br><span class="line">  System.out.println(number);</span><br><span class="line">  StringBuilder s = new StringBuilder();</span><br><span class="line">  while (number != 0) &#123;</span><br><span class="line">    s.append(radix[number % toRadix]);</span><br><span class="line">    number = number / toRadix;</span><br><span class="line">  &#125;</span><br><span class="line">  return s.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java进制转换&quot;&gt;&lt;a href=&quot;#java进制转换&quot; class=&quot;headerlink&quot; title=&quot;java进制转换&quot;&gt;&lt;/a&gt;java进制转换&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="java" scheme="https://cheng102e.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 209. Minimum Size Subarray Sum</title>
    <link href="https://cheng102e.github.io/LeetCode%20209.%20Minimum%20Size%20Subarray%20Sum.html"/>
    <id>https://cheng102e.github.io/LeetCode 209. Minimum Size Subarray Sum.html</id>
    <published>2020-02-17T12:30:00.000Z</published>
    <updated>2020-02-17T12:55:06.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="209-Minimum-Size-Subarray-Sum（无重复字符的最长子串）"><a href="#209-Minimum-Size-Subarray-Sum（无重复字符的最长子串）" class="headerlink" title="209. Minimum Size Subarray Sum（无重复字符的最长子串）"></a>209. Minimum Size Subarray Sum（无重复字符的最长子串）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-size-subarray-sum</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p><p>示例: </p><p>  输入: s = 7, nums = [2,3,1,2,4,3]<br>  输出: 2<br>  解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。<br>进阶:</p><p>如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口的题目，不过这里是数字，相对简单一点。<br>这里设置了两个指针，left就代表左侧，right代表右侧，如果和大于s，就更新min并且减去最左侧；如果小于s，就增加最右侧，最后输出min。这里有一个坑，就是有可能不存在，所以最后要对于min进行一个判断。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">  int len = nums.length;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int min = Integer.MAX_VALUE;</span><br><span class="line">  int left = 0;</span><br><span class="line">  for (int right = 0; right &lt; len; right++) &#123;</span><br><span class="line">    sum += nums[right];</span><br><span class="line">    while (sum &gt;= s) &#123;</span><br><span class="line">      min = Math.min(min, right - left + 1);</span><br><span class="line">      sum -= nums[left];</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(min== Integer.MAX_VALUE)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;209-Minimum-Size-Subarray-Sum（无重复字符的最长子串）&quot;&gt;&lt;a href=&quot;#209-Minimum-Size-Subarray-Sum（无重复字符的最长子串）&quot; class=&quot;headerlink&quot; title=&quot;209. Minim
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="https://cheng102e.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3. Longest Substring Without Repeating Characters</title>
    <link href="https://cheng102e.github.io/LeetCode%203.%20Longest%20Substring%20Without%20Repeating%20Characters.html"/>
    <id>https://cheng102e.github.io/LeetCode 3. Longest Substring Without Repeating Characters.html</id>
    <published>2020-02-17T12:20:00.000Z</published>
    <updated>2020-02-17T12:55:07.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-Longest-Substring-Without-Repeating-Characters（无重复字符的最长子串）"><a href="#3-Longest-Substring-Without-Repeating-Characters（无重复字符的最长子串）" class="headerlink" title="3. Longest Substring Without Repeating Characters（无重复字符的最长子串）"></a>3. Longest Substring Without Repeating Characters（无重复字符的最长子串）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>  输入: “abcabcbb”<br>  输出: 3<br>  解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>  输入: “bbbbb”<br>  输出: 1<br>  解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>  输入: “pwwkew”<br>  输出: 3<br>  解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口的题目，做出来不是很难，但是要优化就很麻烦。<br>这里设置了两个指针，同时借助了hashmap来去重。循环比较每一个字符，如果字符不存在就加入，如果存在了，就看在left左还是右，左侧无需在意，右侧更新，最后输出max即可。<br>（这里没有和left比较，而是直接取了较大值，left就代表当前字符串左侧，right代表当前字符串右侧）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">  int len = s.length();</span><br><span class="line">  if (len == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">  int max = 0;</span><br><span class="line">  int left = 0;</span><br><span class="line">  for (int right = 0; right &lt; len; right++) &#123;</span><br><span class="line">    if (map.containsKey(s.charAt(right))) &#123;</span><br><span class="line">      left = Math.max(left, map.get(s.charAt(right)) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s.charAt(right), right);</span><br><span class="line">    max = Math.max(max, right - left + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-Longest-Substring-Without-Repeating-Characters（无重复字符的最长子串）&quot;&gt;&lt;a href=&quot;#3-Longest-Substring-Without-Repeating-Characters（无重复字符的最长子串）
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="https://cheng102e.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 11. Container With Most Water</title>
    <link href="https://cheng102e.github.io/LeetCode%2011.%20Container%20With%20Most%20Water.html"/>
    <id>https://cheng102e.github.io/LeetCode 11. Container With Most Water.html</id>
    <published>2020-02-16T06:50:00.000Z</published>
    <updated>2020-02-17T12:55:08.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Container-With-Most-Water（反转字符串中的元音字母）"><a href="#11-Container-With-Most-Water（反转字符串中的元音字母）" class="headerlink" title="11. Container With Most Water（反转字符串中的元音字母）"></a>11. Container With Most Water（反转字符串中的元音字母）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://img2018.cnblogs.com/blog/1493464/202002/1493464-20200216143541248-1914702232.png" alt><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例:</p><p>  输入: [1,8,6,2,5,4,8,3,7]<br>  输出: 49</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题思路也很清晰，就是要求最大值，方法不少，首先就是最简单的穷举，把所有可能值都算出来，也可以采用动态规划的思想，找到最合适的方法。<br>面积取决于两个值，左右距离，和两边的较小值，当两边距离不等的时候，将较小值更换可能获得更大的面积，思路就是这样，一直选择较小的往内移动，直到两边相遇。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">  int left = 0, right = height.length - 1;</span><br><span class="line">  int max = 0;</span><br><span class="line">  while (left &lt; right) &#123;</span><br><span class="line">    max = Math.max(max, (right - left) * Math.min(height[left], height[right]));</span><br><span class="line">    if (height[left] &lt; height[right]) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-Container-With-Most-Water（反转字符串中的元音字母）&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water（反转字符串中的元音字母）&quot; class=&quot;headerlink&quot; title=&quot;11. Contai
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 345. Reverse Vowels of a String</title>
    <link href="https://cheng102e.github.io/LeetCode%20345.%20Reverse%20Vowels%20of%20a%20String.html"/>
    <id>https://cheng102e.github.io/LeetCode 345. Reverse Vowels of a String.html</id>
    <published>2020-02-16T05:50:00.000Z</published>
    <updated>2020-02-16T06:00:42.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="345-Reverse-Vowels-of-a-String（反转字符串中的元音字母）"><a href="#345-Reverse-Vowels-of-a-String（反转字符串中的元音字母）" class="headerlink" title="345. Reverse Vowels of a String（反转字符串中的元音字母）"></a>345. Reverse Vowels of a String（反转字符串中的元音字母）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-vowels-of-a-string</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p>示例 1:</p><p>  输入: “hello”<br>  输出: “holle”<br>示例 2:</p><p>  输入: “leetcode”<br>  输出: “leotcede”<br>说明:<br>元音字母不包含字母”y”。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>也是双指针，不过要注意大小写都可以，所以额外增加了一个判断函数判断是否需要反转，别的和344题基本相同。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static boolean find(char c) &#123;</span><br><span class="line">  return !(c == &apos;a&apos; || c == &apos;o&apos; || c == &apos;e&apos; || c == &apos;i&apos; || c == &apos;u&apos; || c == &apos;A&apos; || c == &apos;O&apos;</span><br><span class="line">      || c == &apos;E&apos; || c == &apos;I&apos; || c == &apos;U&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String reverseVowels(String s) &#123;</span><br><span class="line">  char[] arr = s.toCharArray();</span><br><span class="line">  int left = 0, right = arr.length - 1;</span><br><span class="line">  while (left &lt; right) &#123;</span><br><span class="line">    while (left &lt; arr.length &amp;&amp; find(arr[left])) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (right &gt;= 0 &amp;&amp; find(arr[right])) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (left &gt;= right) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    char temp = arr[right];</span><br><span class="line">    arr[right--] = arr[left];</span><br><span class="line">    arr[left++] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  String result = new String(arr);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;345-Reverse-Vowels-of-a-String（反转字符串中的元音字母）&quot;&gt;&lt;a href=&quot;#345-Reverse-Vowels-of-a-String（反转字符串中的元音字母）&quot; class=&quot;headerlink&quot; title=&quot;345. R
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 344. Reverse String</title>
    <link href="https://cheng102e.github.io/LeetCode%20344.%20Reverse%20String.html"/>
    <id>https://cheng102e.github.io/LeetCode 344. Reverse String.html</id>
    <published>2020-02-16T04:50:00.000Z</published>
    <updated>2020-02-16T05:11:03.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="344-Reverse-String（反转字符串）"><a href="#344-Reverse-String（反转字符串）" class="headerlink" title="344. Reverse String（反转字符串）"></a>344. Reverse String（反转字符串）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：</p><p>  输入：[“h”,”e”,”l”,”l”,”o”]<br>  输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p><p>  输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>  输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就硬转呗，双指针，一头一尾直接转换位置，当指针相遇就结束。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void reverseString(char[] s) &#123;</span><br><span class="line">    int left = 0, right = s.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">      char temp = s[left];</span><br><span class="line">      s[left] = s[right];</span><br><span class="line">      s[right] = temp;</span><br><span class="line">      left++;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;344-Reverse-String（反转字符串）&quot;&gt;&lt;a href=&quot;#344-Reverse-String（反转字符串）&quot; class=&quot;headerlink&quot; title=&quot;344. Reverse String（反转字符串）&quot;&gt;&lt;/a&gt;344. Rever
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 215. Kth Largest Element in an Array</title>
    <link href="https://cheng102e.github.io/LeetCode%20215.%20Kth%20Largest%20Element%20in%20an%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 215. Kth Largest Element in an Array.html</id>
    <published>2020-02-16T04:50:00.000Z</published>
    <updated>2020-02-16T05:09:01.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="215-Kth-Largest-Element-in-an-Array（数组中的第K个最大元素）"><a href="#215-Kth-Largest-Element-in-an-Array（数组中的第K个最大元素）" class="headerlink" title="215. Kth Largest Element in an Array（数组中的第K个最大元素）"></a>215. Kth Largest Element in an Array（数组中的第K个最大元素）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>  输入: [3,2,1,5,6,4] 和 k = 2<br>  输出: 5<br>示例 2:</p><p>  输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>  输出: 4<br>说明:</p><p>  你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道数组题目，解法多种。<br>最简单的就是直接排序，然后找到那个数，直接完成，就是效率相对较低。<br>这里用的是优先队列建堆，最小堆，小的数字在堆顶，然后一个一个往里面加数字，每当堆的规模大于k，就去除最小的数字（堆顶），数字处理完之后的堆顶就是所需数字。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">  PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">      new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n1 - n2);</span><br><span class="line">  for (int n : nums) &#123;</span><br><span class="line">    heap.add(n);</span><br><span class="line">    if (heap.size() &gt; k) &#123;</span><br><span class="line">      heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return heap.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;215-Kth-Largest-Element-in-an-Array（数组中的第K个最大元素）&quot;&gt;&lt;a href=&quot;#215-Kth-Largest-Element-in-an-Array（数组中的第K个最大元素）&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 88. Merge Sorted Array</title>
    <link href="https://cheng102e.github.io/LeetCode%2088.%20Merge%20Sorted%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 88. Merge Sorted Array.html</id>
    <published>2020-02-14T14:50:00.000Z</published>
    <updated>2020-02-16T05:08:50.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="88-Merge-Sorted-Array（合并两个有序数组）"><a href="#88-Merge-Sorted-Array（合并两个有序数组）" class="headerlink" title="88. Merge Sorted Array（合并两个有序数组）"></a>88. Merge Sorted Array（合并两个有序数组）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><p>  输入:<br>  nums1 = [1,2,3,0,0,0], m = 3<br>  nums2 = [2,5,6],       n = 3</p><p>  输出: [1,2,2,3,5,6]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道数组题目，解法多种。<br>可以直接合并再排序，也可以两个数组开头慢慢遍历，倒是官方给了一种很cool的题解，直接从数组后方开始。<br>三指针，两个指针指向两个数组最后的数字，一个指针指向数组1的末尾，比较之后将数字放到数组1的末尾，不需要额外空间，最后将数组2未使用的数字（如果存在的话）放到数组1的前面即可。<br>（这题我去年好像做过，还没做出来233333）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">  int index = m + n - 1;</span><br><span class="line">  int m1 = m - 1;</span><br><span class="line">  int n1 = n - 1;</span><br><span class="line">  while (m1 &gt;= 0 &amp;&amp; n1 &gt;= 0) &#123;</span><br><span class="line">    if (nums1[m1] &lt; nums2[n1]) &#123;</span><br><span class="line">      nums1[index] = nums2[n1];</span><br><span class="line">      n1--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      nums1[index] = nums1[m1];</span><br><span class="line">      m1--;</span><br><span class="line">    &#125;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">  while (n1 &gt;= 0) &#123;</span><br><span class="line">    nums1[index] = nums2[n1];</span><br><span class="line">    n1--;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;88-Merge-Sorted-Array（合并两个有序数组）&quot;&gt;&lt;a href=&quot;#88-Merge-Sorted-Array（合并两个有序数组）&quot; class=&quot;headerlink&quot; title=&quot;88. Merge Sorted Array（合并两个有序数
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 75. Sort Colors</title>
    <link href="https://cheng102e.github.io/LeetCode%2075.%20Sort%20Colors.html"/>
    <id>https://cheng102e.github.io/LeetCode 75. Sort Colors.html</id>
    <published>2020-02-14T12:50:00.000Z</published>
    <updated>2020-02-14T12:48:27.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="75-Sort-Colors（颜色分类）"><a href="#75-Sort-Colors（颜色分类）" class="headerlink" title="75. Sort Colors（颜色分类）"></a>75. Sort Colors（颜色分类）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><p>  输入: [2,0,2,1,1,0]<br>  输出: [0,0,1,1,2,2]<br>进阶：</p><p>  一个直观的解决方案是使用计数排序的两趟扫描算法。<br>  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>  你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道数组题目，解法多种。<br>说不让用代码库中的排序函数，那自己写一个应该不算违规吧23333.<br>只有三种数字，012，那么可以遍历统计每个数字的数量，之后直接更改。<br>也可以用三指针法，index012，一共三个变量，index0和1初始值是0，index2初始值是nums.length-1.遍历使用index1，发现那个数字为0，就和index0的数交换，为2就和index2的数交换，这里要注意，index2换过来的数还需要再判断一下。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  public static void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">  int temp = nums[i];</span><br><span class="line">  nums[i] = nums[j];</span><br><span class="line">  nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">  int index0 = 0, index1 = 0, index2 = nums.length - 1;</span><br><span class="line">  while (index1 &lt;= index2) &#123;</span><br><span class="line">    if (nums[index1] == 0) &#123;</span><br><span class="line">      swap(nums, index1, index0);</span><br><span class="line">      index0++;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125; else if (nums[index1] == 2) &#123;</span><br><span class="line">      swap(nums, index1, index2);</span><br><span class="line">      index2--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;75-Sort-Colors（颜色分类）&quot;&gt;&lt;a href=&quot;#75-Sort-Colors（颜色分类）&quot; class=&quot;headerlink&quot; title=&quot;75. Sort Colors（颜色分类）&quot;&gt;&lt;/a&gt;75. Sort Colors（颜色分类）&lt;/h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 581. Shortest Unsorted Continuous Subarray</title>
    <link href="https://cheng102e.github.io/LeetCode%20581.%20Shortest%20Unsorted%20Continuous%20Subarray.html"/>
    <id>https://cheng102e.github.io/LeetCode 581. Shortest Unsorted Continuous Subarray.html</id>
    <published>2020-02-12T03:13:00.000Z</published>
    <updated>2020-02-12T03:20:18.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）"><a href="#581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）" class="headerlink" title="581. Shortest Unsorted Continuous Subarray（最短无序连续子数组）"></a>581. Shortest Unsorted Continuous Subarray（最短无序连续子数组）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:</p><p>  输入: [2, 6, 4, 8, 10, 9, 15]<br>  输出: 5<br>  解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。<br>说明 :</p><p>输入的数组长度范围在 [1, 10,000]。<br>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题方法多种，可以排序之后对比，也可以用别的方法。<br>首先遍历，由前往后由后往前，分别确定两个边界。前向后时寻找右边界，每个数字判断是否小于前方最大值，若小于，就代表这个数需要排序，若大于，就代表这个数可以放在当前位置，若最后全为升序排列那就不用排序，后向前同理。<br>以输入示范，首先max为2，之后往后遍历，6&gt;2,max=6,4&lt;6,需要排序，一直往后，right=5，15大于前方所有数字，无需排序。反向遍历，2小于后方所有数，left=1，5-1+1=5.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int findUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">  int len = nums.length;</span><br><span class="line">  int max = nums[0];</span><br><span class="line">  int min = nums[len - 1];</span><br><span class="line">  int left = 0, right = -1;</span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    if (max &gt; nums[i]) &#123;</span><br><span class="line">      right = i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = len - 1; i &gt; -1; i--) &#123;</span><br><span class="line">    if (min &lt; nums[i]) &#123;</span><br><span class="line">      left = i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      min = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return right - left + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）&quot;&gt;&lt;a href=&quot;#581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
</feed>
