<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-03-14T09:53:50.004Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 1038. Binary Search Tree to Greater Sum Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%201038.%20Binary%20Search%20Tree%20to%20Greater%20Sum%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 1038. Binary Search Tree to Greater Sum Tree.html</id>
    <published>2020-03-14T09:21:00.000Z</published>
    <updated>2020-03-14T09:53:50.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree（从二叉搜索树到更大和树）"><a href="#1038-Binary-Search-Tree-to-Greater-Sum-Tree（从二叉搜索树到更大和树）" class="headerlink" title="1038. Binary Search Tree to Greater Sum Tree（从二叉搜索树到更大和树）"></a>1038. Binary Search Tree to Greater Sum Tree（从二叉搜索树到更大和树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给出二叉 搜索 树的根节点，该二叉树的节点值各不相同，修改二叉树，使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p><p>示例：</p><p>  输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>  输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><p>提示：</p><p>树中的节点数介于 1 和 100 之间。<br>每个节点的值介于 0 和 100 之间。<br>给定的树为二叉搜索树。</p><p>注意：该题目与 538: <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a>  相同</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>偷了个懒，代码和538的是一样的。<br>直接递归，新建一个sum拿来存储值，然后修改结点值，这里记得右中左的方式。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line"></span><br><span class="line">public TreeNode bstToGst(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line"></span><br><span class="line">    bstToGst(root.right);</span><br><span class="line">    sum += root.val;</span><br><span class="line">    root.val = sum;</span><br><span class="line">    bstToGst(root.left);</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1038-Binary-Search-Tree-to-Greater-Sum-Tree（从二叉搜索树到更大和树）&quot;&gt;&lt;a href=&quot;#1038-Binary-Search-Tree-to-Greater-Sum-Tree（从二叉搜索树到更大和树）&quot; class=
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 538. Convert BST to Greater Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20538.%20Convert%20BST%20to%20Greater%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 538. Convert BST to Greater Tree.html</id>
    <published>2020-03-14T09:20:00.000Z</published>
    <updated>2020-03-14T09:19:52.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="538-Convert-BST-to-Greater-Tree（把二叉搜索树转换为累加树）"><a href="#538-Convert-BST-to-Greater-Tree（把二叉搜索树转换为累加树）" class="headerlink" title="538. Convert BST to Greater Tree（把二叉搜索树转换为累加树）"></a>538. Convert BST to Greater Tree（把二叉搜索树转换为累加树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：</p><p>输入: 原始二叉搜索树:<br>              5<br>            /   <br>           2     13</p><p>输出: 转换为累加树:<br>             18<br>            /   <br>          20     13</p><p>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接递归，新建一个sum拿来存储值，然后修改结点值，这里记得右中左的方式。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line"></span><br><span class="line">public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line"></span><br><span class="line">    convertBST(root.right);</span><br><span class="line">    sum += root.val;</span><br><span class="line">    root.val = sum;</span><br><span class="line">    convertBST(root.left);</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;538-Convert-BST-to-Greater-Tree（把二叉搜索树转换为累加树）&quot;&gt;&lt;a href=&quot;#538-Convert-BST-to-Greater-Tree（把二叉搜索树转换为累加树）&quot; class=&quot;headerlink&quot; title=&quot;53
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 141. Linked List Cycle</title>
    <link href="https://cheng102e.github.io/LeetCode%20141.%20Linked%20List%20Cycle.html"/>
    <id>https://cheng102e.github.io/LeetCode 141. Linked List Cycle.html</id>
    <published>2020-03-14T07:40:00.000Z</published>
    <updated>2020-03-14T08:17:22.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="141-Linked-List-Cycle（环形链表）"><a href="#141-Linked-List-Cycle（环形链表）" class="headerlink" title="141. Linked List Cycle（环形链表）"></a>141. Linked List Cycle（环形链表）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><p>  输入：head = [3,2,0,-4], pos = 1<br>  输出：true<br>  解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：</p><p>  输入：head = [1,2], pos = 0<br>  输出：true<br>  解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：</p><p>  输入：head = [1], pos = -1<br>  输出：false<br>  解释：链表中没有环。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>快慢指针法，快的一次走两步，慢的一次走一步，每次的差值都是1步，如果快的能追上慢的，就代表成环。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next;</span><br><span class="line"></span><br><span class="line">  ListNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">    next = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">  if (head == null || head.next == null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode slow = head;</span><br><span class="line">  ListNode fast = head.next;</span><br><span class="line">  while (slow != fast) &#123;</span><br><span class="line">    if (fast.next == null || fast.next.next == null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;141-Linked-List-Cycle（环形链表）&quot;&gt;&lt;a href=&quot;#141-Linked-List-Cycle（环形链表）&quot; class=&quot;headerlink&quot; title=&quot;141. Linked List Cycle（环形链表）&quot;&gt;&lt;/a&gt;141.
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 155. Min Stack</title>
    <link href="https://cheng102e.github.io/LeetCode%20155.%20Min%20Stack.html"/>
    <id>https://cheng102e.github.io/LeetCode 155. Min Stack.html</id>
    <published>2020-03-14T03:40:00.000Z</published>
    <updated>2020-03-14T03:43:03.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="155-Min-Stack（最小栈）"><a href="#155-Min-Stack（最小栈）" class="headerlink" title="155. Min Stack（最小栈）"></a>155. Min Stack（最小栈）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br>示例:</p><p>  MinStack minStack = new MinStack();<br>  minStack.push(-2);<br>  minStack.push(0);<br>  minStack.push(-3);<br>  minStack.getMin();   –&gt; 返回 -3.<br>  minStack.pop();<br>  minStack.top();      –&gt; 返回 0.<br>  minStack.getMin();   –&gt; 返回 -2.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里用了两个栈，一个栈用于存放数据，一个栈用于存放最小值。<br>对于新的数据，如果x小于最小值栈的栈顶，那就将这个数字进入最小值栈，不然就将栈顶数字再入栈一次，出栈的时候两个一起出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Stack&lt;Integer&gt; stackdata;</span><br><span class="line"> Stack&lt;Integer&gt; stackmin;</span><br><span class="line"></span><br><span class="line">/* public MinStack() &#123;</span><br><span class="line">   stackdata = new Stack&lt;&gt;();</span><br><span class="line">   stackmin = new Stack&lt;&gt;();</span><br><span class="line"> &#125;*/</span><br><span class="line"></span><br><span class="line"> public void push(int x) &#123;</span><br><span class="line">   stackdata.push(x);</span><br><span class="line"></span><br><span class="line">   if (stackmin.empty()) &#123;</span><br><span class="line">     stackmin.push(x);</span><br><span class="line">   &#125; else if (x &lt; stackmin.peek()) &#123;</span><br><span class="line">     stackmin.push(x);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     stackmin.push(stackmin.peek());</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void pop() &#123;</span><br><span class="line">   if (!stackdata.empty()) &#123;</span><br><span class="line">     stackdata.pop();</span><br><span class="line">     stackmin.pop();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public int top() &#123;</span><br><span class="line">   return stackdata.peek();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public int getMin() &#123;</span><br><span class="line">   return stackmin.peek();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;155-Min-Stack（最小栈）&quot;&gt;&lt;a href=&quot;#155-Min-Stack（最小栈）&quot; class=&quot;headerlink&quot; title=&quot;155. Min Stack（最小栈）&quot;&gt;&lt;/a&gt;155. Min Stack（最小栈）&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 300. Longest Increasing Subsequence</title>
    <link href="https://cheng102e.github.io/LeetCode%20300.%20Longest%20Increasing%20Subsequence.html"/>
    <id>https://cheng102e.github.io/LeetCode 300. Longest Increasing Subsequence.html</id>
    <published>2020-03-14T01:58:00.000Z</published>
    <updated>2020-03-14T02:04:08.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="300-Longest-Increasing-Subsequence（最长上升子序列）"><a href="#300-Longest-Increasing-Subsequence（最长上升子序列）" class="headerlink" title="300. Longest Increasing Subsequence（最长上升子序列）"></a>300. Longest Increasing Subsequence（最长上升子序列）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>  输入: [10,9,2,5,3,7,101,18]<br>  输出: 4<br>  解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p><p>  可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>  你算法的时间复杂度应该为 O(n2) 。</p><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>n2的我是拿动态规划做的，但是nlogn我没什么思路，就没写。<br>增加一个dp数组，初始值为1，当遍历到第i个数时，比较前方的所有数，若比第i个数小，就可以构成上升子序列，找到最长的那个存储在dp中，最后输出最大值即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">  int len = nums.length;</span><br><span class="line">  if (len &lt;= 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] dp = new int[len];</span><br><span class="line">  dp[0] = 1;</span><br><span class="line">  int max = 1;</span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i] = 1;</span><br><span class="line">    for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">      if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[i] &gt; max) &#123;</span><br><span class="line">      max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;300-Longest-Increasing-Subsequence（最长上升子序列）&quot;&gt;&lt;a href=&quot;#300-Longest-Increasing-Subsequence（最长上升子序列）&quot; class=&quot;headerlink&quot; title=&quot;300. L
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 617. Merge Two Binary Trees</title>
    <link href="https://cheng102e.github.io/LeetCode%20617.%20Merge%20Two%20Binary%20Trees.html"/>
    <id>https://cheng102e.github.io/LeetCode 617. Merge Two Binary Trees.html</id>
    <published>2020-03-13T14:16:00.000Z</published>
    <updated>2020-03-14T01:59:07.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="617-Merge-Two-Binary-Trees（合并二叉树）"><a href="#617-Merge-Two-Binary-Trees（合并二叉树）" class="headerlink" title="617. Merge Two Binary Trees（合并二叉树）"></a>617. Merge Two Binary Trees（合并二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和前面几道树的题相似，都借助了递归。<br>这里将t2加到t1上，若某一个为空，就接入不为空的，都不为空，就将数值相加。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;</span><br><span class="line">  if (t1 == null) &#123;</span><br><span class="line">    return t2;</span><br><span class="line">  &#125;if (t2 == null) &#123;</span><br><span class="line">    return t1;</span><br><span class="line">  &#125;</span><br><span class="line">  t1.val += t2.val;</span><br><span class="line">  t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">  t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">  return t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;617-Merge-Two-Binary-Trees（合并二叉树）&quot;&gt;&lt;a href=&quot;#617-Merge-Two-Binary-Trees（合并二叉树）&quot; class=&quot;headerlink&quot; title=&quot;617. Merge Two Binary Tree
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 226. Invert Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20226.%20Invert%20Binary%20Tree%20copy.html"/>
    <id>https://cheng102e.github.io/LeetCode 226. Invert Binary Tree copy.html</id>
    <published>2020-03-13T11:16:00.000Z</published>
    <updated>2020-03-13T12:03:51.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="226-Invert-Binary-Tree（翻转二叉树）"><a href="#226-Invert-Binary-Tree（翻转二叉树）" class="headerlink" title="226. Invert Binary Tree（翻转二叉树）"></a>226. Invert Binary Tree（翻转二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>输出：</p><pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单题目，对于每一个结点，都交换左右子节点，然后交换完整棵树就结束了。设置一个临时结点，然后递归即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    if (root.left != null) &#123;</span><br><span class="line">      invertTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null) &#123;</span><br><span class="line">      invertTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;226-Invert-Binary-Tree（翻转二叉树）&quot;&gt;&lt;a href=&quot;#226-Invert-Binary-Tree（翻转二叉树）&quot; class=&quot;headerlink&quot; title=&quot;226. Invert Binary Tree（翻转二叉树）&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 226. Invert Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20226.%20Invert%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 226. Invert Binary Tree.html</id>
    <published>2020-03-13T11:16:00.000Z</published>
    <updated>2020-03-13T11:58:52.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="226-Invert-Binary-Tree（翻转二叉树）"><a href="#226-Invert-Binary-Tree（翻转二叉树）" class="headerlink" title="226. Invert Binary Tree（翻转二叉树）"></a>226. Invert Binary Tree（翻转二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>输出：</p><pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单题目，对于每一个结点，都交换左右子节点，然后交换完整棵树就结束了。设置一个临时结点，然后递归即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    if (root.left != null) &#123;</span><br><span class="line">      invertTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null) &#123;</span><br><span class="line">      invertTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;226-Invert-Binary-Tree（翻转二叉树）&quot;&gt;&lt;a href=&quot;#226-Invert-Binary-Tree（翻转二叉树）&quot; class=&quot;headerlink&quot; title=&quot;226. Invert Binary Tree（翻转二叉树）&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 101. Symmetric Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20101.%20Symmetric%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 101. Symmetric Tree.html</id>
    <published>2020-03-13T07:16:00.000Z</published>
    <updated>2020-03-13T07:15:39.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="101-Symmetric-Tree（对称二叉树）"><a href="#101-Symmetric-Tree（对称二叉树）" class="headerlink" title="101. Symmetric Tree（对称二叉树）"></a>101. Symmetric Tree（对称二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>1</code></pre><p>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>1</code></pre><p>   / <br>  2   2<br>   \   <br>   3    3<br>说明:</p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>树的题目，尤其是二叉树，用递归和迭代都能减少运算量，这里用递归。<br>首先是根节点的判断，为空那么符合，之后就是递归过程，先查看左右子节点，相同的话继续比较左子树左节点和右子树右节点，左子树右节点和右子树左节点，如果不同，直接false。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean test(TreeNode l, TreeNode r) &#123;</span><br><span class="line">  if (l == null &amp;&amp; r == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (l == null || r == null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (l.val == r.val) &#123;</span><br><span class="line">    return test(l.left, r.right) &amp;&amp; test(l.right, r.left);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return test(root.left, root.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;101-Symmetric-Tree（对称二叉树）&quot;&gt;&lt;a href=&quot;#101-Symmetric-Tree（对称二叉树）&quot; class=&quot;headerlink&quot; title=&quot;101. Symmetric Tree（对称二叉树）&quot;&gt;&lt;/a&gt;101. Symme
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 21. Merge Two Sorted Lists</title>
    <link href="https://cheng102e.github.io/LeetCode%2021.%20Merge%20Two%20Sorted%20Lists.html"/>
    <id>https://cheng102e.github.io/LeetCode 21. Merge Two Sorted Lists.html</id>
    <published>2020-03-13T06:46:00.000Z</published>
    <updated>2020-03-13T06:52:56.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-Merge-Two-Sorted-Lists（合并两个有序链表）"><a href="#21-Merge-Two-Sorted-Lists（合并两个有序链表）" class="headerlink" title="21. Merge Two Sorted Lists（合并两个有序链表）"></a>21. Merge Two Sorted Lists（合并两个有序链表）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>  输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>  输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单的链表题目，可以循环做，也可以递归做，这里采用的是递归。<br>如果结点为空，那么后面就不用继续判断，直接加到尾部即可，不然的话就需要比较两个结点的大小，小的加入，大的继续运算。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next;</span><br><span class="line"></span><br><span class="line">  ListNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">  if (l1 == null) &#123;</span><br><span class="line">    return l2;</span><br><span class="line">  &#125;</span><br><span class="line">  if (l2 == null) &#123;</span><br><span class="line">    return l1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(l1.val&lt;l2.val)&#123;</span><br><span class="line">    l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">    return l1;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">    return l2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-Merge-Two-Sorted-Lists（合并两个有序链表）&quot;&gt;&lt;a href=&quot;#21-Merge-Two-Sorted-Lists（合并两个有序链表）&quot; class=&quot;headerlink&quot; title=&quot;21. Merge Two Sorted L
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1071. Greatest Common Divisor of Strings</title>
    <link href="https://cheng102e.github.io/LeetCode%201071.%20Greatest%20Common%20Divisor%20of%20Strings.html"/>
    <id>https://cheng102e.github.io/LeetCode 1071. Greatest Common Divisor of Strings.html</id>
    <published>2020-03-11T03:29:00.000Z</published>
    <updated>2020-03-12T03:51:07.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1071-Greatest-Common-Divisor-of-Strings（字符串的最大公因子）"><a href="#1071-Greatest-Common-Divisor-of-Strings（字符串的最大公因子）" class="headerlink" title="1071. Greatest Common Divisor of Strings（字符串的最大公因子）"></a>1071. Greatest Common Divisor of Strings（字符串的最大公因子）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-common-divisor-of-strings</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p>示例 1：</p><p>  输入：str1 = “ABCABC”, str2 = “ABC”<br>  输出：”ABC”<br>示例 2：</p><p>  输入：str1 = “ABABAB”, str2 = “ABAB”<br>  输出：”AB”<br>示例 3：</p><p>  输入：str1 = “LEET”, str2 = “CODE”<br>  输出：””</p><p>提示：</p><p>  1 &lt;= str1.length &lt;= 1000<br>  1 &lt;= str2.length &lt;= 1000<br>  str1[i] 和 str2[i] 为大写英文字母</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>算是数学题吧，如果str1+str2和str2+str1相同的话，那就存在想要求的公约数，并且长度就已经知道了，就是字符串长度的公约数，只需要输出长的字符串截取的那部分即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int gcd(int a, int b) &#123;</span><br><span class="line">  if (b == 0) &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return gcd(b, a % b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String gcdOfStrings(String str1, String str2) &#123;</span><br><span class="line">  if ((str1 + str2).equals(str2 + str1)) &#123;</span><br><span class="line">    return str1.substring(0, gcd(str1.length(), str2.length()));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1071-Greatest-Common-Divisor-of-Strings（字符串的最大公因子）&quot;&gt;&lt;a href=&quot;#1071-Greatest-Common-Divisor-of-Strings（字符串的最大公因子）&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1013. Partition Array Into Three Parts With Equal Sum</title>
    <link href="https://cheng102e.github.io/LeetCode%201013.%20Partition%20Array%20Into%20Three%20Parts%20With%20Equal%20Sum.html"/>
    <id>https://cheng102e.github.io/LeetCode 1013. Partition Array Into Three Parts With Equal Sum.html</id>
    <published>2020-03-11T01:29:00.000Z</published>
    <updated>2020-03-11T02:16:28.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1013-Partition-Array-Into-Three-Parts-With-Equal-Sum（将数组分成和相等的三个部分）"><a href="#1013-Partition-Array-Into-Three-Parts-With-Equal-Sum（将数组分成和相等的三个部分）" class="headerlink" title="1013. Partition Array Into Three Parts With Equal Sum（将数组分成和相等的三个部分）"></a>1013. Partition Array Into Three Parts With Equal Sum（将数组分成和相等的三个部分）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p><p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p><p>示例 1：</p><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1<br>示例 2：</p><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false<br>示例 3：</p><p>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p><p>提示：</p><p>3 &lt;= A.length &lt;= 50000<br>-10^4 &lt;= A[i] &lt;= 10^4</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>普通的数组题，最多多挖了几个坑。<br>首先统计整个数组的和，如果能被三整除就进行下一步。<br>从前从后同时开始，如果部分和等于总数的三分之一，那么就不在前进，等到两边都为1/3，中间自然也是1/3.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean canThreePartsEqualSum(int[] A) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (int i = 0; i &lt; A.length; i++) &#123;</span><br><span class="line">    sum += A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  if (sum % 3 != 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = sum / 3;</span><br><span class="line">  int suma = A[0], sumc = A[A.length - 1];</span><br><span class="line">  int i = 1, j = A.length - 2;</span><br><span class="line">  while (i &lt; j) &#123;</span><br><span class="line">    if (suma != sum) &#123;</span><br><span class="line">      suma += A[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    if (sumc != sum) &#123;</span><br><span class="line">      sumc += A[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    if (suma == sum &amp;&amp; sumc == sum &amp;&amp; i &lt;= j) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1013-Partition-Array-Into-Three-Parts-With-Equal-Sum（将数组分成和相等的三个部分）&quot;&gt;&lt;a href=&quot;#1013-Partition-Array-Into-Three-Parts-With-Equal-Sum（
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 322. Coin Change</title>
    <link href="https://cheng102e.github.io/LeetCode%20322.%20Coin%20Change.html"/>
    <id>https://cheng102e.github.io/LeetCode 322. Coin Change.html</id>
    <published>2020-03-08T13:29:00.000Z</published>
    <updated>2020-03-09T02:41:01.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="322-Coin-Change（零钱兑换）"><a href="#322-Coin-Change（零钱兑换）" class="headerlink" title="322. Coin Change（零钱兑换）"></a>322. Coin Change（零钱兑换）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>示例 1:</p><p>  输入: coins = [1, 2, 5], amount = 11<br>  输出: 3<br>  解释: 11 = 5 + 5 + 1</p><p>示例 2:</p><p>  输入: coins = [2], amount = 3<br>  输出: -1</p><p>说明:<br>  你可以认为每种硬币的数量是无限的。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划题目，设置一个dp数组用于存储中间结果，外层循环的i就代表金额的数量，内层代表硬币，状态转移方程是dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)，</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">  if (coins.length == 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] dp = new int[amount + 1];</span><br><span class="line">  dp[0] = 0;</span><br><span class="line">  for (int i = 1; i &lt;= amount; i++) &#123;</span><br><span class="line">    dp[i] = amount + 1;</span><br><span class="line">    for (int j = 0; j &lt; coins.length; j++) &#123;</span><br><span class="line">      if (i &gt;= coins[j]) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (dp[amount] == amount + 1) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;322-Coin-Change（零钱兑换）&quot;&gt;&lt;a href=&quot;#322-Coin-Change（零钱兑换）&quot; class=&quot;headerlink&quot; title=&quot;322. Coin Change（零钱兑换）&quot;&gt;&lt;/a&gt;322. Coin Change（零钱兑换）
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 0.n个骰子的点数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%200.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 0.n个骰子的点数.html</id>
    <published>2020-03-07T02:40:00.000Z</published>
    <updated>2020-03-07T02:38:42.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-0-n个骰子的点数"><a href="#剑指offer-0-n个骰子的点数" class="headerlink" title="剑指offer 0.n个骰子的点数"></a>剑指offer 0.n个骰子的点数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p>示例 1:</p><p>  输入: 1<br>  输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]<br>示例 2:</p><p>  输入: 2<br>  输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</p><p>限制：</p><p>  1 &lt;= n &lt;= 11</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题本来是在书里面的，但是牛客上面没有，所以我就去LeetCode做了这道题。<br>动态规划方法，用dp[i][j]来存储出现的次数，i表示骰子的个数，j表示点数。<br>dp[i][j]=dp[i-1][j-1]+dp[i-1][j-2]+dp[i-1][j-3]+dp[i-1][j-4]+dp[i-1][j-5]+dp[i-1][j-6],设置循环即可。<br>(剑指offer这本书到这就算刷完了)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public double[] twoSum(int n) &#123;</span><br><span class="line">  int[][] dp = new int[n + 1][6 * n + 1];</span><br><span class="line">  double[] ans = new double[5 * n + 1];</span><br><span class="line">  double all = Math.pow(6, n);</span><br><span class="line">  for (int i = 1; i &lt;= 6; i++) &#123;</span><br><span class="line">    dp[1][i] = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    for (int j = i; j &lt;= 6 * n; j++) &#123;</span><br><span class="line">      for (int k = 1; k &lt;= 6; k++) &#123;</span><br><span class="line">        dp[i][j] += j &gt;= k ? dp[i - 1][j - k] : 0;</span><br><span class="line">        if (i == n) &#123;</span><br><span class="line">          ans[j - i] = dp[i][j] / all;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-0-n个骰子的点数&quot;&gt;&lt;a href=&quot;#剑指offer-0-n个骰子的点数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 0.n个骰子的点数&quot;&gt;&lt;/a&gt;剑指offer 0.n个骰子的点数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 67.剪绳子</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2067.%E5%89%AA%E7%BB%B3%E5%AD%90%20copy.html"/>
    <id>https://cheng102e.github.io/剑指offer 67.剪绳子 copy.html</id>
    <published>2020-03-06T09:40:00.000Z</published>
    <updated>2020-03-07T02:30:37.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-67-剪绳子"><a href="#剑指offer-67-剪绳子" class="headerlink" title="剑指offer 67.剪绳子"></a>剑指offer 67.剪绳子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目描述<br>  给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>输入描述:<br>  输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）<br>输出描述:<br>  输出答案。<br>示例1<br>  输入<br>  8<br>  输出<br>  18</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>。。。动态规划，对于绳子有切或者不切两种选择，如果切可以让结果更大，那就切，如果不行就不切，一米一米的延长，直到最后长度为target，输出。<br>外层循环是绳子总长度的增加，内层循环可以做个例子，6米的可以切成1+5，2+4，3+3(4+2和2+4一样)，dp存放多少米的绳子的最大乘积，那么这三种情况就是dp[1]*dp[5],dp[2]*dp[4],dp[3]*dp[3],其中最大值就是6米绳子的最大乘积，存储下来，以后继续用。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int cutRope(int target) &#123;</span><br><span class="line">  if (target == 2) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (target == 3) &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] dp = new int[target + 1];</span><br><span class="line">  dp[1] = 1;</span><br><span class="line">  dp[2] = 2;</span><br><span class="line">  dp[3] = 3;</span><br><span class="line">  int max = 0;</span><br><span class="line">  for (int i = 4; i &lt;= target; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;=i/2 ; j++) &#123;</span><br><span class="line">      max=Math.max(max,dp[j]*dp[i-j]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i]=max;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-67-剪绳子&quot;&gt;&lt;a href=&quot;#剑指offer-67-剪绳子&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 67.剪绳子&quot;&gt;&lt;/a&gt;剑指offer 67.剪绳子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 66.机器人的运动范围</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2066.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.html"/>
    <id>https://cheng102e.github.io/剑指offer 66.机器人的运动范围.html</id>
    <published>2020-03-06T09:30:00.000Z</published>
    <updated>2020-03-06T09:40:34.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-66-机器人的运动范围"><a href="#剑指offer-66-机器人的运动范围" class="headerlink" title="剑指offer 66.机器人的运动范围"></a>剑指offer 66.机器人的运动范围</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种题目可以设置标记位，上下左右四个方向可以设置为4个式子，返回值相加。<br>先假设全局为0，表示未走过，然后向四个方向走，若走过了，返回数字加一，继续走，若没走或者不能走，就去除这一条路(返回0)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int movingCount(int threshold, int rows, int cols) &#123;</span><br><span class="line">  int flag[][] = new int[rows][cols];</span><br><span class="line">  return find(0, 0, rows, cols, flag, threshold);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int find(int i, int j, int rows, int cols, int[][] flag, int threshold) &#123;</span><br><span class="line">  if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || sum(i) + sum(j) &gt; threshold</span><br><span class="line">      || flag[i][j] == 1) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  flag[i][j] = 1;</span><br><span class="line">  return find(i - 1, j, rows, cols, flag, threshold)</span><br><span class="line">      + find(i + 1, j, rows, cols, flag, threshold)</span><br><span class="line">      + find(i, j - 1, rows, cols, flag, threshold)</span><br><span class="line">      + find(i, j + 1, rows, cols, flag, threshold)</span><br><span class="line">      + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sum(int i) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  while (i &gt; 0) &#123;</span><br><span class="line">    sum += i % 10;</span><br><span class="line">    i /= 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-66-机器人的运动范围&quot;&gt;&lt;a href=&quot;#剑指offer-66-机器人的运动范围&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 66.机器人的运动范围&quot;&gt;&lt;/a&gt;剑指offer 66.机器人的运动范围&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 65.矩阵中的路径</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2065.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.html"/>
    <id>https://cheng102e.github.io/剑指offer 65.矩阵中的路径.html</id>
    <published>2020-03-06T09:20:00.000Z</published>
    <updated>2020-03-06T09:29:07.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-65-矩阵中的路径"><a href="#剑指offer-65-矩阵中的路径" class="headerlink" title="剑指offer 65.矩阵中的路径"></a>剑指offer 65.矩阵中的路径</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。(这里应该有个图但是没有)<br>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法的思路，首先先找到第一个可以的点，然后从这点开始尝试，上下左右四种情况，如果走过了的话，那么就让标志位为true，避免再次走到这一步，如果没有机会，那么回退一步，重新开始，这里要注意标志位的还原。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123;</span><br><span class="line">  boolean[] flag = new boolean[matrix.length];</span><br><span class="line">  for (int i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; cols; j++) &#123;</span><br><span class="line">      if (judge(matrix, i, j, rows, cols, flag, str, 0)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean judge(char[] matrix, int i, int j, int rows, int cols, boolean[] flag, char[] str,</span><br><span class="line">    int k) &#123;</span><br><span class="line">  int index = i * cols + j;</span><br><span class="line">  if (i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= cols || matrix[index] != str[k]</span><br><span class="line">      || flag[index] == true) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (k == str.length - 1) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  flag[index] = true;</span><br><span class="line"></span><br><span class="line">  if (judge(matrix, i - 1, j, rows, cols, flag, str, k + 1) ||</span><br><span class="line">      judge(matrix, i + 1, j, rows, cols, flag, str, k + 1) ||</span><br><span class="line">      judge(matrix, i, j - 1, rows, cols, flag, str, k + 1) ||</span><br><span class="line">      judge(matrix, i, j + 1, rows, cols, flag, str, k + 1)) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  flag[index] = false;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-65-矩阵中的路径&quot;&gt;&lt;a href=&quot;#剑指offer-65-矩阵中的路径&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 65.矩阵中的路径&quot;&gt;&lt;/a&gt;剑指offer 65.矩阵中的路径&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 64.滑动窗口的最大值</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2064.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html"/>
    <id>https://cheng102e.github.io/剑指offer 64.滑动窗口的最大值.html</id>
    <published>2020-03-06T09:00:00.000Z</published>
    <updated>2020-03-06T09:16:24.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-64-滑动窗口的最大值"><a href="#剑指offer-64-滑动窗口的最大值" class="headerlink" title="剑指offer 64.滑动窗口的最大值"></a>剑指offer 64.滑动窗口的最大值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果不考虑复杂度的话，直接加一个内循环重新搜索即可。<br>这里采用双端队列，可以在前后删除，插入的时候从后方比较，如果一个数比新的数小，那么直接删除，如果比新的数大，若超出范围就删除，未超出就无视。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123;</span><br><span class="line"></span><br><span class="line">   ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">   if (num == null) &#123;</span><br><span class="line">     return ans;</span><br><span class="line">   &#125;</span><br><span class="line">   if (num.length &lt; size || size &lt; 1) &#123;</span><br><span class="line">     return ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">   for (int i = 0; i &lt; size - 1; i++) &#123;</span><br><span class="line">     while (!list.isEmpty() &amp;&amp; num[i] &gt; num[list.getLast()]) &#123;</span><br><span class="line">       list.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line">     list.addLast(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (int i = size - 1; i &lt; num.length; i++) &#123;</span><br><span class="line">     while (!list.isEmpty() &amp;&amp; num[i] &gt; num[list.getLast()]) &#123;</span><br><span class="line">       list.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line">     list.addLast(i);</span><br><span class="line">     if (i - list.getFirst() + 1 &gt; size) &#123;</span><br><span class="line">       list.removeFirst();</span><br><span class="line">     &#125;</span><br><span class="line">     ans.add(num[list.getFirst()]);</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-64-滑动窗口的最大值&quot;&gt;&lt;a href=&quot;#剑指offer-64-滑动窗口的最大值&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 64.滑动窗口的最大值&quot;&gt;&lt;/a&gt;剑指offer 64.滑动窗口的最大值&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 63.数据流中的中位数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2063.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 63.数据流中的中位数.html</id>
    <published>2020-03-06T06:40:00.000Z</published>
    <updated>2020-03-06T06:55:06.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-63-数据流中的中位数"><a href="#剑指offer-63-数据流中的中位数" class="headerlink" title="剑指offer 63.数据流中的中位数"></a>剑指offer 63.数据流中的中位数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我一开始的想法，是排序之后直接找，但是复杂度有点高。<br>发现了一种新的方法，维持两个堆，一个最大堆，一个最小堆，确保最大堆的数都小于最小堆，两个堆的大小差距为1或0.<br>如果两边数量相同的话，取最大堆的最大值和最小堆的最小值和的一半即可，如果不同，那么就是多的那个。<br>java可以用优先队列，改一下比较器就可以了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int count = 0;</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void Insert(Integer num) &#123;</span><br><span class="line">  if (count % 2 == 0) &#123;</span><br><span class="line">    maxHeap.offer(num);</span><br><span class="line">    int filteredMaxNum = maxHeap.poll();</span><br><span class="line">    minHeap.offer(filteredMaxNum);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    minHeap.offer(num);</span><br><span class="line">    int filteredMinNum = minHeap.poll();</span><br><span class="line">    maxHeap.offer(filteredMinNum);</span><br><span class="line">  &#125;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Double GetMedian() &#123;</span><br><span class="line">  if (count % 2 == 0) &#123;</span><br><span class="line">    return new Double((minHeap.peek() + maxHeap.peek())) / 2;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return new Double(minHeap.peek());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-63-数据流中的中位数&quot;&gt;&lt;a href=&quot;#剑指offer-63-数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 63.数据流中的中位数&quot;&gt;&lt;/a&gt;剑指offer 63.数据流中的中位数&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 62.二叉搜索树的第k个结点</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2062.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 62.二叉搜索树的第k个结点.html</id>
    <published>2020-03-06T06:20:00.000Z</published>
    <updated>2020-03-06T06:38:52.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-62-二叉搜索树的第k个结点"><a href="#剑指offer-62-二叉搜索树的第k个结点" class="headerlink" title="剑指offer 62.二叉搜索树的第k个结点"></a>剑指offer 62.二叉搜索树的第k个结点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树的中序遍历是递增的，找到第k小的话，那就只需要中序遍历即可，遍历的第k个数就是所需的数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode KthNode(TreeNode pRoot, int k) &#123;</span><br><span class="line">  if(pRoot == null || k == 0) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  int count = 0;</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">  while (pRoot != null || ! stack.isEmpty()) &#123;</span><br><span class="line">    while (pRoot != null) &#123;</span><br><span class="line">      stack.push(pRoot);</span><br><span class="line">      pRoot = pRoot.left;</span><br><span class="line">    &#125;</span><br><span class="line">    pRoot = stack.pop();</span><br><span class="line">    count ++;</span><br><span class="line">    if(count == k) &#123;</span><br><span class="line">      return pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    pRoot = pRoot.right;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-62-二叉搜索树的第k个结点&quot;&gt;&lt;a href=&quot;#剑指offer-62-二叉搜索树的第k个结点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 62.二叉搜索树的第k个结点&quot;&gt;&lt;/a&gt;剑指offer 62.二叉搜索树的第k个
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
