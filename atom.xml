<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-02-17T12:55:06.074Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 209. Minimum Size Subarray Sum</title>
    <link href="https://cheng102e.github.io/LeetCode%20209.%20Minimum%20Size%20Subarray%20Sum.html"/>
    <id>https://cheng102e.github.io/LeetCode 209. Minimum Size Subarray Sum.html</id>
    <published>2020-02-17T12:30:00.000Z</published>
    <updated>2020-02-17T12:55:06.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="209-Minimum-Size-Subarray-Sum（无重复字符的最长子串）"><a href="#209-Minimum-Size-Subarray-Sum（无重复字符的最长子串）" class="headerlink" title="209. Minimum Size Subarray Sum（无重复字符的最长子串）"></a>209. Minimum Size Subarray Sum（无重复字符的最长子串）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-size-subarray-sum</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p><p>示例: </p><p>  输入: s = 7, nums = [2,3,1,2,4,3]<br>  输出: 2<br>  解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。<br>进阶:</p><p>如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口的题目，不过这里是数字，相对简单一点。<br>这里设置了两个指针，left就代表左侧，right代表右侧，如果和大于s，就更新min并且减去最左侧；如果小于s，就增加最右侧，最后输出min。这里有一个坑，就是有可能不存在，所以最后要对于min进行一个判断。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">  int len = nums.length;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int min = Integer.MAX_VALUE;</span><br><span class="line">  int left = 0;</span><br><span class="line">  for (int right = 0; right &lt; len; right++) &#123;</span><br><span class="line">    sum += nums[right];</span><br><span class="line">    while (sum &gt;= s) &#123;</span><br><span class="line">      min = Math.min(min, right - left + 1);</span><br><span class="line">      sum -= nums[left];</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(min== Integer.MAX_VALUE)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;209-Minimum-Size-Subarray-Sum（无重复字符的最长子串）&quot;&gt;&lt;a href=&quot;#209-Minimum-Size-Subarray-Sum（无重复字符的最长子串）&quot; class=&quot;headerlink&quot; title=&quot;209. Minim
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="https://cheng102e.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3. Longest Substring Without Repeating Characters</title>
    <link href="https://cheng102e.github.io/LeetCode%203.%20Longest%20Substring%20Without%20Repeating%20Characters.html"/>
    <id>https://cheng102e.github.io/LeetCode 3. Longest Substring Without Repeating Characters.html</id>
    <published>2020-02-17T12:20:00.000Z</published>
    <updated>2020-02-17T12:55:07.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-Longest-Substring-Without-Repeating-Characters（无重复字符的最长子串）"><a href="#3-Longest-Substring-Without-Repeating-Characters（无重复字符的最长子串）" class="headerlink" title="3. Longest Substring Without Repeating Characters（无重复字符的最长子串）"></a>3. Longest Substring Without Repeating Characters（无重复字符的最长子串）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>  输入: “abcabcbb”<br>  输出: 3<br>  解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>  输入: “bbbbb”<br>  输出: 1<br>  解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>  输入: “pwwkew”<br>  输出: 3<br>  解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口的题目，做出来不是很难，但是要优化就很麻烦。<br>这里设置了两个指针，同时借助了hashmap来去重。循环比较每一个字符，如果字符不存在就加入，如果存在了，就看在left左还是右，左侧无需在意，右侧更新，最后输出max即可。<br>（这里没有和left比较，而是直接取了较大值，left就代表当前字符串左侧，right代表当前字符串右侧）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">  int len = s.length();</span><br><span class="line">  if (len == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">  int max = 0;</span><br><span class="line">  int left = 0;</span><br><span class="line">  for (int right = 0; right &lt; len; right++) &#123;</span><br><span class="line">    if (map.containsKey(s.charAt(right))) &#123;</span><br><span class="line">      left = Math.max(left, map.get(s.charAt(right)) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s.charAt(right), right);</span><br><span class="line">    max = Math.max(max, right - left + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-Longest-Substring-Without-Repeating-Characters（无重复字符的最长子串）&quot;&gt;&lt;a href=&quot;#3-Longest-Substring-Without-Repeating-Characters（无重复字符的最长子串）
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="https://cheng102e.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 11. Container With Most Water</title>
    <link href="https://cheng102e.github.io/LeetCode%2011.%20Container%20With%20Most%20Water.html"/>
    <id>https://cheng102e.github.io/LeetCode 11. Container With Most Water.html</id>
    <published>2020-02-16T06:50:00.000Z</published>
    <updated>2020-02-17T12:55:08.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Container-With-Most-Water（反转字符串中的元音字母）"><a href="#11-Container-With-Most-Water（反转字符串中的元音字母）" class="headerlink" title="11. Container With Most Water（反转字符串中的元音字母）"></a>11. Container With Most Water（反转字符串中的元音字母）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://img2018.cnblogs.com/blog/1493464/202002/1493464-20200216143541248-1914702232.png" alt><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例:</p><p>  输入: [1,8,6,2,5,4,8,3,7]<br>  输出: 49</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题思路也很清晰，就是要求最大值，方法不少，首先就是最简单的穷举，把所有可能值都算出来，也可以采用动态规划的思想，找到最合适的方法。<br>面积取决于两个值，左右距离，和两边的较小值，当两边距离不等的时候，将较小值更换可能获得更大的面积，思路就是这样，一直选择较小的往内移动，直到两边相遇。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">  int left = 0, right = height.length - 1;</span><br><span class="line">  int max = 0;</span><br><span class="line">  while (left &lt; right) &#123;</span><br><span class="line">    max = Math.max(max, (right - left) * Math.min(height[left], height[right]));</span><br><span class="line">    if (height[left] &lt; height[right]) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-Container-With-Most-Water（反转字符串中的元音字母）&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water（反转字符串中的元音字母）&quot; class=&quot;headerlink&quot; title=&quot;11. Contai
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 345. Reverse Vowels of a String</title>
    <link href="https://cheng102e.github.io/LeetCode%20345.%20Reverse%20Vowels%20of%20a%20String.html"/>
    <id>https://cheng102e.github.io/LeetCode 345. Reverse Vowels of a String.html</id>
    <published>2020-02-16T05:50:00.000Z</published>
    <updated>2020-02-16T06:00:42.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="345-Reverse-Vowels-of-a-String（反转字符串中的元音字母）"><a href="#345-Reverse-Vowels-of-a-String（反转字符串中的元音字母）" class="headerlink" title="345. Reverse Vowels of a String（反转字符串中的元音字母）"></a>345. Reverse Vowels of a String（反转字符串中的元音字母）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-vowels-of-a-string</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p>示例 1:</p><p>  输入: “hello”<br>  输出: “holle”<br>示例 2:</p><p>  输入: “leetcode”<br>  输出: “leotcede”<br>说明:<br>元音字母不包含字母”y”。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>也是双指针，不过要注意大小写都可以，所以额外增加了一个判断函数判断是否需要反转，别的和344题基本相同。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static boolean find(char c) &#123;</span><br><span class="line">  return !(c == &apos;a&apos; || c == &apos;o&apos; || c == &apos;e&apos; || c == &apos;i&apos; || c == &apos;u&apos; || c == &apos;A&apos; || c == &apos;O&apos;</span><br><span class="line">      || c == &apos;E&apos; || c == &apos;I&apos; || c == &apos;U&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String reverseVowels(String s) &#123;</span><br><span class="line">  char[] arr = s.toCharArray();</span><br><span class="line">  int left = 0, right = arr.length - 1;</span><br><span class="line">  while (left &lt; right) &#123;</span><br><span class="line">    while (left &lt; arr.length &amp;&amp; find(arr[left])) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (right &gt;= 0 &amp;&amp; find(arr[right])) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (left &gt;= right) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    char temp = arr[right];</span><br><span class="line">    arr[right--] = arr[left];</span><br><span class="line">    arr[left++] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  String result = new String(arr);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;345-Reverse-Vowels-of-a-String（反转字符串中的元音字母）&quot;&gt;&lt;a href=&quot;#345-Reverse-Vowels-of-a-String（反转字符串中的元音字母）&quot; class=&quot;headerlink&quot; title=&quot;345. R
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 344. Reverse String</title>
    <link href="https://cheng102e.github.io/LeetCode%20344.%20Reverse%20String.html"/>
    <id>https://cheng102e.github.io/LeetCode 344. Reverse String.html</id>
    <published>2020-02-16T04:50:00.000Z</published>
    <updated>2020-02-16T05:11:03.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="344-Reverse-String（反转字符串）"><a href="#344-Reverse-String（反转字符串）" class="headerlink" title="344. Reverse String（反转字符串）"></a>344. Reverse String（反转字符串）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：</p><p>  输入：[“h”,”e”,”l”,”l”,”o”]<br>  输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p><p>  输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>  输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就硬转呗，双指针，一头一尾直接转换位置，当指针相遇就结束。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void reverseString(char[] s) &#123;</span><br><span class="line">    int left = 0, right = s.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">      char temp = s[left];</span><br><span class="line">      s[left] = s[right];</span><br><span class="line">      s[right] = temp;</span><br><span class="line">      left++;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;344-Reverse-String（反转字符串）&quot;&gt;&lt;a href=&quot;#344-Reverse-String（反转字符串）&quot; class=&quot;headerlink&quot; title=&quot;344. Reverse String（反转字符串）&quot;&gt;&lt;/a&gt;344. Rever
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 215. Kth Largest Element in an Array</title>
    <link href="https://cheng102e.github.io/LeetCode%20215.%20Kth%20Largest%20Element%20in%20an%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 215. Kth Largest Element in an Array.html</id>
    <published>2020-02-16T04:50:00.000Z</published>
    <updated>2020-02-16T05:09:01.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="215-Kth-Largest-Element-in-an-Array（数组中的第K个最大元素）"><a href="#215-Kth-Largest-Element-in-an-Array（数组中的第K个最大元素）" class="headerlink" title="215. Kth Largest Element in an Array（数组中的第K个最大元素）"></a>215. Kth Largest Element in an Array（数组中的第K个最大元素）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>  输入: [3,2,1,5,6,4] 和 k = 2<br>  输出: 5<br>示例 2:</p><p>  输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>  输出: 4<br>说明:</p><p>  你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道数组题目，解法多种。<br>最简单的就是直接排序，然后找到那个数，直接完成，就是效率相对较低。<br>这里用的是优先队列建堆，最小堆，小的数字在堆顶，然后一个一个往里面加数字，每当堆的规模大于k，就去除最小的数字（堆顶），数字处理完之后的堆顶就是所需数字。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">  PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">      new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n1 - n2);</span><br><span class="line">  for (int n : nums) &#123;</span><br><span class="line">    heap.add(n);</span><br><span class="line">    if (heap.size() &gt; k) &#123;</span><br><span class="line">      heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return heap.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;215-Kth-Largest-Element-in-an-Array（数组中的第K个最大元素）&quot;&gt;&lt;a href=&quot;#215-Kth-Largest-Element-in-an-Array（数组中的第K个最大元素）&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 88. Merge Sorted Array</title>
    <link href="https://cheng102e.github.io/LeetCode%2088.%20Merge%20Sorted%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 88. Merge Sorted Array.html</id>
    <published>2020-02-14T14:50:00.000Z</published>
    <updated>2020-02-16T05:08:50.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="88-Merge-Sorted-Array（合并两个有序数组）"><a href="#88-Merge-Sorted-Array（合并两个有序数组）" class="headerlink" title="88. Merge Sorted Array（合并两个有序数组）"></a>88. Merge Sorted Array（合并两个有序数组）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><p>  输入:<br>  nums1 = [1,2,3,0,0,0], m = 3<br>  nums2 = [2,5,6],       n = 3</p><p>  输出: [1,2,2,3,5,6]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道数组题目，解法多种。<br>可以直接合并再排序，也可以两个数组开头慢慢遍历，倒是官方给了一种很cool的题解，直接从数组后方开始。<br>三指针，两个指针指向两个数组最后的数字，一个指针指向数组1的末尾，比较之后将数字放到数组1的末尾，不需要额外空间，最后将数组2未使用的数字（如果存在的话）放到数组1的前面即可。<br>（这题我去年好像做过，还没做出来233333）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">  int index = m + n - 1;</span><br><span class="line">  int m1 = m - 1;</span><br><span class="line">  int n1 = n - 1;</span><br><span class="line">  while (m1 &gt;= 0 &amp;&amp; n1 &gt;= 0) &#123;</span><br><span class="line">    if (nums1[m1] &lt; nums2[n1]) &#123;</span><br><span class="line">      nums1[index] = nums2[n1];</span><br><span class="line">      n1--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      nums1[index] = nums1[m1];</span><br><span class="line">      m1--;</span><br><span class="line">    &#125;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">  while (n1 &gt;= 0) &#123;</span><br><span class="line">    nums1[index] = nums2[n1];</span><br><span class="line">    n1--;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;88-Merge-Sorted-Array（合并两个有序数组）&quot;&gt;&lt;a href=&quot;#88-Merge-Sorted-Array（合并两个有序数组）&quot; class=&quot;headerlink&quot; title=&quot;88. Merge Sorted Array（合并两个有序数
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 75. Sort Colors</title>
    <link href="https://cheng102e.github.io/LeetCode%2075.%20Sort%20Colors.html"/>
    <id>https://cheng102e.github.io/LeetCode 75. Sort Colors.html</id>
    <published>2020-02-14T12:50:00.000Z</published>
    <updated>2020-02-14T12:48:27.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="75-Sort-Colors（颜色分类）"><a href="#75-Sort-Colors（颜色分类）" class="headerlink" title="75. Sort Colors（颜色分类）"></a>75. Sort Colors（颜色分类）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><p>  输入: [2,0,2,1,1,0]<br>  输出: [0,0,1,1,2,2]<br>进阶：</p><p>  一个直观的解决方案是使用计数排序的两趟扫描算法。<br>  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>  你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道数组题目，解法多种。<br>说不让用代码库中的排序函数，那自己写一个应该不算违规吧23333.<br>只有三种数字，012，那么可以遍历统计每个数字的数量，之后直接更改。<br>也可以用三指针法，index012，一共三个变量，index0和1初始值是0，index2初始值是nums.length-1.遍历使用index1，发现那个数字为0，就和index0的数交换，为2就和index2的数交换，这里要注意，index2换过来的数还需要再判断一下。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  public static void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">  int temp = nums[i];</span><br><span class="line">  nums[i] = nums[j];</span><br><span class="line">  nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">  int index0 = 0, index1 = 0, index2 = nums.length - 1;</span><br><span class="line">  while (index1 &lt;= index2) &#123;</span><br><span class="line">    if (nums[index1] == 0) &#123;</span><br><span class="line">      swap(nums, index1, index0);</span><br><span class="line">      index0++;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125; else if (nums[index1] == 2) &#123;</span><br><span class="line">      swap(nums, index1, index2);</span><br><span class="line">      index2--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;75-Sort-Colors（颜色分类）&quot;&gt;&lt;a href=&quot;#75-Sort-Colors（颜色分类）&quot; class=&quot;headerlink&quot; title=&quot;75. Sort Colors（颜色分类）&quot;&gt;&lt;/a&gt;75. Sort Colors（颜色分类）&lt;/h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 581. Shortest Unsorted Continuous Subarray</title>
    <link href="https://cheng102e.github.io/LeetCode%20581.%20Shortest%20Unsorted%20Continuous%20Subarray.html"/>
    <id>https://cheng102e.github.io/LeetCode 581. Shortest Unsorted Continuous Subarray.html</id>
    <published>2020-02-12T03:13:00.000Z</published>
    <updated>2020-02-12T03:20:18.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）"><a href="#581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）" class="headerlink" title="581. Shortest Unsorted Continuous Subarray（最短无序连续子数组）"></a>581. Shortest Unsorted Continuous Subarray（最短无序连续子数组）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:</p><p>  输入: [2, 6, 4, 8, 10, 9, 15]<br>  输出: 5<br>  解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。<br>说明 :</p><p>输入的数组长度范围在 [1, 10,000]。<br>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题方法多种，可以排序之后对比，也可以用别的方法。<br>首先遍历，由前往后由后往前，分别确定两个边界。前向后时寻找右边界，每个数字判断是否小于前方最大值，若小于，就代表这个数需要排序，若大于，就代表这个数可以放在当前位置，若最后全为升序排列那就不用排序，后向前同理。<br>以输入示范，首先max为2，之后往后遍历，6&gt;2,max=6,4&lt;6,需要排序，一直往后，right=5，15大于前方所有数字，无需排序。反向遍历，2小于后方所有数，left=1，5-1+1=5.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int findUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">  int len = nums.length;</span><br><span class="line">  int max = nums[0];</span><br><span class="line">  int min = nums[len - 1];</span><br><span class="line">  int left = 0, right = -1;</span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    if (max &gt; nums[i]) &#123;</span><br><span class="line">      right = i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = len - 1; i &gt; -1; i--) &#123;</span><br><span class="line">    if (min &lt; nums[i]) &#123;</span><br><span class="line">      left = i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      min = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return right - left + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）&quot;&gt;&lt;a href=&quot;#581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 20. Valid Parentheses</title>
    <link href="https://cheng102e.github.io/LeetCode%2020.%20Valid%20Parentheses.html"/>
    <id>https://cheng102e.github.io/LeetCode 20. Valid Parentheses.html</id>
    <published>2020-02-11T14:20:00.000Z</published>
    <updated>2020-02-12T02:26:37.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20-Valid-Parentheses（有效的括号）"><a href="#20-Valid-Parentheses（有效的括号）" class="headerlink" title="20. Valid Parentheses（有效的括号）"></a>20. Valid Parentheses（有效的括号）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>  输入: “()”<br>  输出: true<br>示例 2:</p><p>  输入: “()[]{}”<br>  输出: true<br>示例 3:</p><p>  输入: “(]”<br>  输出: false<br>示例 4:</p><p>  输入: “([)]”<br>  输出: false<br>示例 5:</p><p>  输入: “{[]}”<br>  输出: true</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断括号嘛，我用了最基础的解法，借助栈一个一个找，如果为左括号则入栈，若为右括号且栈顶为对应左括号则出栈，不然直接返回false，一直到遍历结束，如果栈为空就返回true。效率虽然不是很高但是思路很清晰。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">  Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">  for (char c : s.toCharArray()) &#123;</span><br><span class="line">    if (c == &apos;)&apos; &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">      if (stack.peek() == &apos;(&apos;) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (c == &apos;]&apos; &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">      if (stack.peek() == &apos;[&apos;) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (c == &apos;&#125;&apos; &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">      if (stack.peek() == &apos;&#123;&apos;) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      stack.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;20-Valid-Parentheses（有效的括号）&quot;&gt;&lt;a href=&quot;#20-Valid-Parentheses（有效的括号）&quot; class=&quot;headerlink&quot; title=&quot;20. Valid Parentheses（有效的括号）&quot;&gt;&lt;/a&gt;20. 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="栈与队列" scheme="https://cheng102e.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 53. Maximum Subarray</title>
    <link href="https://cheng102e.github.io/LeetCode%2053.%20Maximum%20Subarray.html"/>
    <id>https://cheng102e.github.io/LeetCode 53. Maximum Subarray.html</id>
    <published>2020-02-11T13:50:00.000Z</published>
    <updated>2020-02-12T02:26:36.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="53-Maximum-Subarray（最大子序和）"><a href="#53-Maximum-Subarray（最大子序和）" class="headerlink" title="53. Maximum Subarray（最大子序和）"></a>53. Maximum Subarray（最大子序和）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>  输入: [-2,1,-3,4,-1,2,1,-5,4],<br>  输出: 6<br>  解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p><p>  如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没尝试分治法，那个有点麻烦，等做到别的分治时候再做。<br>这边有动态规划的思想在里面，从头到尾遍历，如果和小于0，那么直接无视，重新开始，和大于0，就加上之前的和。每次都保留当前最大的和，直到输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums) &#123;</span><br><span class="line">    int ans = nums[0];</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">      if (sum &gt;= 0) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        sum = num;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = Math.max(sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;53-Maximum-Subarray（最大子序和）&quot;&gt;&lt;a href=&quot;#53-Maximum-Subarray（最大子序和）&quot; class=&quot;headerlink&quot; title=&quot;53. Maximum Subarray（最大子序和）&quot;&gt;&lt;/a&gt;53. Max
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 448. Find All Numbers Disappeared in an Array</title>
    <link href="https://cheng102e.github.io/LeetCode%20448.%20Find%20All%20Numbers%20Disappeared%20in%20an%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 448. Find All Numbers Disappeared in an Array.html</id>
    <published>2020-02-11T11:50:00.000Z</published>
    <updated>2020-02-11T12:11:42.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="448-Find-All-Numbers-Disappeared-in-an-Array（找到所有数组中消失的数字）"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array（找到所有数组中消失的数字）" class="headerlink" title="448. Find All Numbers Disappeared in an Array（找到所有数组中消失的数字）"></a>448. Find All Numbers Disappeared in an Array（找到所有数组中消失的数字）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:</p><p>  输入:<br>  [4,3,2,7,8,2,3,1]</p><p>  输出:<br>  [5,6]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题的题意很简单，就是要找到缺失的数字，但是思路很巧妙，对于每个数字，都设置一个位置，就像例子一样，第一个数字为4，就将第四个数字设置为-7，一遍循环之后，数组就成为[-4,-3,-2,-7,8,2,-3,-1],然后第二次遍历，如果数字为正，就代表数组中不存在这个数，记录到答案中即可，这里要注意数组从0开始，而数字从1开始。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  public static List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;</span><br><span class="line">  for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">    int temp = Math.abs(nums[i]);</span><br><span class="line">    nums[temp-1]=-Math.abs(nums[temp-1]);</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;Integer&gt;ans = new ArrayList(nums.length);</span><br><span class="line">  for(int i=0;i&lt;nums.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    if(nums[i]&gt;0)&#123;</span><br><span class="line">      ans.add(i+1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;448-Find-All-Numbers-Disappeared-in-an-Array（找到所有数组中消失的数字）&quot;&gt;&lt;a href=&quot;#448-Find-All-Numbers-Disappeared-in-an-Array（找到所有数组中消失的数字）&quot; cl
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 461. Hamming Distance</title>
    <link href="https://cheng102e.github.io/LeetCode%20461.%20Hamming%20Distance.html"/>
    <id>https://cheng102e.github.io/LeetCode 461. Hamming Distance.html</id>
    <published>2020-02-11T11:50:00.000Z</published>
    <updated>2020-02-12T12:20:05.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="461-Hamming-Distance（汉明距离）"><a href="#461-Hamming-Distance（汉明距离）" class="headerlink" title="461. Hamming Distance（汉明距离）"></a>461. Hamming Distance（汉明距离）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/hamming-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hamming-distance</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><p>注意：<br>0 ≤ x, y &lt; 231.</p><p>示例:</p><p>  输入: x = 1, y = 4</p><p>  输出: 2</p><p>  解释:<br>  1   (0 0 0 1)<br>  4   (0 1 0 0)<br>        ↑   ↑</p><p>上面的箭头指出了对应二进制位不同的位置。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题的名词也就是转换一下，需要我们找到二进制位的不同，这时候异或最简单，直接找到不同位，然后可以按位寻找，也可以直接和1进行与运算，然后右移。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  public static int hammingDistance(int x, int y) &#123;</span><br><span class="line">  int xor = x ^ y;</span><br><span class="line">  int num = 0;</span><br><span class="line">  while (xor != 0) &#123;</span><br><span class="line">    if ((xor &amp; 1) == 1) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    xor = xor &gt;&gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;461-Hamming-Distance（汉明距离）&quot;&gt;&lt;a href=&quot;#461-Hamming-Distance（汉明距离）&quot; class=&quot;headerlink&quot; title=&quot;461. Hamming Distance（汉明距离）&quot;&gt;&lt;/a&gt;461. Ha
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="位运算" scheme="https://cheng102e.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="https://cheng102e.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html"/>
    <id>https://cheng102e.github.io/排序算法总结.html</id>
    <published>2020-02-11T11:00:00.000Z</published>
    <updated>2020-02-21T14:29:25.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  所谓排序算法，即通过特定的算法因式将一组或多组数据按照既定模式进行重新排序。这种新序列遵循着一定的规则，体现出一定的规律，因此，经处理后的数据便于筛选和计算，大大提高了计算效率.<br>  这里我就整理一下几种常用的排序算法，复杂度什么放在最后部分。</p><h3 id="目录"><a href="#目录" class="headerlink" title="[目录]"></a>[目录]</h3><ol><li><a href="#1">冒泡排序(BubbleSort)</a></li><li><a href="#2">选择排序(SelctionSort)</a></li><li><a href="#3">插入排序(InsertionSort)</a></li><li><a href="#4">希尔排序(ShellSort)</a></li><li><a href="#5">快速排序(Quicksort)</a></li><li><a href="#6">归并排序(MergeSort)</a></li><li><a href="#7">堆排序(HeapSort)</a></li><li><a href="#8">基数排序(等待更新)</a></li><li><a href="#9">桶排序(等待更新)</a></li><li><a href="#10">计数排序(等待更新)</a></li><li><a href="#11">总结与比较</a></li></ol><h3 id="冒泡排序-BubbleSort"><a href="#冒泡排序-BubbleSort" class="headerlink" title="冒泡排序(BubbleSort)"></a><span id="1">冒泡排序(BubbleSort)</span></h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>两个数比较大小，大的冒泡向后，小的向前，一直到运行结束。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void BubbleSort(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    int len = nums.length;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">        if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">          int temp = nums[i];</span><br><span class="line">          nums[i] = nums[j];</span><br><span class="line">          nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序-SelctionSort"><a href="#选择排序-SelctionSort" class="headerlink" title="选择排序(SelctionSort)"></a><span id="2">选择排序(SelctionSort)</span></h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>选择排序的思路就是找到最小的，放在数组的最前面，之后找第二小的，放在第二位，这里可以采用交换的方法，减少一点运算量。<br>(也可以找最大的放在最后面，思路相同)</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void SelctionSort(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">  int len = nums.length;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    int min = nums[i];</span><br><span class="line">    int index = i;</span><br><span class="line">    for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">      if (nums[j] &lt; min) &#123;</span><br><span class="line">        min = nums[j];</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = nums[i];</span><br><span class="line">    nums[i] = nums[index];</span><br><span class="line">    nums[index] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序-InsertionSort"><a href="#插入排序-InsertionSort" class="headerlink" title="插入排序(InsertionSort)"></a><span id="3">插入排序(InsertionSort)</span></h3><h4 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h4><p>与选择排序相似，对于该数字，找到应该插入的位置，确保数组前方一直保持有序，前方有序后方无序，一个一个插入。<br>(这里我里面循环是从下标1开始的，因为第一个无所谓有序无序)</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void InsertionSort(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    int len = nums.length;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">      int value = nums[i];</span><br><span class="line">      int j = i - 1;</span><br><span class="line">      while (j &gt;= 0 &amp;&amp; nums[j] &gt; value) &#123;</span><br><span class="line">        nums[j + 1] = nums[j];</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      nums[j + 1] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序-ShellSort"><a href="#希尔排序-ShellSort" class="headerlink" title="希尔排序(ShellSort)"></a><span id="4">希尔排序(ShellSort)</span></h3><h4 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h4><p>希尔排序难度一下子就加大了不少，相似与插入排序，但是这是一下子进行多个插入排序，等到基本有序的时候再缩小范围。<br>这里先设置了一个增量，为长度的一半，假设数组长度为8，那么一开始就是第1个和第5个插入排序，2-6，3-7，4-8.第一圈结束。然后长度为2，就是1-3-5-7和2-4-6-8排序，最后全部排序。<br>这块建议上网找图解，文字版的确不适合理解。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void ShellSort(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">   int len = nums.length;</span><br><span class="line">   int len_sort = len;</span><br><span class="line">   while (len_sort &gt; 1) &#123;</span><br><span class="line">     len_sort = len_sort / 2;</span><br><span class="line">     for (int t = 0; t &lt; len_sort; t++) &#123;</span><br><span class="line">       for (int i = t + len_sort; i &lt; len; i = i + len_sort) &#123;</span><br><span class="line">         for (int j = i; j &gt; t; j = j - len_sort) &#123;</span><br><span class="line">           if (nums[j] &lt; nums[j - len_sort]) &#123;</span><br><span class="line">             int temp = nums[j];</span><br><span class="line">             nums[j] = nums[j - len_sort];</span><br><span class="line">             nums[j - len_sort] = temp;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">             break;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序-Quicksort"><a href="#快速排序-Quicksort" class="headerlink" title="快速排序(Quicksort)"></a><span id="5">快速排序(Quicksort)</span></h3><h4 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h4><p>算是利用分治法，先选出一个key值，然后把小于key的放在左边，大于key的放在右边，然后左右两边都进行这种操作，一直到不能再次分割。<br>这个算是比较重要且常用的排序方法，记住要递归调用，代码虽然复杂但是思路还是比较清晰的。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void Quicksort(int[] nums, int l, int r) &#123;</span><br><span class="line">  if (l &gt;= r) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  int i = l, j = r;</span><br><span class="line">  int key = nums[l];</span><br><span class="line">  while (i &lt; j) &#123;</span><br><span class="line">    while (i &lt; j &amp;&amp; nums[j] &gt;= key) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; j) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; j) &#123;</span><br><span class="line">      nums[j] = nums[i];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nums[i] = key;</span><br><span class="line">  Quicksort(nums, l, i - 1);</span><br><span class="line">  Quicksort(nums, i + 1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序-MergeSort"><a href="#归并排序-MergeSort" class="headerlink" title="归并排序(MergeSort)"></a><span id="6">归并排序(MergeSort)</span></h3><h4 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a>思想</h4><p>递归分治的思想，将数组分为待排序的子数组，等到子数组排序好了就合并，子数组分到最小的时候进行排序，两两合并，最后有序。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static void Merge(int[] nums, int start, int mid, int end) &#123;</span><br><span class="line">   int i = start;</span><br><span class="line">   int j = mid + 1;</span><br><span class="line">   int k = 0;</span><br><span class="line">   int[] temp = new int[end - start + 1];</span><br><span class="line">   while (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">     if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">       temp[k] = nums[i];</span><br><span class="line">       i++;</span><br><span class="line">       k++;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       temp[k] = nums[j];</span><br><span class="line">       j++;</span><br><span class="line">       k++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   while (i &lt;= mid) &#123;</span><br><span class="line">     temp[k] = nums[i];</span><br><span class="line">     k++;</span><br><span class="line">     i++;</span><br><span class="line">   &#125;</span><br><span class="line">   while (j &lt;= end) &#123;</span><br><span class="line">     temp[k] = nums[j];</span><br><span class="line">     k++;</span><br><span class="line">     j++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (int t = 0; t &lt; temp.length; t++) &#123;</span><br><span class="line">     nums[start + t] = temp[t];</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void MergeSort(int[] nums, int start, int end) &#123;</span><br><span class="line">   if (start &gt;= end) &#123;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int mid = start + (end - start) / 2;</span><br><span class="line">   MergeSort(nums, start, mid);</span><br><span class="line">   MergeSort(nums, mid + 1, end);</span><br><span class="line">   Merge(nums, start, mid, end);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序(HeapSort)"></a><span id="7">堆排序(HeapSort)</span></h3><h4 id="思想-6"><a href="#思想-6" class="headerlink" title="思想"></a>思想</h4><p>堆排序借助了堆的性质，假设使用最大堆，那么堆顶就是最大值，取下最大值进行堆的调整，就能得到次大值，直到堆为空，就可以得到排序的结果。<br>可以直接借助数据结构建立一个堆，也可以自己写一个模拟堆的运行。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static void HeapSort(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">  int len = nums.length;</span><br><span class="line"></span><br><span class="line">  for (int i = len / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    adjustHeap(nums, i, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (int j = len - 1; j &gt; 0; j--) &#123;</span><br><span class="line">    int temp = nums[j];</span><br><span class="line">    nums[j] = nums[0];</span><br><span class="line">    nums[0] = temp;</span><br><span class="line">    adjustHeap(nums, 0, j);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void adjustHeap(int[] nums, int i, int length) &#123;</span><br><span class="line">  int temp = nums[i];</span><br><span class="line">  for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123;</span><br><span class="line">    if (k + 1 &lt; length &amp;&amp; nums[k] &lt; nums[k + 1]) &#123;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[k] &gt; temp) &#123;</span><br><span class="line">      nums[i] = nums[k];</span><br><span class="line">      i = k;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nums[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序-等待更新"><a href="#基数排序-等待更新" class="headerlink" title="基数排序(等待更新)"></a><span id="8">基数排序(等待更新)</span></h3><h4 id="思想-7"><a href="#思想-7" class="headerlink" title="思想"></a>思想</h4><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><h3 id="桶排序-等待更新"><a href="#桶排序-等待更新" class="headerlink" title="桶排序(等待更新)"></a><span id="9">桶排序(等待更新)</span></h3><h4 id="思想-8"><a href="#思想-8" class="headerlink" title="思想"></a>思想</h4><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><h3 id="计数排序-等待更新"><a href="#计数排序-等待更新" class="headerlink" title="计数排序(等待更新)"></a><span id="10">计数排序(等待更新)</span></h3><h4 id="思想-9"><a href="#思想-9" class="headerlink" title="思想"></a>思想</h4><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><h3 id="总结与比较"><a href="#总结与比较" class="headerlink" title="总结与比较"></a><span id="11">总结与比较</span></h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有很多种排序方法，我这里只写了一些基础的，还有桶排序，基数排序计数排序什么的我没有写上去，以后有机会在写吧。<br>算法没有绝对的好坏之分，我们要做的是选择当前状况下的最合适的算法。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table><thead><tr><th>排序方法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th><th>比较类排序</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n2)</td><td>O(1)</td><td>稳定</td><td>是</td></tr><tr><td>选择排序</td><td>O(n2)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>插入排序</td><td>O(n2)</td><td>O(1)</td><td>稳定</td><td>是</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n)</td><td>不稳定</td><td>是</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(logn)</td><td>稳定</td><td>是</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n+k)</td><td>稳定</td><td>否</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td><td>否</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td><td>否</td></tr></tbody></table><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>这里还做了一个主函数用于排序的，随机生成数组并排序，大家可以试试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  int[] array = new int[20];</span><br><span class="line">  for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    array[i] = (int) (Math.random() * 1000);</span><br><span class="line">  &#125;</span><br><span class="line">  sort(array);</span><br><span class="line">  for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序算法总结&quot;&gt;&lt;a href=&quot;#排序算法总结&quot; class=&quot;headerlink&quot; title=&quot;排序算法总结&quot;&gt;&lt;/a&gt;排序算法总结&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="https://cheng102e.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 976. Largest Perimeter Triangle</title>
    <link href="https://cheng102e.github.io/LeetCode%20976.%20Largest%20Perimeter%20Triangle.html"/>
    <id>https://cheng102e.github.io/LeetCode 976. Largest Perimeter Triangle.html</id>
    <published>2020-02-05T03:11:00.000Z</published>
    <updated>2020-02-05T03:17:12.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="976-Largest-Perimeter-Triangle（三角形的最大周长）"><a href="#976-Largest-Perimeter-Triangle（三角形的最大周长）" class="headerlink" title="976. Largest Perimeter Triangle（三角形的最大周长）"></a>976. Largest Perimeter Triangle（三角形的最大周长）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-perimeter-triangle</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。</p><p>如果不能形成任何面积不为零的三角形，返回 0。</p><p>示例 1：</p><p>  输入：[2,1,2]<br>  输出：5<br>示例 2：</p><p>  输入：[1,2,1]<br>  输出：0<br>示例 3：</p><p>  输入：[3,2,3,4]<br>  输出：10<br>示例 4：</p><p>  输入：[3,6,2,3]<br>  输出：8</p><p>提示：</p><p>  3 &lt;= A.length &lt;= 10000<br>  1 &lt;= A[i] &lt;= 10^6</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题偷了个懒，直接用了自带的sort函数，之后就是一共从后向前的循环，每三个为一组，若该组可以构成三角形，返回长度，不然跳出。<br>这里还有一个数学问题，为什么是连续的三个而不是中断的三个，这里假设有四个数字abcd，升序排列，先判断bcd，在判断abc，因为如果b+c&lt;d，无法构成,那么a+c&lt;b+c更无法构成了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int largestPerimeter(int[] A) &#123;</span><br><span class="line">  Arrays.sort(A);</span><br><span class="line">  for (int i = A.length - 1; i &gt; 1; i--) &#123;</span><br><span class="line">    if (A[i] &lt; A[i - 1] + A[i - 2]) &#123;</span><br><span class="line">      return A[i] + A[i - 1] + A[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;976-Largest-Perimeter-Triangle（三角形的最大周长）&quot;&gt;&lt;a href=&quot;#976-Largest-Perimeter-Triangle（三角形的最大周长）&quot; class=&quot;headerlink&quot; title=&quot;976. Largest
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1295. Find Numbers with Even Number of Digits</title>
    <link href="https://cheng102e.github.io/LeetCode%201295.%20Find%20Numbers%20with%20Even%20Number%20of%20Digits.html"/>
    <id>https://cheng102e.github.io/LeetCode 1295. Find Numbers with Even Number of Digits.html</id>
    <published>2020-02-04T03:29:00.000Z</published>
    <updated>2020-02-04T03:31:22.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1295-Find-Numbers-with-Even-Number-of-Digits（统计位数为偶数的数字）"><a href="#1295-Find-Numbers-with-Even-Number-of-Digits（统计位数为偶数的数字）" class="headerlink" title="1295. Find Numbers with Even Number of Digits（统计位数为偶数的数字）"></a>1295. Find Numbers with Even Number of Digits（统计位数为偶数的数字）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。</p><p>示例 1：</p><p>  输入：nums = [12,345,2,6,7896]<br>  输出：2<br>  解释：<br>  12 是 2 位数字（位数为偶数）<br>  345 是 3 位数字（位数为奇数）<br>  2 是 1 位数字（位数为奇数）<br>  6 是 1 位数字 位数为奇数）<br>  7896 是 4 位数字（位数为偶数）<br>  因此只有 12 和 7896 是位数为偶数的数字<br>示例 2：</p><p>  输入：nums = [555,901,482,1771]<br>  输出：1<br>  解释：<br>  只有 1771 是位数为偶数的数字。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>emmm我也不知道算是什么题目，从头到尾判断一下就行了，对于数字的范围判断一下，其实也可以转字符串判断长度，不过没必要。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int findNumbers(int[] nums) &#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  for (int num : nums) &#123;</span><br><span class="line">    if ((10 &lt;= num &amp;&amp; num &lt;= 99) || (1000 &lt;= num &amp;&amp; num &lt;= 9999) || num == 100000) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1295-Find-Numbers-with-Even-Number-of-Digits（统计位数为偶数的数字）&quot;&gt;&lt;a href=&quot;#1295-Find-Numbers-with-Even-Number-of-Digits（统计位数为偶数的数字）&quot; class=
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 374. Guess Number Higher or Lower</title>
    <link href="https://cheng102e.github.io/LeetCode%20374.%20Guess%20Number%20Higher%20or%20Lower.html"/>
    <id>https://cheng102e.github.io/LeetCode 374. Guess Number Higher or Lower.html</id>
    <published>2020-02-03T12:19:00.000Z</published>
    <updated>2020-02-03T12:19:33.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="374-Guess-Number-Higher-or-Lower（猜数字大小）"><a href="#374-Guess-Number-Higher-or-Lower（猜数字大小）" class="headerlink" title="374. Guess Number Higher or Lower（猜数字大小）"></a>374. Guess Number Higher or Lower（猜数字大小）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower" target="_blank" rel="noopener">https://leetcode-cn.com/problems/guess-number-higher-or-lower</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：</p><p>-1 : 我的数字比较小<br> 1 : 我的数字比较大<br> 0 : 恭喜！你猜对了！<br>示例 :</p><p>  输入: n = 10, pick = 6<br>  输出: 6</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个也是二分查找，只不过又换了一种问法。<br>这里只需要注意到leftright的更新与guess函数的返回值即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int guessNumber(int n) &#123;</span><br><span class="line">  int left = 1;</span><br><span class="line">  int right = n;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (guess(mid) == 0) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (guess(mid) == 1) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (guess(mid) == -1) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;374-Guess-Number-Higher-or-Lower（猜数字大小）&quot;&gt;&lt;a href=&quot;#374-Guess-Number-Higher-or-Lower（猜数字大小）&quot; class=&quot;headerlink&quot; title=&quot;374. Guess Num
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 278. First Bad Version</title>
    <link href="https://cheng102e.github.io/LeetCode%20278.%20First%20Bad%20Version.html"/>
    <id>https://cheng102e.github.io/LeetCode 278. First Bad Version.html</id>
    <published>2020-02-03T12:09:00.000Z</published>
    <updated>2020-02-03T12:21:46.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="278-First-Bad-Version（第一个错误的版本）"><a href="#278-First-Bad-Version（第一个错误的版本）" class="headerlink" title="278. First Bad Version（第一个错误的版本）"></a>278. First Bad Version（第一个错误的版本）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/first-bad-version" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p>示例:</p><p>  给定 n = 5，并且 version = 4 是第一个错误的版本。</p><p>  调用 isBadVersion(3) -&gt; false<br>  调用 isBadVersion(5) -&gt; true<br>  调用 isBadVersion(4) -&gt; true</p><p>  所以，4 是第一个错误的版本。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个也是二分查找，问题相对来说不是很大，只需要注意几个细节即可，返回值为true表示版本错误，同时注意left和right的顺序，并且mid取值的时候要注意到不能溢出，最后返回left即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  public static int firstBadVersion(int n) &#123;</span><br><span class="line">  int left = 1;</span><br><span class="line">  int right = n;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (isBadVersion(mid) == true) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (isBadVersion(mid) == false) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;278-First-Bad-Version（第一个错误的版本）&quot;&gt;&lt;a href=&quot;#278-First-Bad-Version（第一个错误的版本）&quot; class=&quot;headerlink&quot; title=&quot;278. First Bad Version（第一个错误的版
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 35. Search Insert Position</title>
    <link href="https://cheng102e.github.io/LeetCode%2035.%20Search%20Insert%20Position.html"/>
    <id>https://cheng102e.github.io/LeetCode 35. Search Insert Position.html</id>
    <published>2020-02-03T05:09:00.000Z</published>
    <updated>2020-02-03T05:45:28.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="35-Search-Insert-Position（二分查找）"><a href="#35-Search-Insert-Position（二分查找）" class="headerlink" title="35. Search Insert Position（二分查找）"></a>35. Search Insert Position（二分查找）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><p>  输入: [1,3,5,6], 5<br>  输出: 2<br>示例 2:</p><p>  输入: [1,3,5,6], 2<br>  输出: 1<br>示例 3:</p><p>  输入: [1,3,5,6], 7<br>  输出: 4<br>示例 4:</p><p>  输入: [1,3,5,6], 0<br>  输出: 0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找加了一些别的东西，升序数组，找到返回下标，未找到就返回可以加入的位置.<br>代码和正常的二分查找相同，需要注意的是，最后一个返回的应该是left，因为在最后一次循环中，left=right，然后left++，这个位置，就是应该存放的位置。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  public static int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;35-Search-Insert-Position（二分查找）&quot;&gt;&lt;a href=&quot;#35-Search-Insert-Position（二分查找）&quot; class=&quot;headerlink&quot; title=&quot;35. Search Insert Position（二分查
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>查找算法-二分查找</title>
    <link href="https://cheng102e.github.io/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <id>https://cheng102e.github.io/查找算法-二分查找.html</id>
    <published>2020-02-03T05:00:00.000Z</published>
    <updated>2020-02-12T12:00:03.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找算法-二分查找"><a href="#查找算法-二分查找" class="headerlink" title="查找算法-二分查找"></a>查找算法-二分查找</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置两个标签，一个为left一个为right，分别表示左侧与右侧，常见初始值为0，length-1.<br>之后进行while循环，这里注意，判断条件选择left&lt;=right，这里当然可以改变，但是最好是熟练之后再进行改变。<br>循环中定义mid = (left + right) / 2，其实更好的是left+（right-left）/2；这样避免越界。<br>若找到了所需要的值，直接返回，找不到的话，就先判断nums[mid]与目标值的大小关系，重新确立leftright，进行下一步运算。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>O(log2n)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查找算法-二分查找&quot;&gt;&lt;a href=&quot;#查找算法-二分查找&quot; class=&quot;headerlink&quot; title=&quot;查找算法-二分查找&quot;&gt;&lt;/a&gt;查找算法-二分查找&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="算法" scheme="https://cheng102e.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://cheng102e.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
