<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-03-06T09:47:13.934Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer 67.剪绳子</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2067.%E5%89%AA%E7%BB%B3%E5%AD%90.html"/>
    <id>https://cheng102e.github.io/剑指offer 67.剪绳子.html</id>
    <published>2020-03-06T09:40:00.000Z</published>
    <updated>2020-03-06T09:47:13.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-67-剪绳子"><a href="#剑指offer-67-剪绳子" class="headerlink" title="剑指offer 67.剪绳子"></a>剑指offer 67.剪绳子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目描述<br>  给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>输入描述:<br>  输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）<br>输出描述:<br>  输出答案。<br>示例1<br>  输入<br>  8<br>  输出<br>  18</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>。。。动态规划，对于绳子有切或者不切两种选择，如果切可以让结果更大，那就切，如果不行就不切，一米一米的延长，直到最后长度为target，输出。<br>外层循环是绳子总长度的增加，内层循环可以做个例子，6米的可以切成1+5，2+4，3+3(4+2和2+4一样)，dp存放多少米的绳子的最大乘积，那么这三种情况就是dp[1]*dp[5],dp[2]*dp[4],dp[3]*dp[3],其中最大值就是6米绳子的最大乘积，存储下来，以后继续用。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int cutRope(int target) &#123;</span><br><span class="line">  if (target == 2) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (target == 3) &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] dp = new int[target + 1];</span><br><span class="line">  dp[1] = 1;</span><br><span class="line">  dp[2] = 2;</span><br><span class="line">  dp[3] = 3;</span><br><span class="line">  int max = 0;</span><br><span class="line">  for (int i = 4; i &lt;= target; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;=i/2 ; j++) &#123;</span><br><span class="line">      max=Math.max(max,dp[j]*dp[i-j]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i]=max;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-67-剪绳子&quot;&gt;&lt;a href=&quot;#剑指offer-67-剪绳子&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 67.剪绳子&quot;&gt;&lt;/a&gt;剑指offer 67.剪绳子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 66.机器人的运动范围</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2066.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.html"/>
    <id>https://cheng102e.github.io/剑指offer 66.机器人的运动范围.html</id>
    <published>2020-03-06T09:30:00.000Z</published>
    <updated>2020-03-06T09:40:34.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-66-机器人的运动范围"><a href="#剑指offer-66-机器人的运动范围" class="headerlink" title="剑指offer 66.机器人的运动范围"></a>剑指offer 66.机器人的运动范围</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种题目可以设置标记位，上下左右四个方向可以设置为4个式子，返回值相加。<br>先假设全局为0，表示未走过，然后向四个方向走，若走过了，返回数字加一，继续走，若没走或者不能走，就去除这一条路(返回0)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int movingCount(int threshold, int rows, int cols) &#123;</span><br><span class="line">  int flag[][] = new int[rows][cols];</span><br><span class="line">  return find(0, 0, rows, cols, flag, threshold);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int find(int i, int j, int rows, int cols, int[][] flag, int threshold) &#123;</span><br><span class="line">  if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || sum(i) + sum(j) &gt; threshold</span><br><span class="line">      || flag[i][j] == 1) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  flag[i][j] = 1;</span><br><span class="line">  return find(i - 1, j, rows, cols, flag, threshold)</span><br><span class="line">      + find(i + 1, j, rows, cols, flag, threshold)</span><br><span class="line">      + find(i, j - 1, rows, cols, flag, threshold)</span><br><span class="line">      + find(i, j + 1, rows, cols, flag, threshold)</span><br><span class="line">      + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sum(int i) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  while (i &gt; 0) &#123;</span><br><span class="line">    sum += i % 10;</span><br><span class="line">    i /= 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-66-机器人的运动范围&quot;&gt;&lt;a href=&quot;#剑指offer-66-机器人的运动范围&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 66.机器人的运动范围&quot;&gt;&lt;/a&gt;剑指offer 66.机器人的运动范围&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 65.矩阵中的路径</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2065.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.html"/>
    <id>https://cheng102e.github.io/剑指offer 65.矩阵中的路径.html</id>
    <published>2020-03-06T09:20:00.000Z</published>
    <updated>2020-03-06T09:29:07.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-65-矩阵中的路径"><a href="#剑指offer-65-矩阵中的路径" class="headerlink" title="剑指offer 65.矩阵中的路径"></a>剑指offer 65.矩阵中的路径</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。(这里应该有个图但是没有)<br>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法的思路，首先先找到第一个可以的点，然后从这点开始尝试，上下左右四种情况，如果走过了的话，那么就让标志位为true，避免再次走到这一步，如果没有机会，那么回退一步，重新开始，这里要注意标志位的还原。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123;</span><br><span class="line">  boolean[] flag = new boolean[matrix.length];</span><br><span class="line">  for (int i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; cols; j++) &#123;</span><br><span class="line">      if (judge(matrix, i, j, rows, cols, flag, str, 0)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean judge(char[] matrix, int i, int j, int rows, int cols, boolean[] flag, char[] str,</span><br><span class="line">    int k) &#123;</span><br><span class="line">  int index = i * cols + j;</span><br><span class="line">  if (i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= cols || matrix[index] != str[k]</span><br><span class="line">      || flag[index] == true) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (k == str.length - 1) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  flag[index] = true;</span><br><span class="line"></span><br><span class="line">  if (judge(matrix, i - 1, j, rows, cols, flag, str, k + 1) ||</span><br><span class="line">      judge(matrix, i + 1, j, rows, cols, flag, str, k + 1) ||</span><br><span class="line">      judge(matrix, i, j - 1, rows, cols, flag, str, k + 1) ||</span><br><span class="line">      judge(matrix, i, j + 1, rows, cols, flag, str, k + 1)) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  flag[index] = false;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-65-矩阵中的路径&quot;&gt;&lt;a href=&quot;#剑指offer-65-矩阵中的路径&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 65.矩阵中的路径&quot;&gt;&lt;/a&gt;剑指offer 65.矩阵中的路径&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 64.滑动窗口的最大值</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2064.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html"/>
    <id>https://cheng102e.github.io/剑指offer 64.滑动窗口的最大值.html</id>
    <published>2020-03-06T09:00:00.000Z</published>
    <updated>2020-03-06T09:16:24.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-64-滑动窗口的最大值"><a href="#剑指offer-64-滑动窗口的最大值" class="headerlink" title="剑指offer 64.滑动窗口的最大值"></a>剑指offer 64.滑动窗口的最大值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果不考虑复杂度的话，直接加一个内循环重新搜索即可。<br>这里采用双端队列，可以在前后删除，插入的时候从后方比较，如果一个数比新的数小，那么直接删除，如果比新的数大，若超出范围就删除，未超出就无视。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123;</span><br><span class="line"></span><br><span class="line">   ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">   if (num == null) &#123;</span><br><span class="line">     return ans;</span><br><span class="line">   &#125;</span><br><span class="line">   if (num.length &lt; size || size &lt; 1) &#123;</span><br><span class="line">     return ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">   for (int i = 0; i &lt; size - 1; i++) &#123;</span><br><span class="line">     while (!list.isEmpty() &amp;&amp; num[i] &gt; num[list.getLast()]) &#123;</span><br><span class="line">       list.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line">     list.addLast(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (int i = size - 1; i &lt; num.length; i++) &#123;</span><br><span class="line">     while (!list.isEmpty() &amp;&amp; num[i] &gt; num[list.getLast()]) &#123;</span><br><span class="line">       list.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line">     list.addLast(i);</span><br><span class="line">     if (i - list.getFirst() + 1 &gt; size) &#123;</span><br><span class="line">       list.removeFirst();</span><br><span class="line">     &#125;</span><br><span class="line">     ans.add(num[list.getFirst()]);</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-64-滑动窗口的最大值&quot;&gt;&lt;a href=&quot;#剑指offer-64-滑动窗口的最大值&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 64.滑动窗口的最大值&quot;&gt;&lt;/a&gt;剑指offer 64.滑动窗口的最大值&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 63.数据流中的中位数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2063.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 63.数据流中的中位数.html</id>
    <published>2020-03-06T06:40:00.000Z</published>
    <updated>2020-03-06T06:55:06.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-63-数据流中的中位数"><a href="#剑指offer-63-数据流中的中位数" class="headerlink" title="剑指offer 63.数据流中的中位数"></a>剑指offer 63.数据流中的中位数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我一开始的想法，是排序之后直接找，但是复杂度有点高。<br>发现了一种新的方法，维持两个堆，一个最大堆，一个最小堆，确保最大堆的数都小于最小堆，两个堆的大小差距为1或0.<br>如果两边数量相同的话，取最大堆的最大值和最小堆的最小值和的一半即可，如果不同，那么就是多的那个。<br>java可以用优先队列，改一下比较器就可以了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int count = 0;</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void Insert(Integer num) &#123;</span><br><span class="line">  if (count % 2 == 0) &#123;</span><br><span class="line">    maxHeap.offer(num);</span><br><span class="line">    int filteredMaxNum = maxHeap.poll();</span><br><span class="line">    minHeap.offer(filteredMaxNum);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    minHeap.offer(num);</span><br><span class="line">    int filteredMinNum = minHeap.poll();</span><br><span class="line">    maxHeap.offer(filteredMinNum);</span><br><span class="line">  &#125;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Double GetMedian() &#123;</span><br><span class="line">  if (count % 2 == 0) &#123;</span><br><span class="line">    return new Double((minHeap.peek() + maxHeap.peek())) / 2;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return new Double(minHeap.peek());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-63-数据流中的中位数&quot;&gt;&lt;a href=&quot;#剑指offer-63-数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 63.数据流中的中位数&quot;&gt;&lt;/a&gt;剑指offer 63.数据流中的中位数&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 62.二叉搜索树的第k个结点</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2062.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 62.二叉搜索树的第k个结点.html</id>
    <published>2020-03-06T06:20:00.000Z</published>
    <updated>2020-03-06T06:38:52.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-62-二叉搜索树的第k个结点"><a href="#剑指offer-62-二叉搜索树的第k个结点" class="headerlink" title="剑指offer 62.二叉搜索树的第k个结点"></a>剑指offer 62.二叉搜索树的第k个结点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树的中序遍历是递增的，找到第k小的话，那就只需要中序遍历即可，遍历的第k个数就是所需的数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode KthNode(TreeNode pRoot, int k) &#123;</span><br><span class="line">  if(pRoot == null || k == 0) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  int count = 0;</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">  while (pRoot != null || ! stack.isEmpty()) &#123;</span><br><span class="line">    while (pRoot != null) &#123;</span><br><span class="line">      stack.push(pRoot);</span><br><span class="line">      pRoot = pRoot.left;</span><br><span class="line">    &#125;</span><br><span class="line">    pRoot = stack.pop();</span><br><span class="line">    count ++;</span><br><span class="line">    if(count == k) &#123;</span><br><span class="line">      return pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    pRoot = pRoot.right;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-62-二叉搜索树的第k个结点&quot;&gt;&lt;a href=&quot;#剑指offer-62-二叉搜索树的第k个结点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 62.二叉搜索树的第k个结点&quot;&gt;&lt;/a&gt;剑指offer 62.二叉搜索树的第k个
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 61.序列化二叉树</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2061.%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://cheng102e.github.io/剑指offer 61.序列化二叉树.html</id>
    <published>2020-03-06T06:00:00.000Z</published>
    <updated>2020-03-06T06:25:54.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-61-序列化二叉树"><a href="#剑指offer-61-序列化二叉树" class="headerlink" title="剑指offer 61.序列化二叉树"></a>剑指offer 61.序列化二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题其实可以面向答案编程，直接设一个root返回就行了，牛客不检查那个字符串。<br>正规做法还是递归，中左右前序，直接就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int index;</span><br><span class="line">String Serialize(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">  StringBuffer sb = new StringBuffer();</span><br><span class="line">  if(root == null)&#123;</span><br><span class="line">    sb.append(&quot;#,&quot;);</span><br><span class="line">    return sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  sb.append(root.val+&quot;,&quot;);</span><br><span class="line">  sb.append(Serialize(root.left));</span><br><span class="line">  sb.append(Serialize(root.right));</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">TreeNode Deserialize(String str) &#123;</span><br><span class="line">  </span><br><span class="line">  if(str == null)&#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  index = -1;</span><br><span class="line">  String[] strSeg = str.split(&quot;,&quot;);</span><br><span class="line"></span><br><span class="line">  return DeserializeStr(strSeg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode DeserializeStr(String[] strSeg)&#123;</span><br><span class="line">  index++;</span><br><span class="line">  TreeNode treeNode = null;</span><br><span class="line">  if(!strSeg[index].equals(&quot;#&quot;))&#123;</span><br><span class="line">    treeNode = new TreeNode(Integer.valueOf(strSeg[index]));</span><br><span class="line">    treeNode.left = DeserializeStr(strSeg);</span><br><span class="line">    treeNode.right = DeserializeStr(strSeg);</span><br><span class="line">  &#125;</span><br><span class="line">  return treeNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-61-序列化二叉树&quot;&gt;&lt;a href=&quot;#剑指offer-61-序列化二叉树&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 61.序列化二叉树&quot;&gt;&lt;/a&gt;剑指offer 61.序列化二叉树&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 60.把二叉树打印成多行</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2060.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.html"/>
    <id>https://cheng102e.github.io/剑指offer 60.把二叉树打印成多行.html</id>
    <published>2020-03-06T05:40:00.000Z</published>
    <updated>2020-03-06T05:47:30.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-60-把二叉树打印成多行"><a href="#剑指offer-60-把二叉树打印成多行" class="headerlink" title="剑指offer 60.把二叉树打印成多行"></a>剑指offer 60.把二叉树打印成多行</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和上一题类似，不过无需用两个栈了，只需要以队列来存储即可，就是简单的层次遍历，记得设置一个标记来记录每一行的长度，因为是按行输出的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line"></span><br><span class="line">  ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">  if (pRoot == null) &#123;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">  queue.add(pRoot);</span><br><span class="line">  int start = 0, end = 1;</span><br><span class="line">  while (!queue.isEmpty()) &#123;</span><br><span class="line">    TreeNode cur = queue.remove();</span><br><span class="line">    list.add(cur.val);</span><br><span class="line">    start++;</span><br><span class="line">    if (cur.left != null) &#123;</span><br><span class="line">      queue.add(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cur.right != null) &#123;</span><br><span class="line">      queue.add(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    if (start == end) &#123;</span><br><span class="line">      end = queue.size();</span><br><span class="line">      start = 0;</span><br><span class="line">      ans.add(list);</span><br><span class="line">      list = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-60-把二叉树打印成多行&quot;&gt;&lt;a href=&quot;#剑指offer-60-把二叉树打印成多行&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 60.把二叉树打印成多行&quot;&gt;&lt;/a&gt;剑指offer 60.把二叉树打印成多行&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 59.按之字形顺序打印二叉树</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2059.%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://cheng102e.github.io/剑指offer 59.按之字形顺序打印二叉树.html</id>
    <published>2020-03-06T04:40:00.000Z</published>
    <updated>2020-03-06T05:31:17.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-59-按之字形顺序打印二叉树"><a href="#剑指offer-59-按之字形顺序打印二叉树" class="headerlink" title="剑指offer 59.按之字形顺序打印二叉树"></a>剑指offer 59.按之字形顺序打印二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用栈来存储了，一正一负，也不是很麻烦，只是入栈的时候顺序不同，左子树右子树是奇数，右子树左子树是偶数，这里设置一个标记来记录当前是奇数还是偶数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">  ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">  if (pRoot == null) &#123;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br><span class="line">  Stack&lt;TreeNode&gt; odd = new Stack&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; even = new Stack&lt;&gt;();</span><br><span class="line">  odd.push(pRoot);</span><br><span class="line">  boolean isodd = true;</span><br><span class="line">  while (!(odd.empty() &amp;&amp; even.empty())) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    if (isodd) &#123;</span><br><span class="line">      while (!odd.empty()) &#123;</span><br><span class="line">        TreeNode temp = odd.pop();</span><br><span class="line">        list.add(temp.val);</span><br><span class="line">        if (temp.left != null) &#123;</span><br><span class="line">          even.push(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp.right != null) &#123;</span><br><span class="line">          even.push(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ans.add(list);</span><br><span class="line">      isodd = false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      while (!even.empty()) &#123;</span><br><span class="line">        TreeNode temp = even.pop();</span><br><span class="line">        list.add(temp.val);</span><br><span class="line">        if (temp.right != null) &#123;</span><br><span class="line">          odd.push(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp.left != null) &#123;</span><br><span class="line">          odd.push(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ans.add(list);</span><br><span class="line">      isodd = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-59-按之字形顺序打印二叉树&quot;&gt;&lt;a href=&quot;#剑指offer-59-按之字形顺序打印二叉树&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 59.按之字形顺序打印二叉树&quot;&gt;&lt;/a&gt;剑指offer 59.按之字形顺序打印二
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 58.对称的二叉树</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2058.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://cheng102e.github.io/剑指offer 58.对称的二叉树.html</id>
    <published>2020-03-06T03:50:00.000Z</published>
    <updated>2020-03-06T04:37:25.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-58-对称的二叉树"><a href="#剑指offer-58-对称的二叉树" class="headerlink" title="剑指offer 58.对称的二叉树"></a>剑指offer 58.对称的二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种情况，显然递归了，对于每个节点都递归下去，检查该点的左子树和右子树是否对照，设子节点为p1p2，然后就是p1左子树p2右子树判断，p1右子树p2左子树判断，以此类推。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean test(TreeNode p1, TreeNode p2) &#123;</span><br><span class="line">  if (p1 == null &amp;&amp; p2 == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (p1 != null &amp;&amp; p2 != null) &#123;</span><br><span class="line">    return p1.val == p2.val &amp;&amp; test(p1.left, p2.right) &amp;&amp; test(p1.right, p2.left);</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean isSymmetrical(TreeNode pRoot) &#123;</span><br><span class="line">  if (pRoot == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return test(pRoot.left, pRoot.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-58-对称的二叉树&quot;&gt;&lt;a href=&quot;#剑指offer-58-对称的二叉树&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 58.对称的二叉树&quot;&gt;&lt;/a&gt;剑指offer 58.对称的二叉树&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 57.二叉树的下一个结点</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2057.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 57.二叉树的下一个结点.html</id>
    <published>2020-03-06T03:40:00.000Z</published>
    <updated>2020-03-06T04:37:24.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-57-二叉树的下一个结点"><a href="#剑指offer-57-二叉树的下一个结点" class="headerlink" title="剑指offer 57.二叉树的下一个结点"></a>剑指offer 57.二叉树的下一个结点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里的next命名有点憨，指向父节点的命名为next。</p><ol><li>中序是左中右，如果结点存在右子树，那么就找到右子树的最左节点，</li><li>如果不存在右子树<ol><li>若该点为父节点的左子节点，那么下一个就是父节点。</li><li>若该点为父节点的右子节点，那么递归向上，直到找到结点为父节点的左子节点为止。</li></ol></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class TreeLinkNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeLinkNode left = null;</span><br><span class="line">  TreeLinkNode right = null;</span><br><span class="line">  TreeLinkNode next = null;</span><br><span class="line"></span><br><span class="line">  TreeLinkNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeLinkNode GetNext(TreeLinkNode pNode) &#123;</span><br><span class="line">  if (pNode == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  if (pNode.right != null) &#123;</span><br><span class="line">    pNode = pNode.right;</span><br><span class="line">    while (pNode.left != null) &#123;</span><br><span class="line">      pNode = pNode.left;</span><br><span class="line">    &#125;</span><br><span class="line">    return pNode;</span><br><span class="line">  &#125;</span><br><span class="line">  while (pNode.next != null) &#123;</span><br><span class="line">    if (pNode.next.left == pNode) &#123;</span><br><span class="line">      return pNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode = pNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-57-二叉树的下一个结点&quot;&gt;&lt;a href=&quot;#剑指offer-57-二叉树的下一个结点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 57.二叉树的下一个结点&quot;&gt;&lt;/a&gt;剑指offer 57.二叉树的下一个结点&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 56.删除链表中重复的结点</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2056.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 56.删除链表中重复的结点.html</id>
    <published>2020-03-05T13:50:00.000Z</published>
    <updated>2020-03-06T03:34:10.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-56-删除链表中重复的结点"><a href="#剑指offer-56-删除链表中重复的结点" class="headerlink" title="剑指offer 56.删除链表中重复的结点"></a>剑指offer 56.删除链表中重复的结点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接找就行了,记得先新建一个结点用于避免头结点也和别的相同值，如果下一个结点和当前节点相等，那么再到下一个结点直到不一样未知，然后直接把连起来就行。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next = null;</span><br><span class="line"></span><br><span class="line">  ListNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode deleteDuplication(ListNode pHead) &#123;</span><br><span class="line">  if (pHead == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode newhead = new ListNode(1);</span><br><span class="line">  newhead.next = pHead;</span><br><span class="line">  ListNode cur = pHead;</span><br><span class="line">  ListNode pre = newhead;</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">    if (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">      while (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">      pre.next = cur.next;</span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newhead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-56-删除链表中重复的结点&quot;&gt;&lt;a href=&quot;#剑指offer-56-删除链表中重复的结点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 56.删除链表中重复的结点&quot;&gt;&lt;/a&gt;剑指offer 56.删除链表中重复的结点&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 55.链表中环的入口结点</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2055.%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 55.链表中环的入口结点.html</id>
    <published>2020-03-05T13:40:00.000Z</published>
    <updated>2020-03-05T13:56:31.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-55-链表中环的入口结点"><a href="#剑指offer-55-链表中环的入口结点" class="headerlink" title="剑指offer 55.链表中环的入口结点"></a>剑指offer 55.链表中环的入口结点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>现在成了数学题了，首先设快慢两点都在开头，快结点一下走两步，慢结点一下走一步，当快结点追上慢结点就代表存在环。<br>当二者相遇，快结点回到开头，慢结点继续走，当二者再次相遇时，结点就为环的入口结点。记得要考虑到没有下一个结点的可能性。<br>数学问题我就不证明了，画一个图就能理解了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next = null;</span><br><span class="line"></span><br><span class="line">  ListNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode EntryNodeOfLoop(ListNode pHead) &#123;</span><br><span class="line">  ListNode fast = pHead;</span><br><span class="line">  ListNode slow = pHead;</span><br><span class="line">  while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    if (fast == slow) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (fast == null || fast.next == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  fast = pHead;</span><br><span class="line">  while (fast != slow) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-55-链表中环的入口结点&quot;&gt;&lt;a href=&quot;#剑指offer-55-链表中环的入口结点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 55.链表中环的入口结点&quot;&gt;&lt;/a&gt;剑指offer 55.链表中环的入口结点&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 54.字符流中第一个不重复的字符</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2054.%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.html"/>
    <id>https://cheng102e.github.io/剑指offer 54.字符流中第一个不重复的字符.html</id>
    <published>2020-03-05T13:20:00.000Z</published>
    <updated>2020-03-05T13:27:31.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-54-字符流中第一个不重复的字符"><a href="#剑指offer-54-字符流中第一个不重复的字符" class="headerlink" title="剑指offer 54.字符流中第一个不重复的字符"></a>剑指offer 54.字符流中第一个不重复的字符</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目描述<br>  请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>输出描述:<br>  如果当前字符流没有存在出现一次的字符，返回#字符。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我用LinkedHashMap，然后迭代器老是有问题，所以只能改成Hashmap加ArrayList，多了一个步骤。<br>首先是insert，在这里存放，通过hashmap存放字符和次数，list存放顺序，最后读取一下就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void Insert(char ch) &#123;</span><br><span class="line">  if (map.containsKey(ch)) &#123;</span><br><span class="line">    map.put(ch, map.get(ch) + 1);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    map.put(ch, 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  list.add(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public char FirstAppearingOnce() &#123;</span><br><span class="line">  char c = &apos;#&apos;;</span><br><span class="line">  for (char key : list) &#123;</span><br><span class="line">    if (map.get(key) == 1) &#123;</span><br><span class="line">      c = key;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-54-字符流中第一个不重复的字符&quot;&gt;&lt;a href=&quot;#剑指offer-54-字符流中第一个不重复的字符&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 54.字符流中第一个不重复的字符&quot;&gt;&lt;/a&gt;剑指offer 54.字符流
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 53.表示数值的字符串</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2053.%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://cheng102e.github.io/剑指offer 53.表示数值的字符串.html</id>
    <published>2020-03-05T13:10:00.000Z</published>
    <updated>2020-03-05T13:08:13.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-53-表示数值的字符串"><a href="#剑指offer-53-表示数值的字符串" class="headerlink" title="剑指offer 53.表示数值的字符串"></a>剑指offer 53.表示数值的字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>三种思路：</p><ol><li>正则表达式，这里要注意转义符号的使用。</li><li>自动机，编译原理中的概念，已经忘了.</li><li>遍历，硬算，设几个标签量来记录符号等，然后ifelse结束.</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean isNumeric(char[] str) &#123;</span><br><span class="line">  String que=String.valueOf(str);</span><br><span class="line">  return  que.matches(&quot;[\\+-]?[0-9]*(\\.[0-9]*)?([eE][\\+-]?[0-9]+)?&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-53-表示数值的字符串&quot;&gt;&lt;a href=&quot;#剑指offer-53-表示数值的字符串&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 53.表示数值的字符串&quot;&gt;&lt;/a&gt;剑指offer 53.表示数值的字符串&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 52.正则表达式匹配</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2052.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.html"/>
    <id>https://cheng102e.github.io/剑指offer 52.正则表达式匹配.html</id>
    <published>2020-03-05T12:10:00.000Z</published>
    <updated>2020-03-05T13:06:02.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-52-正则表达式匹配"><a href="#剑指offer-52-正则表达式匹配" class="headerlink" title="剑指offer 52.正则表达式匹配"></a>剑指offer 52.正则表达式匹配</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我对这题还真没什么思路，就，硬算，对于’.’的情况，不需要太过在意，只需要在用到的时候加一个判断即可。对于’*’的时候，需要多加讨论，是匹配当前0个字符就不用，还是匹配一个字符就不用，还是留下来匹配下一个字符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static boolean mate(char[] str, char[] pattern, int si, int pi) &#123;</span><br><span class="line"></span><br><span class="line">  if (str.length == si &amp;&amp; pattern.length == pi) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (str.length != si &amp;&amp; pattern.length == pi) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (pi + 1 &lt; pattern.length &amp;&amp; pattern[pi + 1] == &apos;*&apos;) &#123;</span><br><span class="line">    if (si != str.length &amp;&amp; ((str[si] == pattern[pi] || pattern[pi] == &apos;.&apos;))) &#123;</span><br><span class="line">      boolean t0 = mate(str, pattern, si, pi + 2);</span><br><span class="line">      boolean t1 = mate(str, pattern, si + 1, pi + 2);</span><br><span class="line">      boolean t2 = mate(str, pattern, si + 1, pi);</span><br><span class="line">      return t0 || t1 || t2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return mate(str, pattern, si, pi + 2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (si != str.length) &#123;</span><br><span class="line">    if (str[si] == pattern[pi] || pattern[pi] == &apos;.&apos;) &#123;</span><br><span class="line">      return mate(str, pattern, si + 1, pi + 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean match(char[] str, char[] pattern) &#123;</span><br><span class="line">  if (str == null || pattern == null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  int si = 0;</span><br><span class="line">  int pi = 0;</span><br><span class="line">  return mate(str, pattern, si, pi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-52-正则表达式匹配&quot;&gt;&lt;a href=&quot;#剑指offer-52-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 52.正则表达式匹配&quot;&gt;&lt;/a&gt;剑指offer 52.正则表达式匹配&lt;/h2&gt;&lt;h3 id=&quot;题
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 51.构建乘积数组</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2051.%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.html"/>
    <id>https://cheng102e.github.io/剑指offer 51.构建乘积数组.html</id>
    <published>2020-03-05T10:10:00.000Z</published>
    <updated>2020-03-05T12:50:39.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-51-构建乘积数组"><a href="#剑指offer-51-构建乘积数组" class="headerlink" title="剑指offer 51.构建乘积数组"></a>剑指offer 51.构建乘积数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这就要从双向往中间计算，首先计算前半部分，就是第一个for循环，对于B[i]来说，这里已经乘上了前半部分，还缺A[i+1]后面的，这时候第二个循环，反向，先给A[len-1]，然后向前逼近，设置一个临时变量表示后半的A乘积。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int[] multiply(int[] A) &#123;</span><br><span class="line">  int len = A.length;</span><br><span class="line">  int[] B = new int[len];</span><br><span class="line">  if (len != 0) &#123;</span><br><span class="line">    B[0] = 1;</span><br><span class="line">    for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">      B[i] = B[i - 1] * A[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = 1;</span><br><span class="line">    for (int j = len - 2; j &gt;= 0; j--) &#123;</span><br><span class="line">      temp *= A[j + 1];</span><br><span class="line">      B[j] *= temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-51-构建乘积数组&quot;&gt;&lt;a href=&quot;#剑指offer-51-构建乘积数组&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 51.构建乘积数组&quot;&gt;&lt;/a&gt;剑指offer 51.构建乘积数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 50.数组中重复的数字</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2050.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 50.数组中重复的数字.html</id>
    <published>2020-03-05T09:50:00.000Z</published>
    <updated>2020-03-05T12:50:40.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-50-数组中重复的数字"><a href="#剑指offer-50-数组中重复的数字" class="headerlink" title="剑指offer 50.数组中重复的数字"></a>剑指offer 50.数组中重复的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没什么特殊的，先判断特殊情况，然后遍历就行，如果数组已经有了，直接返回。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  public boolean duplicate(int numbers[], int length, int[] duplication) &#123;</span><br><span class="line">  if (numbers == null || length &lt;= 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (int i : numbers) &#123;</span><br><span class="line">    if (i &lt; 0 || i &gt; length - 1) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] ans = new int[length];</span><br><span class="line">  for (int i : numbers) &#123;</span><br><span class="line">    if (ans[i] == 0) &#123;</span><br><span class="line">      ans[i] = i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      duplication[0] = i;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-50-数组中重复的数字&quot;&gt;&lt;a href=&quot;#剑指offer-50-数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 50.数组中重复的数字&quot;&gt;&lt;/a&gt;剑指offer 50.数组中重复的数字&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 49.把字符串转换成整数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2049.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 49.把字符串转换成整数.html</id>
    <published>2020-03-05T09:40:00.000Z</published>
    <updated>2020-03-05T09:42:43.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-49-把字符串转换成整数"><a href="#剑指offer-49-把字符串转换成整数" class="headerlink" title="剑指offer 49.把字符串转换成整数"></a>剑指offer 49.把字符串转换成整数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目描述<br>  将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><p>输入描述:<br>  输入一个字符串,包括数字字母符号,可以为空</p><p>输出描述:<br>  如果是合法的数值表达则返回该数字，否则返回0</p><p>示例<br>  输入<br>  +2147483647<br>      1a33<br>  输出<br>  2147483647<br>      0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>面向结果编程了，最小负数我技穷做不出来，就额外加了个判断。<br>首先是首位的符号位，若有则记录下来，别的都是*10，再加当前位数，最后输出时候注意前面的符号位。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int StrToInt(String str) &#123;</span><br><span class="line">  if (str.equals(&quot;&quot;) || str.length() == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (str.equals(&quot;-2147483648&quot;)) &#123;</span><br><span class="line">    return -2147483648;</span><br><span class="line">  &#125;</span><br><span class="line">  char[] c = str.toCharArray();</span><br><span class="line">  boolean flag = true;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (char i : c) &#123;</span><br><span class="line">    if (i == &apos;+&apos;) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125; else if (i == &apos;-&apos;) &#123;</span><br><span class="line">      flag = false;</span><br><span class="line">    &#125; else if (i &lt; 48 || i &gt; 57) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      int temp = sum * 10 + i - 48;</span><br><span class="line">      if (((temp - i + 48) / 10 != sum) || temp % 10 &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      sum = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return flag ? sum : (-1) * sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-49-把字符串转换成整数&quot;&gt;&lt;a href=&quot;#剑指offer-49-把字符串转换成整数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 49.把字符串转换成整数&quot;&gt;&lt;/a&gt;剑指offer 49.把字符串转换成整数&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 48.不用加减乘除做加法</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2048.%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.html"/>
    <id>https://cheng102e.github.io/剑指offer 48.不用加减乘除做加法.html</id>
    <published>2020-03-05T08:40:00.000Z</published>
    <updated>2020-03-05T08:49:38.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-48-不用加减乘除做加法"><a href="#剑指offer-48-不用加减乘除做加法" class="headerlink" title="剑指offer 48.不用加减乘除做加法"></a>剑指offer 48.不用加减乘除做加法</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>(和上题把要用的删差不多了)<br>二进制相加操作就是异或操作，二进制进位操作就是与操作，首先temp就是相加，然后&amp;就是计算进位，左移一位，进位是有极限的，所以用num2存贮进位并且当做跳出条件，num1存放结果，等到没进位的时候，异或就是相加，直接输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int Add(int num1, int num2) &#123;</span><br><span class="line">  while (num2 != 0) &#123;</span><br><span class="line">    int temp = num1 ^ num2;</span><br><span class="line">    num2 = (num1 &amp; num2) &lt;&lt; 1;</span><br><span class="line">    num1 = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  return num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-48-不用加减乘除做加法&quot;&gt;&lt;a href=&quot;#剑指offer-48-不用加减乘除做加法&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 48.不用加减乘除做加法&quot;&gt;&lt;/a&gt;剑指offer 48.不用加减乘除做加法&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
