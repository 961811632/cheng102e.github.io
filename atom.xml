<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-03-04T13:08:52.568Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer 40.数组中只出现一次的数字</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2040.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 40.数组中只出现一次的数字.html</id>
    <published>2020-03-04T12:47:00.000Z</published>
    <updated>2020-03-04T13:08:52.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-40-数组中只出现一次的数字"><a href="#剑指offer-40-数组中只出现一次的数字" class="headerlink" title="剑指offer 40.数组中只出现一次的数字"></a>剑指offer 40.数组中只出现一次的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果只有一个数，当然是异或更好用，相同数字异或为0，但是有两个数字，这种方法无法快速找到，所以不如用hashset，如果存在就删除，不存在就加入，最后把两个数字取出来即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123;</span><br><span class="line"></span><br><span class="line">  HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  for (int i : array) &#123;</span><br><span class="line">    if (set.contains(i)) &#123;</span><br><span class="line">      set.remove(i);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] t = new int[2];</span><br><span class="line">  int temp = 0;</span><br><span class="line">  Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">  while (iterator.hasNext()) &#123;</span><br><span class="line">    t[temp++] = iterator.next();</span><br><span class="line">  &#125;</span><br><span class="line">  num1[0] = t[0];</span><br><span class="line">  num2[0] = t[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-40-数组中只出现一次的数字&quot;&gt;&lt;a href=&quot;#剑指offer-40-数组中只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 40.数组中只出现一次的数字&quot;&gt;&lt;/a&gt;剑指offer 40.数组中只出现一次的
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 39.平衡二叉树</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2039.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://cheng102e.github.io/剑指offer 39.平衡二叉树.html</id>
    <published>2020-03-04T12:37:00.000Z</published>
    <updated>2020-03-04T12:39:59.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-39-平衡二叉树"><a href="#剑指offer-39-平衡二叉树" class="headerlink" title="剑指offer 39.平衡二叉树"></a>剑指offer 39.平衡二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>继续偷懒，用前一题的代码，求深度，在返回之前比较一下左右子树深度，若差值大于1，结果置为false。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean ans = true;</span><br><span class="line"></span><br><span class="line">public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = TreeDepth(root.left);</span><br><span class="line">  int right = TreeDepth(root.right);</span><br><span class="line">  if (Math.abs(left - right) &gt; 1) &#123;</span><br><span class="line">    ans = false;</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(left, right) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">  int i = TreeDepth(root);</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-39-平衡二叉树&quot;&gt;&lt;a href=&quot;#剑指offer-39-平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 39.平衡二叉树&quot;&gt;&lt;/a&gt;剑指offer 39.平衡二叉树&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 38.二叉树的深度</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2038.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.html"/>
    <id>https://cheng102e.github.io/剑指offer 38.二叉树的深度.html</id>
    <published>2020-03-04T12:17:00.000Z</published>
    <updated>2020-03-04T12:39:54.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-38-二叉树的深度"><a href="#剑指offer-38-二叉树的深度" class="headerlink" title="剑指offer 38.二叉树的深度"></a>剑指offer 38.二叉树的深度</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>偷个懒，直接用递归，如果结点为空就不增长深度，不为空就返回子树的深度加一。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(TreeDepth(root.left), TreeDepth(root.right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-38-二叉树的深度&quot;&gt;&lt;a href=&quot;#剑指offer-38-二叉树的深度&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 38.二叉树的深度&quot;&gt;&lt;/a&gt;剑指offer 38.二叉树的深度&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 37.数字在排序数组中出现的次数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2037.%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 37.数字在排序数组中出现的次数.html</id>
    <published>2020-03-04T11:55:00.000Z</published>
    <updated>2020-03-04T12:17:32.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-37-数字在排序数组中出现的次数"><a href="#剑指offer-37-数字在排序数组中出现的次数" class="headerlink" title="剑指offer 37.数字在排序数组中出现的次数"></a>剑指offer 37.数字在排序数组中出现的次数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>统计一个数字在排序数组中出现的次数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然递归已经是O(n)了，但是还要缩小，所以二分查找，找到前后的位置就行了。查找设k-0.5和k+0.5，反正都没有，所以能找到应该在的位置，然后减法就行。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int search(int[] array, double k) &#123;</span><br><span class="line">  int l = 0;</span><br><span class="line">  int r = array.length - 1;</span><br><span class="line">  int m = (r - l) / 2 + l;</span><br><span class="line">  while (l &lt;= r) &#123;</span><br><span class="line">    if (array[m] &lt; k) &#123;</span><br><span class="line">      l = m + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      r = m - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    m = (r - l) / 2 + l;</span><br><span class="line">  &#125;</span><br><span class="line">  return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int GetNumberOfK(int[] array, int k) &#123;</span><br><span class="line">  int start = search(array, k - 0.5);</span><br><span class="line">  int end = search(array, k + 0.5);</span><br><span class="line">  return end - start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-37-数字在排序数组中出现的次数&quot;&gt;&lt;a href=&quot;#剑指offer-37-数字在排序数组中出现的次数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 37.数字在排序数组中出现的次数&quot;&gt;&lt;/a&gt;剑指offer 37.数字在
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 36.两个链表的第一个公共结点</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2036.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 36.两个链表的第一个公共结点.html</id>
    <published>2020-03-04T10:55:00.000Z</published>
    <updated>2020-03-04T11:56:59.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-36-两个链表的第一个公共结点"><a href="#剑指offer-36-两个链表的第一个公共结点" class="headerlink" title="剑指offer 36.两个链表的第一个公共结点"></a>剑指offer 36.两个链表的第一个公共结点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果可以的话，从后往前比较最合适。但是不行，我们需要考虑两个链表的长度不同，长度为len1和len2，长的先走完差值，然后两个一起往后面走，就可以找到相同的结点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next = null;</span><br><span class="line"></span><br><span class="line">  ListNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">  if (pHead1 == null || pHead2 == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode p1 = pHead1;</span><br><span class="line">  ListNode p2 = pHead2;</span><br><span class="line">  int len1 = 0;</span><br><span class="line">  int len2 = 0;</span><br><span class="line">  while (p1.next != null) &#123;</span><br><span class="line">    len1++;</span><br><span class="line">    p1 = p1.next;</span><br><span class="line">  &#125;</span><br><span class="line">  while (p2.next != null) &#123;</span><br><span class="line">    len2++;</span><br><span class="line">    p2 = p2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  p1 = pHead1;</span><br><span class="line">  p2 = pHead2;</span><br><span class="line">  if (len1 &gt; len2) &#123;</span><br><span class="line">    for (int i = len1 - len2; i &gt;= 0; i--) &#123;</span><br><span class="line">      p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (int i = len2 - len1; i &gt;= 0; i--) &#123;</span><br><span class="line">      p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while (p1 != p2) &#123;</span><br><span class="line">    p1 = p1.next;</span><br><span class="line">    p2 = p2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-36-两个链表的第一个公共结点&quot;&gt;&lt;a href=&quot;#剑指offer-36-两个链表的第一个公共结点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 36.两个链表的第一个公共结点&quot;&gt;&lt;/a&gt;剑指offer 36.两个链表的第
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 35.数组中的逆序对</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2035.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 35.数组中的逆序对.html</id>
    <published>2020-03-04T10:40:00.000Z</published>
    <updated>2020-03-04T10:47:29.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-35-数组中的逆序对"><a href="#剑指offer-35-数组中的逆序对" class="headerlink" title="剑指offer 35.数组中的逆序对"></a>剑指offer 35.数组中的逆序对</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目描述<br>  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><p>输入描述:<br>  题目保证输入的数组中没有的相同的数字</p><p>数据范围：</p><p>  对于%50的数据,size&lt;=10^4<br>  对于%75的数据,size&lt;=10^5<br>  对于%100的数据,size&lt;=2*10^5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题好麻烦的，最后选择了模拟归并排序的方法，分成最小的块然后进行归并，归并时内部的逆序对就已经计算了，不需要再计算一次。<br>以158，236为例子，首先1&lt;2，逆序不用计算，然后5&gt;3，应该放3，逆序增加5，8两个数字，为mid-l+1，行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">long count = 0;</span><br><span class="line"></span><br><span class="line">public void merge(int[] array, int[] copy, int start, int end) &#123;</span><br><span class="line">  if (start &gt;= end) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int mid = (end - start) / 2 + start;</span><br><span class="line">  merge(array, copy, start, mid);</span><br><span class="line">  merge(array, copy, mid + 1, end);</span><br><span class="line">  int l = start;</span><br><span class="line">  int r = mid + 1;</span><br><span class="line">  int temp = start;</span><br><span class="line">  while (l &lt;= mid &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">    if (array[l] &lt;= array[r]) &#123;</span><br><span class="line">      copy[temp++] = array[l++];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      count += mid - l + 1;</span><br><span class="line">      copy[temp++] = array[r++];</span><br><span class="line">      if (count &gt; 1000000007) &#123;</span><br><span class="line">        count %=  1000000007;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while (l &lt;= mid) &#123;</span><br><span class="line">    copy[temp++] = array[l++];</span><br><span class="line">  &#125;</span><br><span class="line">  while (r &lt;= end) &#123;</span><br><span class="line">    copy[temp++] = array[r++];</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">    array[i] = copy[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int InversePairs(int[] array) &#123;</span><br><span class="line">  int start = 0;</span><br><span class="line">  int end = array.length - 1;</span><br><span class="line">  int[] copy = new int[array.length];</span><br><span class="line">  merge(array, copy, start, end);</span><br><span class="line">  return (int) count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-35-数组中的逆序对&quot;&gt;&lt;a href=&quot;#剑指offer-35-数组中的逆序对&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 35.数组中的逆序对&quot;&gt;&lt;/a&gt;剑指offer 35.数组中的逆序对&lt;/h2&gt;&lt;h3 id=&quot;题
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 34.第一个只出现一次的字符</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2034.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.html"/>
    <id>https://cheng102e.github.io/剑指offer 34.第一个只出现一次的字符.html</id>
    <published>2020-03-04T09:50:00.000Z</published>
    <updated>2020-03-04T09:59:45.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-34-第一个只出现一次的字符"><a href="#剑指offer-34-第一个只出现一次的字符" class="headerlink" title="剑指offer 34.第一个只出现一次的字符"></a>剑指offer 34.第一个只出现一次的字符</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种统计数量的，优先拿hashmap，遍历时若不存在，直接放入，存在的话，数字加一。<br>最后按照字符串中的顺序遍历一下，若次数为1直接输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">  if (str == null || str.length() == 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">  StringBuffer que = new StringBuffer(str);</span><br><span class="line">  for (int i = 0; i &lt; que.length(); i++) &#123;</span><br><span class="line">    char temp = que.charAt(i);</span><br><span class="line">    if (map.containsKey(temp)) &#123;</span><br><span class="line">      int num = map.get(temp);</span><br><span class="line">      map.put(temp, ++num);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      map.put(temp, 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; que.length(); i++) &#123;</span><br><span class="line">    if (map.get(que.charAt(i)) == 1) &#123;</span><br><span class="line">      return i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-34-第一个只出现一次的字符&quot;&gt;&lt;a href=&quot;#剑指offer-34-第一个只出现一次的字符&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 34.第一个只出现一次的字符&quot;&gt;&lt;/a&gt;剑指offer 34.第一个只出现一次的
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 33.丑数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2033.%E4%B8%91%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 33.丑数.html</id>
    <published>2020-03-04T04:50:00.000Z</published>
    <updated>2020-03-04T05:55:33.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-33-丑数"><a href="#剑指offer-33-丑数" class="headerlink" title="剑指offer 33.丑数"></a>剑指offer 33.丑数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里采用的是三指针法，任意丑数都是比这个数小的丑数乘以2，3，5其中之一得到的，要求按照顺序排列，那么就从之前的数中找到未被使用过的数乘一下，然后比较，就可以得到新的数了。<br>首先初始位为1，设三个指针值n2,n3,n5,初始设为0.之后开始循环，每次循环都找到235未乘过的数字乘一下，然后取最小值为新的丑数。之后，若n2n3n5使用过了，那么指针位+1，下次乘下一个数字，如果都可以，那就都加。把数字记录下来最后输出即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">  if(index==0)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] ans = new int[index];</span><br><span class="line">  int n2 = 0, n3 = 0, n5 = 0;</span><br><span class="line">  ans[0] = 1;</span><br><span class="line">  for (int i = 1; i &lt; index; i++) &#123;</span><br><span class="line">    int min = Math.min(ans[n2] * 2, Math.min(ans[n3] * 3, ans[n5] * 5));</span><br><span class="line">    ans[i] = min;</span><br><span class="line">    if (min == ans[n2]*2) &#123;</span><br><span class="line">      n2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (min == ans[n3]*3) &#123;</span><br><span class="line">      n3++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (min == ans[n5]*5) &#123;</span><br><span class="line">      n5++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return ans[index-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-33-丑数&quot;&gt;&lt;a href=&quot;#剑指offer-33-丑数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 33.丑数&quot;&gt;&lt;/a&gt;剑指offer 33.丑数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; cla
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 32.把数组排成最小的数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2032.%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 32.把数组排成最小的数.html</id>
    <published>2020-03-04T03:50:00.000Z</published>
    <updated>2020-03-04T03:54:05.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-32-把数组排成最小的数"><a href="#剑指offer-32-把数组排成最小的数" class="headerlink" title="剑指offer 32.把数组排成最小的数"></a>剑指offer 32.把数组排成最小的数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路就是，先建一个ArrayList存放数字，对这个进行排序，然后转换成字符串。问题就是中间的排序，排序直接用了sort，改一下比较器就行，假设有两个数字，12，34，1234&lt;3412，所以12就往前面排，以此类推，最后得到答案。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static String PrintMinNumber(int[] numbers) &#123;</span><br><span class="line">  StringBuffer str = new StringBuffer();</span><br><span class="line">  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">  for (int i:numbers) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  Collections.sort(list, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">      String s1 = o1 + &quot;&quot; + o2;</span><br><span class="line">      String s2 = o2 + &quot;&quot; + o1;</span><br><span class="line">      return s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  for (int i:list)&#123;</span><br><span class="line">    str.append(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-32-把数组排成最小的数&quot;&gt;&lt;a href=&quot;#剑指offer-32-把数组排成最小的数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 32.把数组排成最小的数&quot;&gt;&lt;/a&gt;剑指offer 32.把数组排成最小的数&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 31.整数中1出现的次数（从1到n整数中1出现的次数）</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2031.%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89.html"/>
    <id>https://cheng102e.github.io/剑指offer 31.整数中1出现的次数（从1到n整数中1出现的次数）.html</id>
    <published>2020-03-04T03:30:00.000Z</published>
    <updated>2020-03-04T03:34:00.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-31-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#剑指offer-31-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="剑指offer 31.整数中1出现的次数（从1到n整数中1出现的次数）"></a>剑指offer 31.整数中1出现的次数（从1到n整数中1出现的次数）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然有不少比较巧妙的算法，但我还是选择了最快的方法(思路最清晰)。新建一个StringBuffer，然后把数字全塞进去，遍历一下，成了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int NumberOf1Between1AndN_Solution(int n) &#123;</span><br><span class="line">  StringBuffer str = new StringBuffer();</span><br><span class="line">  for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    str.append(i);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  int count = 0;</span><br><span class="line">  for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">    if (str.charAt(i) == &apos;1&apos;) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-31-整数中1出现的次数（从1到n整数中1出现的次数）&quot;&gt;&lt;a href=&quot;#剑指offer-31-整数中1出现的次数（从1到n整数中1出现的次数）&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 31.整数中1出现的次数（从
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 30.连续子数组的最大和</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2030.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html"/>
    <id>https://cheng102e.github.io/剑指offer 30.连续子数组的最大和.html</id>
    <published>2020-03-04T02:30:00.000Z</published>
    <updated>2020-03-04T03:31:17.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-30-连续子数组的最大和"><a href="#剑指offer-30-连续子数组的最大和" class="headerlink" title="剑指offer 30.连续子数组的最大和"></a>剑指offer 30.连续子数组的最大和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个思路就是动态规划，但是没必要照状态转移方程来写，先设置两个变量，sum代表当前序列的和，max代表最大子序列的和，对于每个数组，若这时的sum已经小于0，那么对于新的序列就是负收益，直接舍弃，若此时sum大于0，那么就是正收益，不用舍弃，继续叠加。于此同时记得保存最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line"></span><br><span class="line">  int sum = array[0];</span><br><span class="line">  int max = sum;</span><br><span class="line">  for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (sum &lt; 0) &#123;</span><br><span class="line">      sum = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += array[i];</span><br><span class="line">    if (sum &gt; max) &#123;</span><br><span class="line">      max = sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-30-连续子数组的最大和&quot;&gt;&lt;a href=&quot;#剑指offer-30-连续子数组的最大和&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 30.连续子数组的最大和&quot;&gt;&lt;/a&gt;剑指offer 30.连续子数组的最大和&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 29.最小的K个数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2029.%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 29.最小的K个数.html</id>
    <published>2020-03-03T14:30:00.000Z</published>
    <updated>2020-03-04T03:31:15.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-29-最小的K个数"><a href="#剑指offer-29-最小的K个数" class="headerlink" title="剑指offer 29.最小的K个数"></a>剑指offer 29.最小的K个数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>几种方法，我一开始想到的是直接快排函数，然后输出k个就行，之后改用优先队列建堆，大小控制为k，大于这个数量就删除堆顶(最大值),最后只剩k个，输出到ans当中即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123;</span><br><span class="line"></span><br><span class="line">  ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">  if (input == null || k &lt;= 0 || k &gt; input.length) &#123;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; input.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    if (queue.size() &lt; k) &#123;</span><br><span class="line">      queue.add(input[i]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (input[i] &lt; queue.peek()) &#123;</span><br><span class="line">        queue.remove();</span><br><span class="line">        queue.add(input[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while (!queue.isEmpty()) &#123;</span><br><span class="line">    ans.add(queue.remove());</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-29-最小的K个数&quot;&gt;&lt;a href=&quot;#剑指offer-29-最小的K个数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 29.最小的K个数&quot;&gt;&lt;/a&gt;剑指offer 29.最小的K个数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 28.数组中出现次数超过一半的数字</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2028.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 28.数组中出现次数超过一半的数字.html</id>
    <published>2020-03-03T11:30:00.000Z</published>
    <updated>2020-03-03T12:06:37.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-28-数组中出现次数超过一半的数字"><a href="#剑指offer-28-数组中出现次数超过一半的数字" class="headerlink" title="剑指offer 28.数组中出现次数超过一半的数字"></a>剑指offer 28.数组中出现次数超过一半的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这有多种方法，我最后选择了图，思路清晰。<br>首先把数组放进一个hashmap当中，value值做出现次数。然后拿迭代器一对一对取出来，若数量大于总长度一半就输出值，不然就下一个。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int[] array) &#123;</span><br><span class="line">  if (array == null || array.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">  for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (map.containsKey(array[i])) &#123;</span><br><span class="line">      int count = map.get(array[i]);</span><br><span class="line">      map.put(array[i], ++count);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      map.put(array[i], 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator iter = map.entrySet().iterator();</span><br><span class="line">  while (iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = (Entry&lt;Integer, Integer&gt;) iter.next();</span><br><span class="line">    if (entry.getValue() &gt; array.length / 2) &#123;</span><br><span class="line">      return entry.getKey();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-28-数组中出现次数超过一半的数字&quot;&gt;&lt;a href=&quot;#剑指offer-28-数组中出现次数超过一半的数字&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 28.数组中出现次数超过一半的数字&quot;&gt;&lt;/a&gt;剑指offer 28.
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 27.字符串的排列</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2027.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 27.字符串的排列.html</id>
    <published>2020-03-01T13:10:00.000Z</published>
    <updated>2020-03-03T11:34:06.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-27-字符串的排列"><a href="#剑指offer-27-字符串的排列" class="headerlink" title="剑指offer 27.字符串的排列"></a>剑指offer 27.字符串的排列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目描述<br>  输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>  输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法加上递归思路，找到所有可能的排列情况，全部加入到最后的结果集合中，这里要记得去重，最后输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> public ArrayList&lt;String&gt; Permutation(String str) &#123;</span><br><span class="line">  ArrayList&lt;String&gt; resultList = new ArrayList&lt;&gt;();</span><br><span class="line">  if (str.length() == 0) &#123;</span><br><span class="line">    return resultList;</span><br><span class="line">  &#125;</span><br><span class="line">  fun(str.toCharArray(), resultList, 0);</span><br><span class="line">  Collections.sort(resultList);</span><br><span class="line"></span><br><span class="line">  return resultList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void fun(char[] ch, List&lt;String&gt; list, int i) &#123;</span><br><span class="line"></span><br><span class="line">  if (i == ch.length - 1) &#123;</span><br><span class="line">    if (!list.contains(new String(ch))) &#123;</span><br><span class="line">      list.add(new String(ch));</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (int j = i; j &lt; ch.length; j++) &#123;</span><br><span class="line">      swap(ch, i, j);</span><br><span class="line">      fun(ch, list, i + 1);</span><br><span class="line">      swap(ch, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(char[] str, int i, int j) &#123;</span><br><span class="line">  if (i != j) &#123;</span><br><span class="line">    char t = str[i];</span><br><span class="line">    str[i] = str[j];</span><br><span class="line">    str[j] = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-27-字符串的排列&quot;&gt;&lt;a href=&quot;#剑指offer-27-字符串的排列&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 27.字符串的排列&quot;&gt;&lt;/a&gt;剑指offer 27.字符串的排列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 26.二叉搜索树与双向链表</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2026.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html"/>
    <id>https://cheng102e.github.io/剑指offer 26.二叉搜索树与双向链表.html</id>
    <published>2020-03-01T12:00:00.000Z</published>
    <updated>2020-03-01T12:13:40.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树还是要递归方法，对于每个节点，若为空直接返回，不然就递归到子节点。这里和正常的不一样，先寻找右节点，然后在找左节点，可以省下来一个存储位。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode ans = null;</span><br><span class="line"></span><br><span class="line">public TreeNode Convert(TreeNode pRootOfTree) &#123;</span><br><span class="line">  if (pRootOfTree == null) &#123;</span><br><span class="line">    return pRootOfTree;</span><br><span class="line">  &#125;</span><br><span class="line">  Convert(pRootOfTree.right);</span><br><span class="line">  if (ans == null) &#123;</span><br><span class="line">    ans = pRootOfTree;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ans.left = pRootOfTree;</span><br><span class="line">    pRootOfTree.right = ans;</span><br><span class="line">    ans = pRootOfTree;</span><br><span class="line">  &#125;</span><br><span class="line">  Convert(pRootOfTree.left);</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;26-二叉搜索树与双向链表&quot;&gt;&lt;a href=&quot;#26-二叉搜索树与双向链表&quot; class=&quot;headerlink&quot; title=&quot;26.二叉搜索树与双向链表&quot;&gt;&lt;/a&gt;26.二叉搜索树与双向链表&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; cla
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 25.复杂链表的复制</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2025.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html"/>
    <id>https://cheng102e.github.io/剑指offer 25.复杂链表的复制.html</id>
    <published>2020-03-01T04:00:00.000Z</published>
    <updated>2020-03-01T12:05:04.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>好繁琐一道题，用了三次遍历，赋值的时候用了三目运算符缩短代码。</p><ol><li>在每个节点后增加一个新节点，只有节点本身。</li><li>给每个新增节点增加random。</li><li>分开两个链表。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> public class RandomListNode &#123;</span><br><span class="line"></span><br><span class="line">  int label;</span><br><span class="line">  RandomListNode next = null;</span><br><span class="line">  RandomListNode random = null;</span><br><span class="line"></span><br><span class="line">  RandomListNode(int label) &#123;</span><br><span class="line">    this.label = label;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public RandomListNode Clone(RandomListNode pHead) &#123;</span><br><span class="line">  if (pHead == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  RandomListNode cur = pHead;</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">    RandomListNode nextnode = cur.next;</span><br><span class="line">    RandomListNode clone = new RandomListNode(cur.label);</span><br><span class="line">    cur.next = clone;</span><br><span class="line">    clone.next = nextnode;</span><br><span class="line">    cur = nextnode;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = pHead;</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">    cur.next.random = cur.random == null ? null : cur.random.next;</span><br><span class="line">    cur = cur.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = pHead;</span><br><span class="line">  RandomListNode newHead = pHead.next;</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">    RandomListNode clone = cur.next;</span><br><span class="line">    cur.next = clone.next;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    clone.next = clone.next == null ? null : clone.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;25-复杂链表的复制&quot;&gt;&lt;a href=&quot;#25-复杂链表的复制&quot; class=&quot;headerlink&quot; title=&quot;25.复杂链表的复制&quot;&gt;&lt;/a&gt;25.复杂链表的复制&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="https://cheng102e.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 23.二叉搜索树的后序遍历序列</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2023.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 23.二叉搜索树的后序遍历序列.html</id>
    <published>2020-02-29T10:00:00.000Z</published>
    <updated>2020-02-29T12:11:55.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树性质就是左子树小于根节点小于右节点，以最右侧为根，判断一下让数组左侧均小于根，根小于右侧，然后分成两块继续运算即可。<br>(我真的不知道为什么越界啊，我也不知道为什么突然就不越界了)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  public boolean vt(int[] sequence, int start, int end) &#123;</span><br><span class="line">  if (start&gt;=end) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  int root = sequence[end];</span><br><span class="line">  int mid = start;</span><br><span class="line">  for (; mid &lt; end; mid++) &#123;</span><br><span class="line">    if (root &lt; sequence[mid]) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = mid; i &lt; end; i++) &#123;</span><br><span class="line">    if (root &gt; sequence[i]) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  boolean left = true;</span><br><span class="line">  boolean right = true;</span><br><span class="line">  if (start &lt;= mid - 1) &#123;</span><br><span class="line">    left = vt(sequence, start, mid - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  if (mid &lt;= end - 1) &#123;</span><br><span class="line">    right = vt(sequence, mid, end - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return left &amp;&amp; right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean VerifySquenceOfBST(int[] sequence) &#123;</span><br><span class="line">  if (sequence == null || sequence.length == 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (sequence.length &lt; 3) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return vt(sequence, 0, sequence.length - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;23-二叉搜索树的后序遍历序列&quot;&gt;&lt;a href=&quot;#23-二叉搜索树的后序遍历序列&quot; class=&quot;headerlink&quot; title=&quot;23.二叉搜索树的后序遍历序列&quot;&gt;&lt;/a&gt;23.二叉搜索树的后序遍历序列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 24.二叉树中和为某一值的路径</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2024.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.html"/>
    <id>https://cheng102e.github.io/剑指offer 24.二叉树中和为某一值的路径.html</id>
    <published>2020-02-29T10:00:00.000Z</published>
    <updated>2020-03-01T03:59:24.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>路径问题就直接递归就行了，用一个list存储当前路径，如果成功就加入答案集，不成功就删除最后一个结点回溯。<br>这里还要用sort比较一下，Collections.sort(all, ((o1, o2) -&gt; o2.size() - o1.size()))，比较的时候就是降序排列。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void find(TreeNode root, int target, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; all, ArrayList list) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  int value = root.val;</span><br><span class="line">  list.add(value);</span><br><span class="line">  if (target == value &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">    all.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    find(root.left, target - value, all, list);</span><br><span class="line">    find(root.right, target - value, all, list);</span><br><span class="line">  &#125;</span><br><span class="line">  list.remove(list.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123;</span><br><span class="line">  ArrayList&lt;ArrayList&lt;Integer&gt;&gt; all = new ArrayList&lt;&gt;();</span><br><span class="line">  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">  find(root, target, all, list);</span><br><span class="line">  Collections.sort(all, ((o1, o2) -&gt; o2.size() - o1.size()));</span><br><span class="line">  return all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;24-二叉树中和为某一值的路径&quot;&gt;&lt;a href=&quot;#24-二叉树中和为某一值的路径&quot; class=&quot;headerlink&quot; title=&quot;24.二叉树中和为某一值的路径&quot;&gt;&lt;/a&gt;24.二叉树中和为某一值的路径&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 21.栈的压入、弹出序列</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2021.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 21.栈的压入、弹出序列.html</id>
    <published>2020-02-29T07:30:00.000Z</published>
    <updated>2020-02-29T08:29:03.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题思路倒是比较清晰，设置一个栈模拟进栈出栈过程，坑一点的就是边界问题，我本来是以出栈为循环条件的，边界越整越多，最后换了入栈为循环条件，简单了很多。<br>如果栈不为空且栈顶和出栈顺序一样，出栈，不然下一位。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean IsPopOrder(int[] pushA, int[] popA) &#123;</span><br><span class="line">  Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">  int len = pushA.length;</span><br><span class="line"></span><br><span class="line">  int in = 0, out = 0;</span><br><span class="line">  for (; in &lt; len; in++) &#123;</span><br><span class="line"></span><br><span class="line">    stack.push(pushA[in]);</span><br><span class="line"></span><br><span class="line">    while (!stack.empty() &amp;&amp; stack.peek() == popA[out]) &#123;</span><br><span class="line">      stack.pop();</span><br><span class="line">      out++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return stack.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-栈的压入、弹出序列&quot;&gt;&lt;a href=&quot;#21-栈的压入、弹出序列&quot; class=&quot;headerlink&quot; title=&quot;21.栈的压入、弹出序列&quot;&gt;&lt;/a&gt;21.栈的压入、弹出序列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 22.从上往下打印二叉树</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2022.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://cheng102e.github.io/剑指offer 22.从上往下打印二叉树.html</id>
    <published>2020-02-29T07:30:00.000Z</published>
    <updated>2020-02-29T09:09:49.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题就是简单的树的遍历，调节顺序就可以用队列来帮助存储，先把结点存放进队列，从队列头部取出节点，然后查看左子节点和右子节点，取出的时候记得保存值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">      return list;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">      TreeNode temp = queue.poll();</span><br><span class="line">      if (temp.left != null) &#123;</span><br><span class="line">        queue.offer(temp.left);</span><br><span class="line">      &#125;</span><br><span class="line">      if (temp.right != null) &#123;</span><br><span class="line">        queue.offer(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">      list.add(temp.val);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;22-从上往下打印二叉树&quot;&gt;&lt;a href=&quot;#22-从上往下打印二叉树&quot; class=&quot;headerlink&quot; title=&quot;22.从上往下打印二叉树&quot;&gt;&lt;/a&gt;22.从上往下打印二叉树&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
