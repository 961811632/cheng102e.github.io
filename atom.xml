<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-03-03T14:49:41.663Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer 29.最小的K个数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2029.%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 29.最小的K个数.html</id>
    <published>2020-03-03T14:30:00.000Z</published>
    <updated>2020-03-03T14:49:41.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-29-最小的K个数"><a href="#剑指offer-29-最小的K个数" class="headerlink" title="剑指offer 29.最小的K个数"></a>剑指offer 29.最小的K个数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>几种方法，我一开始想到的是直接快排函数，然后输出k个就行，之后改用优先队列建堆，大小控制为k，大于这个数量就删除堆顶(最大值),最后只剩k个，输出到ans当中即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123;</span><br><span class="line"></span><br><span class="line">  ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">  if (input == null || k &lt;= 0 || k &gt; input.length) &#123;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; input.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    if (queue.size() &lt; k) &#123;</span><br><span class="line">      queue.add(input[i]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (input[i] &lt; queue.peek()) &#123;</span><br><span class="line">        queue.remove();</span><br><span class="line">        queue.add(input[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while (!queue.isEmpty()) &#123;</span><br><span class="line">    ans.add(queue.remove());</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-29-最小的K个数&quot;&gt;&lt;a href=&quot;#剑指offer-29-最小的K个数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 29.最小的K个数&quot;&gt;&lt;/a&gt;剑指offer 29.最小的K个数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 28.数组中出现次数超过一半的数字</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2028.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 28.数组中出现次数超过一半的数字.html</id>
    <published>2020-03-03T11:30:00.000Z</published>
    <updated>2020-03-03T12:06:37.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-28-数组中出现次数超过一半的数字"><a href="#剑指offer-28-数组中出现次数超过一半的数字" class="headerlink" title="剑指offer 28.数组中出现次数超过一半的数字"></a>剑指offer 28.数组中出现次数超过一半的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这有多种方法，我最后选择了图，思路清晰。<br>首先把数组放进一个hashmap当中，value值做出现次数。然后拿迭代器一对一对取出来，若数量大于总长度一半就输出值，不然就下一个。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int[] array) &#123;</span><br><span class="line">  if (array == null || array.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">  for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (map.containsKey(array[i])) &#123;</span><br><span class="line">      int count = map.get(array[i]);</span><br><span class="line">      map.put(array[i], ++count);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      map.put(array[i], 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator iter = map.entrySet().iterator();</span><br><span class="line">  while (iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = (Entry&lt;Integer, Integer&gt;) iter.next();</span><br><span class="line">    if (entry.getValue() &gt; array.length / 2) &#123;</span><br><span class="line">      return entry.getKey();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-28-数组中出现次数超过一半的数字&quot;&gt;&lt;a href=&quot;#剑指offer-28-数组中出现次数超过一半的数字&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 28.数组中出现次数超过一半的数字&quot;&gt;&lt;/a&gt;剑指offer 28.
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 27.字符串的排列</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2027.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 27.字符串的排列.html</id>
    <published>2020-03-01T13:10:00.000Z</published>
    <updated>2020-03-03T11:34:06.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-27-字符串的排列"><a href="#剑指offer-27-字符串的排列" class="headerlink" title="剑指offer 27.字符串的排列"></a>剑指offer 27.字符串的排列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目描述<br>  输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>  输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法加上递归思路，找到所有可能的排列情况，全部加入到最后的结果集合中，这里要记得去重，最后输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> public ArrayList&lt;String&gt; Permutation(String str) &#123;</span><br><span class="line">  ArrayList&lt;String&gt; resultList = new ArrayList&lt;&gt;();</span><br><span class="line">  if (str.length() == 0) &#123;</span><br><span class="line">    return resultList;</span><br><span class="line">  &#125;</span><br><span class="line">  fun(str.toCharArray(), resultList, 0);</span><br><span class="line">  Collections.sort(resultList);</span><br><span class="line"></span><br><span class="line">  return resultList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void fun(char[] ch, List&lt;String&gt; list, int i) &#123;</span><br><span class="line"></span><br><span class="line">  if (i == ch.length - 1) &#123;</span><br><span class="line">    if (!list.contains(new String(ch))) &#123;</span><br><span class="line">      list.add(new String(ch));</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (int j = i; j &lt; ch.length; j++) &#123;</span><br><span class="line">      swap(ch, i, j);</span><br><span class="line">      fun(ch, list, i + 1);</span><br><span class="line">      swap(ch, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(char[] str, int i, int j) &#123;</span><br><span class="line">  if (i != j) &#123;</span><br><span class="line">    char t = str[i];</span><br><span class="line">    str[i] = str[j];</span><br><span class="line">    str[j] = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-27-字符串的排列&quot;&gt;&lt;a href=&quot;#剑指offer-27-字符串的排列&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 27.字符串的排列&quot;&gt;&lt;/a&gt;剑指offer 27.字符串的排列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 26.二叉搜索树与双向链表</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2026.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html"/>
    <id>https://cheng102e.github.io/剑指offer 26.二叉搜索树与双向链表.html</id>
    <published>2020-03-01T12:00:00.000Z</published>
    <updated>2020-03-01T12:13:40.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树还是要递归方法，对于每个节点，若为空直接返回，不然就递归到子节点。这里和正常的不一样，先寻找右节点，然后在找左节点，可以省下来一个存储位。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode ans = null;</span><br><span class="line"></span><br><span class="line">public TreeNode Convert(TreeNode pRootOfTree) &#123;</span><br><span class="line">  if (pRootOfTree == null) &#123;</span><br><span class="line">    return pRootOfTree;</span><br><span class="line">  &#125;</span><br><span class="line">  Convert(pRootOfTree.right);</span><br><span class="line">  if (ans == null) &#123;</span><br><span class="line">    ans = pRootOfTree;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ans.left = pRootOfTree;</span><br><span class="line">    pRootOfTree.right = ans;</span><br><span class="line">    ans = pRootOfTree;</span><br><span class="line">  &#125;</span><br><span class="line">  Convert(pRootOfTree.left);</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;26-二叉搜索树与双向链表&quot;&gt;&lt;a href=&quot;#26-二叉搜索树与双向链表&quot; class=&quot;headerlink&quot; title=&quot;26.二叉搜索树与双向链表&quot;&gt;&lt;/a&gt;26.二叉搜索树与双向链表&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; cla
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 25.复杂链表的复制</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2025.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html"/>
    <id>https://cheng102e.github.io/剑指offer 25.复杂链表的复制.html</id>
    <published>2020-03-01T04:00:00.000Z</published>
    <updated>2020-03-01T12:05:04.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>好繁琐一道题，用了三次遍历，赋值的时候用了三目运算符缩短代码。</p><ol><li>在每个节点后增加一个新节点，只有节点本身。</li><li>给每个新增节点增加random。</li><li>分开两个链表。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> public class RandomListNode &#123;</span><br><span class="line"></span><br><span class="line">  int label;</span><br><span class="line">  RandomListNode next = null;</span><br><span class="line">  RandomListNode random = null;</span><br><span class="line"></span><br><span class="line">  RandomListNode(int label) &#123;</span><br><span class="line">    this.label = label;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public RandomListNode Clone(RandomListNode pHead) &#123;</span><br><span class="line">  if (pHead == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  RandomListNode cur = pHead;</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">    RandomListNode nextnode = cur.next;</span><br><span class="line">    RandomListNode clone = new RandomListNode(cur.label);</span><br><span class="line">    cur.next = clone;</span><br><span class="line">    clone.next = nextnode;</span><br><span class="line">    cur = nextnode;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = pHead;</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">    cur.next.random = cur.random == null ? null : cur.random.next;</span><br><span class="line">    cur = cur.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = pHead;</span><br><span class="line">  RandomListNode newHead = pHead.next;</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">    RandomListNode clone = cur.next;</span><br><span class="line">    cur.next = clone.next;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    clone.next = clone.next == null ? null : clone.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;25-复杂链表的复制&quot;&gt;&lt;a href=&quot;#25-复杂链表的复制&quot; class=&quot;headerlink&quot; title=&quot;25.复杂链表的复制&quot;&gt;&lt;/a&gt;25.复杂链表的复制&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="https://cheng102e.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 23.二叉搜索树的后序遍历序列</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2023.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 23.二叉搜索树的后序遍历序列.html</id>
    <published>2020-02-29T10:00:00.000Z</published>
    <updated>2020-02-29T12:11:55.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树性质就是左子树小于根节点小于右节点，以最右侧为根，判断一下让数组左侧均小于根，根小于右侧，然后分成两块继续运算即可。<br>(我真的不知道为什么越界啊，我也不知道为什么突然就不越界了)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  public boolean vt(int[] sequence, int start, int end) &#123;</span><br><span class="line">  if (start&gt;=end) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  int root = sequence[end];</span><br><span class="line">  int mid = start;</span><br><span class="line">  for (; mid &lt; end; mid++) &#123;</span><br><span class="line">    if (root &lt; sequence[mid]) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = mid; i &lt; end; i++) &#123;</span><br><span class="line">    if (root &gt; sequence[i]) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  boolean left = true;</span><br><span class="line">  boolean right = true;</span><br><span class="line">  if (start &lt;= mid - 1) &#123;</span><br><span class="line">    left = vt(sequence, start, mid - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  if (mid &lt;= end - 1) &#123;</span><br><span class="line">    right = vt(sequence, mid, end - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return left &amp;&amp; right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean VerifySquenceOfBST(int[] sequence) &#123;</span><br><span class="line">  if (sequence == null || sequence.length == 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (sequence.length &lt; 3) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return vt(sequence, 0, sequence.length - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;23-二叉搜索树的后序遍历序列&quot;&gt;&lt;a href=&quot;#23-二叉搜索树的后序遍历序列&quot; class=&quot;headerlink&quot; title=&quot;23.二叉搜索树的后序遍历序列&quot;&gt;&lt;/a&gt;23.二叉搜索树的后序遍历序列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 24.二叉树中和为某一值的路径</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2024.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.html"/>
    <id>https://cheng102e.github.io/剑指offer 24.二叉树中和为某一值的路径.html</id>
    <published>2020-02-29T10:00:00.000Z</published>
    <updated>2020-03-01T03:59:24.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>路径问题就直接递归就行了，用一个list存储当前路径，如果成功就加入答案集，不成功就删除最后一个结点回溯。<br>这里还要用sort比较一下，Collections.sort(all, ((o1, o2) -&gt; o2.size() - o1.size()))，比较的时候就是降序排列。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void find(TreeNode root, int target, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; all, ArrayList list) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  int value = root.val;</span><br><span class="line">  list.add(value);</span><br><span class="line">  if (target == value &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">    all.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    find(root.left, target - value, all, list);</span><br><span class="line">    find(root.right, target - value, all, list);</span><br><span class="line">  &#125;</span><br><span class="line">  list.remove(list.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123;</span><br><span class="line">  ArrayList&lt;ArrayList&lt;Integer&gt;&gt; all = new ArrayList&lt;&gt;();</span><br><span class="line">  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">  find(root, target, all, list);</span><br><span class="line">  Collections.sort(all, ((o1, o2) -&gt; o2.size() - o1.size()));</span><br><span class="line">  return all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;24-二叉树中和为某一值的路径&quot;&gt;&lt;a href=&quot;#24-二叉树中和为某一值的路径&quot; class=&quot;headerlink&quot; title=&quot;24.二叉树中和为某一值的路径&quot;&gt;&lt;/a&gt;24.二叉树中和为某一值的路径&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 21.栈的压入、弹出序列</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2021.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 21.栈的压入、弹出序列.html</id>
    <published>2020-02-29T07:30:00.000Z</published>
    <updated>2020-02-29T08:29:03.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题思路倒是比较清晰，设置一个栈模拟进栈出栈过程，坑一点的就是边界问题，我本来是以出栈为循环条件的，边界越整越多，最后换了入栈为循环条件，简单了很多。<br>如果栈不为空且栈顶和出栈顺序一样，出栈，不然下一位。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean IsPopOrder(int[] pushA, int[] popA) &#123;</span><br><span class="line">  Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">  int len = pushA.length;</span><br><span class="line"></span><br><span class="line">  int in = 0, out = 0;</span><br><span class="line">  for (; in &lt; len; in++) &#123;</span><br><span class="line"></span><br><span class="line">    stack.push(pushA[in]);</span><br><span class="line"></span><br><span class="line">    while (!stack.empty() &amp;&amp; stack.peek() == popA[out]) &#123;</span><br><span class="line">      stack.pop();</span><br><span class="line">      out++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return stack.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-栈的压入、弹出序列&quot;&gt;&lt;a href=&quot;#21-栈的压入、弹出序列&quot; class=&quot;headerlink&quot; title=&quot;21.栈的压入、弹出序列&quot;&gt;&lt;/a&gt;21.栈的压入、弹出序列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 22.从上往下打印二叉树</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2022.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://cheng102e.github.io/剑指offer 22.从上往下打印二叉树.html</id>
    <published>2020-02-29T07:30:00.000Z</published>
    <updated>2020-02-29T09:09:49.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题就是简单的树的遍历，调节顺序就可以用队列来帮助存储，先把结点存放进队列，从队列头部取出节点，然后查看左子节点和右子节点，取出的时候记得保存值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">      return list;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">      TreeNode temp = queue.poll();</span><br><span class="line">      if (temp.left != null) &#123;</span><br><span class="line">        queue.offer(temp.left);</span><br><span class="line">      &#125;</span><br><span class="line">      if (temp.right != null) &#123;</span><br><span class="line">        queue.offer(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">      list.add(temp.val);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;22-从上往下打印二叉树&quot;&gt;&lt;a href=&quot;#22-从上往下打印二叉树&quot; class=&quot;headerlink&quot; title=&quot;22.从上往下打印二叉树&quot;&gt;&lt;/a&gt;22.从上往下打印二叉树&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 20.包含min函数的栈</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2020.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html"/>
    <id>https://cheng102e.github.io/剑指offer 20.包含min函数的栈.html</id>
    <published>2020-02-29T06:50:00.000Z</published>
    <updated>2020-02-29T07:33:55.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题给人的启发很深，可以增加一个新的栈专门来存储最小值，push的时候，第一个数据栈直接push，第二个最小值栈若为空或者顶端值大于node，都是直接加入node，如果不是，那么就把栈顶的数再次加入，最小值栈就用于存放最小值，插入值不为最小值就把最小值再次插入一遍确保两个栈相同长度。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stackdata = new Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stackmin = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void push(int node) &#123;</span><br><span class="line">  stackdata.push(node);</span><br><span class="line">  if (stackmin.empty()) &#123;</span><br><span class="line">    stackmin.push(node);</span><br><span class="line">  &#125; else if (node &lt; stackmin.peek()) &#123;</span><br><span class="line">    stackmin.push(node);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    stackmin.push(stackmin.peek());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pop() &#123;</span><br><span class="line">  stackmin.pop();</span><br><span class="line">  stackdata.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int top() &#123;</span><br><span class="line">  return stackdata.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int min() &#123;</span><br><span class="line">  return stackmin.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;20-包含min函数的栈&quot;&gt;&lt;a href=&quot;#20-包含min函数的栈&quot; class=&quot;headerlink&quot; title=&quot;20.包含min函数的栈&quot;&gt;&lt;/a&gt;20.包含min函数的栈&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 19.顺时针打印矩阵</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2019.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html"/>
    <id>https://cheng102e.github.io/剑指offer 19.顺时针打印矩阵.html</id>
    <published>2020-02-29T05:50:00.000Z</published>
    <updated>2020-02-29T05:56:07.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个。。我没找什么特别的方法，就用思路最清晰的方法，用循环来做，并且几个判断条件都要带=，不然结果会出错。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123;</span><br><span class="line">  ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">  int EndX = matrix.length - 1;</span><br><span class="line">  int EndY = matrix[0].length - 1;</span><br><span class="line">  int StartX = 0;</span><br><span class="line">  int StartY = 0;</span><br><span class="line">  int x = StartX, y = StartY;</span><br><span class="line">  while (StartX &lt;= EndX &amp;&amp; StartY &lt;= EndY) &#123;</span><br><span class="line">    if (StartX &lt;= EndX) &#123;</span><br><span class="line">      while (y &lt;= EndY) &#123;</span><br><span class="line">        list.add(matrix[x][y]);</span><br><span class="line">        y++;</span><br><span class="line">      &#125;</span><br><span class="line">      y--;</span><br><span class="line">      StartX++;</span><br><span class="line">      x = StartX;</span><br><span class="line">    &#125;</span><br><span class="line">    if (StartY &lt;= EndY) &#123;</span><br><span class="line">      while (x &lt;= EndX) &#123;</span><br><span class="line">        list.add(matrix[x][y]);</span><br><span class="line">        x++;</span><br><span class="line">      &#125;</span><br><span class="line">      x--;</span><br><span class="line">      EndY--;</span><br><span class="line">      y = EndY;</span><br><span class="line">    &#125;</span><br><span class="line">    if (StartX &lt;= EndX) &#123;</span><br><span class="line">      while (y &gt;= StartY) &#123;</span><br><span class="line">        list.add(matrix[x][y]);</span><br><span class="line">        y--;</span><br><span class="line">      &#125;</span><br><span class="line">      y++;</span><br><span class="line">      EndX--;</span><br><span class="line">      x = EndX;</span><br><span class="line">    &#125;</span><br><span class="line">    if (StartY &lt;= EndY) &#123;</span><br><span class="line">      while (x &gt;= StartX) &#123;</span><br><span class="line">        list.add(matrix[x][y]);</span><br><span class="line">        x--;</span><br><span class="line">      &#125;</span><br><span class="line">      x++;</span><br><span class="line">      StartY++;</span><br><span class="line">      y = StartY;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;19-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#19-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;19.顺时针打印矩阵&quot;&gt;&lt;/a&gt;19.顺时针打印矩阵&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 18.二叉树的镜像</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2018.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.html"/>
    <id>https://cheng102e.github.io/剑指offer 18.二叉树的镜像.html</id>
    <published>2020-02-29T05:00:00.000Z</published>
    <updated>2020-02-29T05:04:09.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目描述<br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树<br>            8<br>           /  <br>          6   10<br>         / \  / <br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           /  <br>          10   6<br>         / \  / <br>        11 9 7  5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>同样是递归，不过这题思路很清晰，如果根节点存在，直接交换左右节点，之后递归以左右节点为根，子节点的子节点左右交换，一层一层就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void Mirror(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    if (root.left != null) &#123;</span><br><span class="line">      Mirror(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null) &#123;</span><br><span class="line">      Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;18-二叉树的镜像&quot;&gt;&lt;a href=&quot;#18-二叉树的镜像&quot; class=&quot;headerlink&quot; title=&quot;18.二叉树的镜像&quot;&gt;&lt;/a&gt;18.二叉树的镜像&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 17.树的子结构</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2017.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.html"/>
    <id>https://cheng102e.github.io/剑指offer 17.树的子结构.html</id>
    <published>2020-02-29T04:26:00.000Z</published>
    <updated>2020-02-29T05:02:14.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题应该用递归的，关于树类型的题目递归的话思路会很清晰。<br>首先在A中寻找到B的根节点，找到之后就开始递归比较左子节点和右子节点是否相同，如果找到就返回true，不然的话就是false。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val = 0;</span><br><span class="line">  TreeNode left = null;</span><br><span class="line">  TreeNode right = null;</span><br><span class="line"></span><br><span class="line">  public TreeNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">  boolean result = false;</span><br><span class="line"></span><br><span class="line">  if (root1 != null &amp;&amp; root2 != null) &#123;</span><br><span class="line">    if (root1.val == root2.val) &#123;</span><br><span class="line">      result = Does1Has2(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!result) &#123;</span><br><span class="line">      result = HasSubtree(root1.left, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!result) &#123;</span><br><span class="line">      result = HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean Does1Has2(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">  if (root2 == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (root1 == null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (root1.val != root2.val) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return Does1Has2(root1.left, root2.left) &amp;&amp; Does1Has2(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;17-树的子结构&quot;&gt;&lt;a href=&quot;#17-树的子结构&quot; class=&quot;headerlink&quot; title=&quot;17.树的子结构&quot;&gt;&lt;/a&gt;17.树的子结构&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 16.合并两个排序的链表</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2016.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.html"/>
    <id>https://cheng102e.github.io/剑指offer 16.合并两个排序的链表.html</id>
    <published>2020-02-29T03:26:00.000Z</published>
    <updated>2020-02-29T03:45:42.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题以前也做过的，只需要新建一个表头，然后比较两边的大小，依次加入新的链表，最后再把没用上的加到结尾即可。<br>now代表当前节点，base代表头结点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next = null;</span><br><span class="line"></span><br><span class="line">  ListNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode Merge(ListNode list1, ListNode list2) &#123;</span><br><span class="line">  if (list1 == null) &#123;</span><br><span class="line">    return list2;</span><br><span class="line">  &#125;</span><br><span class="line">  if (list2 == null) &#123;</span><br><span class="line">    return list1;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode base = null;</span><br><span class="line">  ListNode now = null;</span><br><span class="line">  while (list1 != null &amp;&amp; list2 != null) &#123;</span><br><span class="line">    if (list1.val &lt;= list2.val) &#123;</span><br><span class="line">      if (base == null) &#123;</span><br><span class="line">        base = list1;</span><br><span class="line">        now = list1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        now.next = list1;</span><br><span class="line">        now = now.next;</span><br><span class="line">      &#125;</span><br><span class="line">      list1 = list1.next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (base == null) &#123;</span><br><span class="line">        base = list2;</span><br><span class="line">        now = list2;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        now.next = list2;</span><br><span class="line">        now = now.next;</span><br><span class="line">      &#125;</span><br><span class="line">      list2 = list2.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (list1 == null) &#123;</span><br><span class="line">    now.next = list2;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    now.next = list1;</span><br><span class="line">  &#125;</span><br><span class="line">  return base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;16-合并两个排序的链表&quot;&gt;&lt;a href=&quot;#16-合并两个排序的链表&quot; class=&quot;headerlink&quot; title=&quot;16.合并两个排序的链表&quot;&gt;&lt;/a&gt;16.合并两个排序的链表&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="https://cheng102e.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 15.反转链表</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2015.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html"/>
    <id>https://cheng102e.github.io/剑指offer 15.反转链表.html</id>
    <published>2020-02-28T03:26:00.000Z</published>
    <updated>2020-02-29T03:43:39.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>翻转链表并不是很难，只需要注意一下特殊情况，这里设置两个空节点存储前一个结点和后一个结点。<br>头结点为空直接结束，不为空就开始循环，假设链表为0-&gt;1，head=0，next=null，pre=null；然后next=1，head.next=null(最后一位没有子节点),pre=0,head=1;然后next=null，head.next=0，pre=1，head=null，跳出循环，头结点为pre(1)，结束。<br>最后返回的应该是pre不是head，因为原本尾结点现在是pre，多走了一步，head归为null了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next = null;</span><br><span class="line"></span><br><span class="line">  ListNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">  if (head == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode pre = null;</span><br><span class="line">  ListNode next = null;</span><br><span class="line">  while (head != null) &#123;</span><br><span class="line">    next = head.next;</span><br><span class="line">    head.next = pre;</span><br><span class="line">    pre = head;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;15-反转链表&quot;&gt;&lt;a href=&quot;#15-反转链表&quot; class=&quot;headerlink&quot; title=&quot;15.反转链表&quot;&gt;&lt;/a&gt;15.反转链表&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="https://cheng102e.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 14.链表中倒数第k个结点</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2014.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 14.链表中倒数第k个结点.html</id>
    <published>2020-02-28T02:50:00.000Z</published>
    <updated>2020-02-29T03:43:32.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14-链表中倒数第k个结点"><a href="#14-链表中倒数第k个结点" class="headerlink" title="14.链表中倒数第k个结点"></a>14.链表中倒数第k个结点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设原链表有n个结点，倒数第k个结点就是n-k+1个结点，那么这里可以设置两个结点，一个结点先走k-1步，是第k个结点，然后两个结点一起走，第一个结点再走n-k步就到达末尾，此时第二个结点也走了n-k步，到达了n-k+1个结点，就是所求的值。<br>这里有几点需要注意，就是k的范围，若k&lt;=0那么直接返回null，若链表为空那也返回null，若链表长度小于k一样返回null</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next = null;</span><br><span class="line"></span><br><span class="line">  ListNode(int val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode FindKthToTail(ListNode head, int k) &#123;</span><br><span class="line">  if (head == null || k &lt;= 0) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode ans = head;</span><br><span class="line">  for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">    if (head.next != null) &#123;</span><br><span class="line">      head = head.next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while (head.next != null) &#123;</span><br><span class="line">    head = head.next;</span><br><span class="line">    ans = ans.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;14-链表中倒数第k个结点&quot;&gt;&lt;a href=&quot;#14-链表中倒数第k个结点&quot; class=&quot;headerlink&quot; title=&quot;14.链表中倒数第k个结点&quot;&gt;&lt;/a&gt;14.链表中倒数第k个结点&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; cla
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="链表" scheme="https://cheng102e.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 13.调整数组顺序使奇数位于偶数前面</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2013.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html"/>
    <id>https://cheng102e.github.io/剑指offer 13.调整数组顺序使奇数位于偶数前面.html</id>
    <published>2020-02-28T02:17:00.000Z</published>
    <updated>2020-02-28T02:52:42.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用了空间换时间，确保相对位置，新建数组把奇数放前面偶数放后面，再赋值给原数组。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  public void reOrderArray(int[] array) &#123;</span><br><span class="line">  int[] newarray = new int[array.length];</span><br><span class="line">  int index = 0;</span><br><span class="line">  for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (array[i] % 2 == 1) &#123;</span><br><span class="line">      newarray[index] = array[i];</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (array[i] % 2 == 0) &#123;</span><br><span class="line">      newarray[index] = array[i];</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    array[i] = newarray[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;13-调整数组顺序使奇数位于偶数前面&quot;&gt;&lt;a href=&quot;#13-调整数组顺序使奇数位于偶数前面&quot; class=&quot;headerlink&quot; title=&quot;13.调整数组顺序使奇数位于偶数前面&quot;&gt;&lt;/a&gt;13.调整数组顺序使奇数位于偶数前面&lt;/h2&gt;&lt;h3 id=&quot;题
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 12.数值的整数次方</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2012.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 12.数值的整数次方.html</id>
    <published>2020-02-27T14:17:00.000Z</published>
    <updated>2020-02-28T02:41:50.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>问题也不是很大，如果不是要求效率就可以直接分类讨论，一个循环解决，要求效率的话就要用快速幂，我没用快速幂，就分类讨论了一下，最后输出结果。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">  if (exponent == 0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (base == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  double ans = 1;</span><br><span class="line">  boolean flag = false;</span><br><span class="line">  if (exponent &gt; 0) &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    flag = false;</span><br><span class="line">    exponent = -exponent;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 1; i &lt;= exponent; i++) &#123;</span><br><span class="line">    ans = ans * base;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!flag) &#123;</span><br><span class="line">    ans = 1.0 / ans;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;12-数值的整数次方&quot;&gt;&lt;a href=&quot;#12-数值的整数次方&quot; class=&quot;headerlink&quot; title=&quot;12.数值的整数次方&quot;&gt;&lt;/a&gt;12.数值的整数次方&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 213. House Robber II</title>
    <link href="https://cheng102e.github.io/LeetCode%20213.%20House%20Robber%20II.html"/>
    <id>https://cheng102e.github.io/LeetCode 213. House Robber II.html</id>
    <published>2020-02-27T10:23:00.000Z</published>
    <updated>2020-02-27T10:25:15.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="213-House-Robber-II（打家劫舍-II）"><a href="#213-House-Robber-II（打家劫舍-II）" class="headerlink" title="213. House Robber II（打家劫舍 II）"></a>213. House Robber II（打家劫舍 II）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/house-robber-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-ii</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。<br>示例 2:</p><p>输入: [1,2,3,1]<br>输出: 4<br>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划，对于第三间之后的房子，有拿或者不拿两种选择，如果选择拿，那么前一间房子就不能拿，这样可以得到状态转移方程dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])，还要考虑到一点就是，第一个和最后一个不能都拿，可以考虑设两个方程，第一个是1到n-1，第二个是2到n，选最大值即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">  int[] dp_0 = new int[nums.length];</span><br><span class="line">  int[] dp_1 = new int[nums.length];</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (nums.length == 1) &#123;</span><br><span class="line">    return nums[0];</span><br><span class="line">  &#125;</span><br><span class="line">  if (nums.length == 2) &#123;</span><br><span class="line">    return Math.max(nums[0], nums[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  dp_0[0] = nums[0];</span><br><span class="line">  dp_0[1] = Math.max(nums[0], nums[1]);</span><br><span class="line">  for (int i = 2; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">    dp_0[i] = Math.max(dp_0[i - 1], dp_0[i - 2] + nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  dp_1[1] = nums[1];</span><br><span class="line">  dp_1[2] = Math.max(nums[1], nums[2]);</span><br><span class="line">  for (int i = 3; i &lt; nums.length; i++) &#123;</span><br><span class="line">    dp_1[i] = Math.max(dp_1[i - 1], dp_1[i - 2] + nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(dp_0[nums.length - 2], dp_1[nums.length - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;213-House-Robber-II（打家劫舍-II）&quot;&gt;&lt;a href=&quot;#213-House-Robber-II（打家劫舍-II）&quot; class=&quot;headerlink&quot; title=&quot;213. House Robber II（打家劫舍 II）&quot;&gt;&lt;/a&gt;2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 11.二进制中1的个数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2011.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 11.二进制中1的个数.html</id>
    <published>2020-02-27T10:17:00.000Z</published>
    <updated>2020-02-28T02:41:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对我来说蛮难的，虽然解法有多种吧。<br>一开始想的就是直接转二进制字符串遍历，简单，但是这题本意应该是位运算，这方面我不是很熟。<br>把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。这句话是书上的，每次运算都把一个1变成0，当成为0的时候运算的次数就是1的数量。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">  int count = 0;</span><br><span class="line"></span><br><span class="line">  while (n != 0) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    n = (n - 1) &amp; n;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-二进制中1的个数&quot;&gt;&lt;a href=&quot;#11-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;11.二进制中1的个数&quot;&gt;&lt;/a&gt;11.二进制中1的个数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;head
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="位运算" scheme="https://cheng102e.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
</feed>
