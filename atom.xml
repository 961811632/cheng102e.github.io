<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-02-03T12:19:33.858Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 374. Guess Number Higher or Lower</title>
    <link href="https://cheng102e.github.io/LeetCode%20374.%20Guess%20Number%20Higher%20or%20Lower.html"/>
    <id>https://cheng102e.github.io/LeetCode 374. Guess Number Higher or Lower.html</id>
    <published>2020-02-03T12:19:00.000Z</published>
    <updated>2020-02-03T12:19:33.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="374-Guess-Number-Higher-or-Lower（猜数字大小）"><a href="#374-Guess-Number-Higher-or-Lower（猜数字大小）" class="headerlink" title="374. Guess Number Higher or Lower（猜数字大小）"></a>374. Guess Number Higher or Lower（猜数字大小）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower" target="_blank" rel="noopener">https://leetcode-cn.com/problems/guess-number-higher-or-lower</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：</p><p>-1 : 我的数字比较小<br> 1 : 我的数字比较大<br> 0 : 恭喜！你猜对了！<br>示例 :</p><p>  输入: n = 10, pick = 6<br>  输出: 6</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个也是二分查找，只不过又换了一种问法。<br>这里只需要注意到leftright的更新与guess函数的返回值即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int guessNumber(int n) &#123;</span><br><span class="line">  int left = 1;</span><br><span class="line">  int right = n;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (guess(mid) == 0) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (guess(mid) == 1) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (guess(mid) == -1) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;374-Guess-Number-Higher-or-Lower（猜数字大小）&quot;&gt;&lt;a href=&quot;#374-Guess-Number-Higher-or-Lower（猜数字大小）&quot; class=&quot;headerlink&quot; title=&quot;374. Guess Num
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 278. First Bad Version</title>
    <link href="https://cheng102e.github.io/LeetCode%20278.%20First%20Bad%20Version.html"/>
    <id>https://cheng102e.github.io/LeetCode 278. First Bad Version.html</id>
    <published>2020-02-03T12:09:00.000Z</published>
    <updated>2020-02-03T12:21:24.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="278-First-Bad-Version（第一个错误的版本）"><a href="#278-First-Bad-Version（第一个错误的版本）" class="headerlink" title="278. First Bad Version（第一个错误的版本）"></a>278. First Bad Version（第一个错误的版本）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/first-bad-version" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p>示例:</p><p>  给定 n = 5，并且 version = 4 是第一个错误的版本。</p><p>  调用 isBadVersion(3) -&gt; false<br>  调用 isBadVersion(5) -&gt; true<br>  调用 isBadVersion(4) -&gt; true</p><p>  所以，4 是第一个错误的版本。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个也是二分查找，问题相对来说不是很大，只需要注意几个细节即可，返回值为true表示版本错误，同时注意left和right的顺序，并且mid取值的时候要注意到不能溢出，最后返回left即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  public static int firstBadVersion(int n) &#123;</span><br><span class="line">  int left = 1;</span><br><span class="line">  int right = n;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (isBadVersion(mid) == true) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (isBadVersion(mid) == false) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;278-First-Bad-Version（第一个错误的版本）&quot;&gt;&lt;a href=&quot;#278-First-Bad-Version（第一个错误的版本）&quot; class=&quot;headerlink&quot; title=&quot;278. First Bad Version（第一个错误的版
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 35. Search Insert Position</title>
    <link href="https://cheng102e.github.io/LeetCode%2035.%20Search%20Insert%20Position.html"/>
    <id>https://cheng102e.github.io/LeetCode 35. Search Insert Position.html</id>
    <published>2020-02-03T05:09:00.000Z</published>
    <updated>2020-02-03T05:45:28.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="35-Search-Insert-Position（二分查找）"><a href="#35-Search-Insert-Position（二分查找）" class="headerlink" title="35. Search Insert Position（二分查找）"></a>35. Search Insert Position（二分查找）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><p>  输入: [1,3,5,6], 5<br>  输出: 2<br>示例 2:</p><p>  输入: [1,3,5,6], 2<br>  输出: 1<br>示例 3:</p><p>  输入: [1,3,5,6], 7<br>  输出: 4<br>示例 4:</p><p>  输入: [1,3,5,6], 0<br>  输出: 0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找加了一些别的东西，升序数组，找到返回下标，未找到就返回可以加入的位置.<br>代码和正常的二分查找相同，需要注意的是，最后一个返回的应该是left，因为在最后一次循环中，left=right，然后left++，这个位置，就是应该存放的位置。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  public static int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;35-Search-Insert-Position（二分查找）&quot;&gt;&lt;a href=&quot;#35-Search-Insert-Position（二分查找）&quot; class=&quot;headerlink&quot; title=&quot;35. Search Insert Position（二分查
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>查找算法-二分查找</title>
    <link href="https://cheng102e.github.io/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <id>https://cheng102e.github.io/查找算法-二分查找.html</id>
    <published>2020-02-03T05:00:00.000Z</published>
    <updated>2020-02-03T05:07:12.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找算法-二分查找"><a href="#查找算法-二分查找" class="headerlink" title="查找算法-二分查找"></a>查找算法-二分查找</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置两个标签，一个为left一个为right，分别表示左侧与右侧，常见初始值为0，length-1.<br>之后进行while循环，这里注意，判断条件选择left&lt;=right，这里当然可以改变，但是最好是熟练之后再进行改变。<br>循环中定义mid = (left + right) / 2，其实更好的是left+（right-left）/2；这样避免越界。<br>若找到了所需要的值，直接返回，找不到的话，就先判断nums[mid]与目标值的大小关系，重新确立leftright，进行下一步运算。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>O(log2n)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查找算法-二分查找&quot;&gt;&lt;a href=&quot;#查找算法-二分查找&quot; class=&quot;headerlink&quot; title=&quot;查找算法-二分查找&quot;&gt;&lt;/a&gt;查找算法-二分查找&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="算法" scheme="https://cheng102e.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://cheng102e.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 796. Rotate String</title>
    <link href="https://cheng102e.github.io/LeetCode%20796.%20Rotate%20String.html"/>
    <id>https://cheng102e.github.io/LeetCode 796. Rotate String.html</id>
    <published>2020-02-02T12:00:00.000Z</published>
    <updated>2020-02-02T13:18:03.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="796-Rotate-String（旋转字符串）"><a href="#796-Rotate-String（旋转字符串）" class="headerlink" title="796. Rotate String（旋转字符串）"></a>796. Rotate String（旋转字符串）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/rotate-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-string</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串, A 和 B。</p><p>A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = ‘abcde’，在移动一次之后结果就是’bcdea’ 。如果在若干次旋转操作之后，A 能变成B，那么返回True。</p><p>示例 1:<br>  输入: A = ‘abcde’, B = ‘cdeab’<br>  输出: true</p><p>示例 2:<br>  输入: A = ‘abcde’, B = ‘abced’<br>  输出: false<br>注意：</p><p>A 和 B 长度不超过 100。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目不是很难，但是好的思路可以大大减少所需时间。这里的思路是借鉴的，首先确保AB的长度相同，然后建立A+A，如果这里面包含B的话，就满足条件，因为A+A中随便截取等长的串都可能满足B的条件。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static boolean rotateString(String A, String B) &#123;</span><br><span class="line">    if (A.length() == B.length() &amp;&amp; ((A + A).contains(B))) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;796-Rotate-String（旋转字符串）&quot;&gt;&lt;a href=&quot;#796-Rotate-String（旋转字符串）&quot; class=&quot;headerlink&quot; title=&quot;796. Rotate String（旋转字符串）&quot;&gt;&lt;/a&gt;796. Rotate S
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 27. Remove Element</title>
    <link href="https://cheng102e.github.io/LeetCode%2027.%20Remove%20Element.html"/>
    <id>https://cheng102e.github.io/LeetCode 27. Remove Element.html</id>
    <published>2020-02-02T12:00:00.000Z</published>
    <updated>2020-02-02T13:17:58.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="27-Remove-Element（移除元素）"><a href="#27-Remove-Element（移除元素）" class="headerlink" title="27. Remove Element（移除元素）"></a>27. Remove Element（移除元素）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-element</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><p>  给定 nums = [3,2,2,3], val = 3,</p><p>  函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>  你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>  给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p><p>  函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>  注意这五个元素可为任意顺序。</p><p>  你不需要考虑数组中超出新长度后面的元素。<br>说明:</p><p>  为什么返回数值是整数，但输出的答案是数组呢?</p><p>  请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>  你可以想象内部操作如下:</p><p>  // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>  int len = removeElement(nums, val);</p><p>  // 在函数里修改输入数组对于调用者是可见的。<br>  // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>  for (int i = 0; i &lt; len; i++) {<br>      print(nums[i]);<br>  }</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目内容清晰，但是要求要用原地算法，不给额外空间，所以直接用双指针法，和前一题思路相同。<br>新建一个index，然后遍历数组，如果发现和val不相同，就存储进来，相同就无视，最后输出index即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int removeElement(int[] nums, int val) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      if (nums[i] != val) &#123;</span><br><span class="line">        nums[index]=nums[i];</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;27-Remove-Element（移除元素）&quot;&gt;&lt;a href=&quot;#27-Remove-Element（移除元素）&quot; class=&quot;headerlink&quot; title=&quot;27. Remove Element（移除元素）&quot;&gt;&lt;/a&gt;27. Remove Eleme
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 26. Remove Duplicates from Sorted Array</title>
    <link href="https://cheng102e.github.io/LeetCode%2026.%20Remove%20Duplicates%20from%20Sorted%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 26. Remove Duplicates from Sorted Array.html</id>
    <published>2020-02-02T11:59:00.000Z</published>
    <updated>2020-02-02T13:19:22.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="26-Remove-Duplicates-from-Sorted-Array（删除排序数组中的重复项）"><a href="#26-Remove-Duplicates-from-Sorted-Array（删除排序数组中的重复项）" class="headerlink" title="26. Remove Duplicates from Sorted Array（删除排序数组中的重复项）"></a>26. Remove Duplicates from Sorted Array（删除排序数组中的重复项）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><p>  给定数组 nums = [1,1,2], </p><p>  函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>  你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>  给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>  函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>  你不需要考虑数组中超出新长度后面的元素。<br>说明:</p><p>  为什么返回数值是整数，但输出的答案是数组呢?</p><p>  请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>  你可以想象内部操作如下:</p><p>  // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>  int len = removeDuplicates(nums);</p><p>  // 在函数里修改输入数组对于调用者是可见的。<br>  // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>  for (int i = 0; i &lt; len; i++) {<br>      print(nums[i]);<br>  }</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目内容清晰，但是要求要用原地算法，不给额外空间，所以直接用双指针法。<br>新建一个index，然后遍历数组，如果发现二者相同就跳过，不同的话，就在index的下一位更换，这里要注意index的变化顺序，最后输出index+1即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int removeDuplicates(int[] nums) &#123;</span><br><span class="line">  int index = 0;</span><br><span class="line">  for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    if (nums[i] != nums[index]) &#123;</span><br><span class="line">      index++;</span><br><span class="line">      nums[index] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return index+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;26-Remove-Duplicates-from-Sorted-Array（删除排序数组中的重复项）&quot;&gt;&lt;a href=&quot;#26-Remove-Duplicates-from-Sorted-Array（删除排序数组中的重复项）&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 704. Binary Search</title>
    <link href="https://cheng102e.github.io/LeetCode%20704.%20Binary%20Search.html"/>
    <id>https://cheng102e.github.io/LeetCode 704. Binary Search.html</id>
    <published>2020-02-02T10:00:00.000Z</published>
    <updated>2020-02-02T10:41:38.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="704-Binary-Search（二分查找）"><a href="#704-Binary-Search（二分查找）" class="headerlink" title="704. Binary Search（二分查找）"></a>704. Binary Search（二分查找）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>  输入: nums = [-1,0,3,5,9,12], target = 9<br>  输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p><p>  输入: nums = [-1,0,3,5,9,12], target = 2<br>  输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><p>提示：</p><p>  你可以假设 nums 中的所有元素是不重复的。<br>  n 将在 [1, 10000]之间。<br>  nums 的每个元素都将在 [-9999, 9999]之间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>标准的二分查找，升序数组，找到返回下标，未找到就返回-1.<br>首先如果长度为0，直接返回-11，之后确定左端右端，然后借助while循环进行，注意这里我用的是&lt;=判断，然后循环，如果得到答案返回下标，不然直接输出-1.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;704-Binary-Search（二分查找）&quot;&gt;&lt;a href=&quot;#704-Binary-Search（二分查找）&quot; class=&quot;headerlink&quot; title=&quot;704. Binary Search（二分查找）&quot;&gt;&lt;/a&gt;704. Binary Sear
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 961. N-Repeated Element in Size 2N Array</title>
    <link href="https://cheng102e.github.io/LeetCode%20961.%20N-Repeated%20Element%20in%20Size%202N%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 961. N-Repeated Element in Size 2N Array.html</id>
    <published>2020-02-02T02:00:00.000Z</published>
    <updated>2020-02-02T09:24:22.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="961-N-Repeated-Element-in-Size-2N-Array（重复-N-次的元素）"><a href="#961-N-Repeated-Element-in-Size-2N-Array（重复-N-次的元素）" class="headerlink" title="961. N-Repeated Element in Size 2N Array（重复 N 次的元素）"></a>961. N-Repeated Element in Size 2N Array（重复 N 次的元素）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。</p><p>返回重复了 N 次的那个元素。</p><p>示例 1：</p><p>  输入：[1,2,3,3]<br>  输出：3<br>示例 2：</p><p>  输入：[2,1,2,5,3,2]<br>  输出：2<br>示例 3：</p><p>  输入：[5,1,5,2,5,3,5,4]<br>  输出：5</p><p>提示：</p><p>  4 &lt;= A.length &lt;= 10000<br>  0 &lt;= A[i] &lt; 10000<br>  A.length 为偶数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题不是很难，就是想找到那个出现次数为N的数字，一共只有2N个数字，如果分布的最开的话，是每个数字之间都插一个数字，这样可以证明一定存在连续的三个数字，使那一个数字出现两次及以上。<br>所以只要从头到尾检查一下，若三个数字中出现两个相同数字，该数字即为所求解，不然就是最后一个数字。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int repeatedNTimes(int[] A) &#123;</span><br><span class="line">  int len = A.length;</span><br><span class="line">  for (int i = 0; i &lt; len - 2; i++) &#123;</span><br><span class="line">    if (A[i] == A[i + 1] || A[i] == A[i + 2]) &#123;</span><br><span class="line">      return A[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return A[len - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;961-N-Repeated-Element-in-Size-2N-Array（重复-N-次的元素）&quot;&gt;&lt;a href=&quot;#961-N-Repeated-Element-in-Size-2N-Array（重复-N-次的元素）&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1051. Height Checker</title>
    <link href="https://cheng102e.github.io/LeetCode%201051.%20Height%20Checker.html"/>
    <id>https://cheng102e.github.io/LeetCode 1051. Height Checker.html</id>
    <published>2020-02-01T14:30:00.000Z</published>
    <updated>2020-02-02T01:58:28.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1051-Height-Checker（高度检查器）"><a href="#1051-Height-Checker（高度检查器）" class="headerlink" title="1051. Height Checker（高度检查器）"></a>1051. Height Checker（高度检查器）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/height-checker" target="_blank" rel="noopener">https://leetcode-cn.com/problems/height-checker</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。</p><p>请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。</p><p>示例：</p><p>  输入：heights = [1,1,4,2,1,3]<br>  输出：3</p><p>提示：</p><p>  1 &lt;= heights.length &lt;= 100<br>  1 &lt;= heights[i] &lt;= 100</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不是很懂这题的意义，直接排序然后和原数组比较，每一个不同的就加一，直接输出即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int heightChecker(int[] heights) &#123;</span><br><span class="line">    int[] other = heights.clone();</span><br><span class="line">    Arrays.sort(other);</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; heights.length; i++) &#123;</span><br><span class="line">      if (other[i] != heights[i]) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1051-Height-Checker（高度检查器）&quot;&gt;&lt;a href=&quot;#1051-Height-Checker（高度检查器）&quot; class=&quot;headerlink&quot; title=&quot;1051. Height Checker（高度检查器）&quot;&gt;&lt;/a&gt;1051. H
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 67. Add Binary</title>
    <link href="https://cheng102e.github.io/LeetCode%2067.%20Add%20Binary.html"/>
    <id>https://cheng102e.github.io/LeetCode 67. Add Binary.html</id>
    <published>2020-01-31T04:50:00.000Z</published>
    <updated>2020-01-31T04:53:50.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="67-Add-Binary（二进制求和）"><a href="#67-Add-Binary（二进制求和）" class="headerlink" title="67. Add Binary（二进制求和）"></a>67. Add Binary（二进制求和）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/add-binary" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-binary</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为非空字符串且只包含数字 1 和 0。</p><p>示例 1:</p><p>  输入: a = “11”, b = “1”<br>  输出: “100”<br>示例 2:</p><p>  输入: a = “1010”, b = “1011”<br>  输出: “10101”</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>做起来比想象中麻烦不少，很多小细节需要注意。这里我直接用了一个StringBuilder来存储答案。<br>从后往前计算，num用于保存进位。若ab该位都存在，则二者加num为计算结果，num只有四种情况0123，01无进位，写入。23有进位，-2后写入，进位则置num为1否则为0，然后参与下一步运算。<br>如果ab都计算完了，num为1，则再产生进位，细节问题较多。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  public static String addBinary(String a, String b) &#123;</span><br><span class="line">  StringBuilder ans = new StringBuilder();</span><br><span class="line">  int len1 = a.length() - 1;</span><br><span class="line">  int len2 = b.length() - 1;</span><br><span class="line">  int num = 0;</span><br><span class="line">  while (len1 &gt;= 0 || len2 &gt;= 0) &#123;</span><br><span class="line">    if (len1 &gt;= 0) &#123;</span><br><span class="line">      num += a.charAt(len1) - &apos;0&apos;;</span><br><span class="line">      len1--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len2 &gt;= 0) &#123;</span><br><span class="line">      num += b.charAt(len2) - &apos;0&apos;;</span><br><span class="line">      len2--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num &lt; 2) &#123;</span><br><span class="line">      ans.insert(0, num);</span><br><span class="line">      num = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ans.insert(0, num - 2);</span><br><span class="line">      num = 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (num == 1) &#123;</span><br><span class="line">    ans.insert(0, 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;67-Add-Binary（二进制求和）&quot;&gt;&lt;a href=&quot;#67-Add-Binary（二进制求和）&quot; class=&quot;headerlink&quot; title=&quot;67. Add Binary（二进制求和）&quot;&gt;&lt;/a&gt;67. Add Binary（二进制求和）&lt;/h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 167. Two Sum II - Input array is sorted</title>
    <link href="https://cheng102e.github.io/LeetCode%20167.%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted.html"/>
    <id>https://cheng102e.github.io/LeetCode 167. Two Sum II - Input array is sorted.html</id>
    <published>2020-01-31T04:40:00.000Z</published>
    <updated>2020-01-31T04:47:34.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="167-Two-Sum-II-Input-array-is-sorted（两数之和-II-输入有序数组）"><a href="#167-Two-Sum-II-Input-array-is-sorted（两数之和-II-输入有序数组）" class="headerlink" title="167. Two Sum II - Input array is sorted（两数之和 II - 输入有序数组）"></a>167. Two Sum II - Input array is sorted（两数之和 II - 输入有序数组）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p><p>示例:</p><p>  输入: numbers = [2, 7, 11, 15], target = 9<br>  输出: [1,2]<br>  解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题我是直接双指针做的，由于是升序数组，且前一个一定小于后一个，就可以用两边向中间逼近的方法，若二者和小于答案，则前数向后一位，大于答案，后数向前一位，最后返回数组。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">  int start = 0;</span><br><span class="line">  int end = numbers.length - 1;</span><br><span class="line">  while (numbers[start] + numbers[end] != target) &#123;</span><br><span class="line"></span><br><span class="line">    if (numbers[start] + numbers[end] &lt; target) &#123;</span><br><span class="line">      start++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] res = new int[2];</span><br><span class="line">  res[0] = start + 1;</span><br><span class="line">  res[1] = end + 1;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;167-Two-Sum-II-Input-array-is-sorted（两数之和-II-输入有序数组）&quot;&gt;&lt;a href=&quot;#167-Two-Sum-II-Input-array-is-sorted（两数之和-II-输入有序数组）&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 189. Rotate Array</title>
    <link href="https://cheng102e.github.io/LeetCode%20189.%20Rotate%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 189. Rotate Array.html</id>
    <published>2020-01-31T04:30:00.000Z</published>
    <updated>2020-01-31T04:40:20.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="189-Rotate-Array（旋转数组）"><a href="#189-Rotate-Array（旋转数组）" class="headerlink" title="189. Rotate Array（旋转数组）"></a>189. Rotate Array（旋转数组）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/rotate-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>  输入: [1,2,3,4,5,6,7] 和 k = 3<br>  输出: [5,6,7,1,2,3,4]<br>  解释:<br>  向右旋转 1 步: [7,1,2,3,4,5,6]<br>  向右旋转 2 步: [6,7,1,2,3,4,5]<br>  向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p><p>  输入: [-1,-100,3,99] 和 k = 2<br>  输出: [3,99,-1,-100]<br>  解释:<br>  向右旋转 1 步: [99,-1,-100,3]<br>  向右旋转 2 步: [3,99,-1,-100]<br>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目思路清晰，但是考虑到复杂度，就麻烦了不少。<br>我选择的方法是以前在书上看到的，三次转置，第一次全体转置，第二次转置前k个，第三次转置剩余部分。<br>以例子1解释，1234567，转置全部之后是7654321.转置前三个，再转置后四个，就是5671234，符合条件。<br>由于所有数都转置了两次，所有对于前半部分和后半部分，相对位置是不变的，最开始直接倒序再转置k个，然后就是所需的k个在最前方。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void reverse(int[] nums, int start, int end) &#123;</span><br><span class="line">  while (start &lt; end) &#123;</span><br><span class="line">    int temp = nums[start];</span><br><span class="line">    nums[start] = nums[end];</span><br><span class="line">    nums[end] = temp;</span><br><span class="line">    start++;</span><br><span class="line">    end--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void rotate(int[] nums, int k) &#123;</span><br><span class="line">  int len = nums.length;</span><br><span class="line">  k = k % len;</span><br><span class="line">  reverse(nums, 0, len - 1);</span><br><span class="line">  reverse(nums, 0, k - 1);</span><br><span class="line">  reverse(nums, k, len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;189-Rotate-Array（旋转数组）&quot;&gt;&lt;a href=&quot;#189-Rotate-Array（旋转数组）&quot; class=&quot;headerlink&quot; title=&quot;189. Rotate Array（旋转数组）&quot;&gt;&lt;/a&gt;189. Rotate Array（旋
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 965. Univalued Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20965.%20Univalued%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 965. Univalued Binary Tree.html</id>
    <published>2020-01-30T11:38:00.000Z</published>
    <updated>2020-01-30T11:42:01.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="965-Univalued-Binary-Tree（单值二叉树）"><a href="#965-Univalued-Binary-Tree（单值二叉树）" class="headerlink" title="965. Univalued Binary Tree（单值二叉树）"></a>965. Univalued Binary Tree（单值二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/univalued-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/univalued-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</p><p>只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p><p>示例 1：</p><p>  输入：[1,1,1,1,1,null,1]<br>  输出：true<br>示例 2：</p><p>  输入：[2,2,2,5,2]<br>  输出：false</p><p>提示：</p><p>给定树的节点数范围是 [1, 100]。<br>每个节点的值都是整数，范围为 [0, 99] 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目不难，方法多种，我是选择直接对于每个结点进行一次判断，最后得到结果。也可以直接遍历，把所有的值存放到一个set当中，若set长度为1则成立。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(int x) &#123;</span><br><span class="line">      val = x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static boolean isUnivalTree(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left != null &amp;&amp; root.left.val != root.val) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null &amp;&amp; root.right.val != root.val) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isUnivalTree(root.left) &amp;&amp; isUnivalTree(root.right);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;965-Univalued-Binary-Tree（单值二叉树）&quot;&gt;&lt;a href=&quot;#965-Univalued-Binary-Tree（单值二叉树）&quot; class=&quot;headerlink&quot; title=&quot;965. Univalued Binary Tree（单
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 111. Minimum Depth of Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20111.%20Minimum%20Depth%20of%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 111. Minimum Depth of Binary Tree.html</id>
    <published>2020-01-30T11:30:00.000Z</published>
    <updated>2020-01-30T11:42:04.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="111-Minimum-Depth-of-Binary-Tree（二叉树的最小深度）"><a href="#111-Minimum-Depth-of-Binary-Tree（二叉树的最小深度）" class="headerlink" title="111. Minimum Depth of Binary Tree（二叉树的最小深度）"></a>111. Minimum Depth of Binary Tree（二叉树的最小深度）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最小深度  2.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树的问题，不过比起最大深度麻烦了不少。<br>首先还是空节点直接返回0；<br>如果左右两个子节点有一个为空，最大深度分别为a和b，那么空的那个就应该等于0，返回另外一个深度+0+1；<br>如果两个都不为空节点，那么返回二者中的较小值+1.<br>（这题我本来的代码对于[1,2]的结果为1，是错误的，之后参考了题解，才发现我对于题目的理解出了问题）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static int minDepth(TreeNode root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (root.left == null || root.right == null) &#123;</span><br><span class="line">    return minDepth(root.right) + minDepth(root.left) + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1 + Math.min(minDepth(root.left), minDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;111-Minimum-Depth-of-Binary-Tree（二叉树的最小深度）&quot;&gt;&lt;a href=&quot;#111-Minimum-Depth-of-Binary-Tree（二叉树的最小深度）&quot; class=&quot;headerlink&quot; title=&quot;111. Min
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 104. Maximum Depth of Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20104.%20Maximum%20Depth%20of%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 104. Maximum Depth of Binary Tree.html</id>
    <published>2020-01-30T11:18:00.000Z</published>
    <updated>2020-01-30T11:42:03.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）"><a href="#104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）" class="headerlink" title="104. Maximum Depth of Binary Tree（二叉树的最大深度）"></a>104. Maximum Depth of Binary Tree（二叉树的最大深度）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基础题，有多种方法，我选择的是简单的递归，若根为空，那么返回0，不然返回左右子树最大深度加一，然后就没了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static int maxDepth(TreeNode root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）&quot;&gt;&lt;a href=&quot;#104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）&quot; class=&quot;headerlink&quot; title=&quot;104. Max
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows下MySQL的安装与配置</title>
    <link href="https://cheng102e.github.io/Windows%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html"/>
    <id>https://cheng102e.github.io/Windows下MySQL的安装与配置.html</id>
    <published>2020-01-29T05:13:00.000Z</published>
    <updated>2020-01-29T08:07:09.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows下MySQL的安装与配置"><a href="#Windows下MySQL的安装与配置" class="headerlink" title="Windows下MySQL的安装与配置"></a>Windows下MySQL的安装与配置</h2><p>由于某些特殊原因，电脑上的mysql出了些问题，所以我就打算卸载重装一下，顺便记录一下流程。</p><h3 id="一、官网下载"><a href="#一、官网下载" class="headerlink" title="一、官网下载"></a>一、官网下载</h3><p>直接进入官网下载，下载地址<br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a><br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129132319045-720046442.png" alt><br>下载第一个即可。<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129135519941-1521318186.png" alt><br>（点击下面的No thanks，just start my download）<br>下载完成之后找个位置解压。<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129152848470-797821314.png" alt></p><h3 id="二、安装流程"><a href="#二、安装流程" class="headerlink" title="二、安装流程"></a>二、安装流程</h3><h4 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1.环境变量"></a>1.环境变量</h4><p><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129153132234-1469297161.png" alt><br>计算机中找到环境变量设置，增加环境变量，在path中增加<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129153333582-1845480771.png" alt></p><h4 id="2-新建文件"><a href="#2-新建文件" class="headerlink" title="2.新建文件"></a>2.新建文件</h4><p>在解压目录中新建data文件夹，和一个my.ini文件<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129153537506-398752680.png" alt><br>my.ini文件可以用txt改后缀，内容如下（只写了基础，有需要可以自行添加）</p><pre><code>[mysqld]# mysql根目录basedir = D:\mysql-5.7.29-winx64# 放所有数据库的data目录datadir = D:\mysql-5.7.29-winx64\data</code></pre><h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>这部分需要三条指令，先以管理员身份打开cmd，之后依次输入，初始化，安装，启动。</p><pre><code>mysqld --initialize --user=mysql --consolemysqld –install mysqlnet start mysql</code></pre><p>输入第一条指令后会生成随机密码，记得先保存，之后更改，毕竟这个贼难记。</p><p><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129154607378-1914546088.png" alt></p><h3 id="三、配置修改"><a href="#三、配置修改" class="headerlink" title="三、配置修改"></a>三、配置修改</h3><p>这里也没什么太多的，就把之前的初始密码修改下，有两种方法，一种是借助navicat等工具修改，一种是命令行修改，我采用的是命令行。</p><h4 id="1-登录"><a href="#1-登录" class="headerlink" title="1.登录"></a>1.登录</h4><p>输入登录命令</p><pre><code>mysql -uroot -p</code></pre><p>前面指root用户，后面指password密码，记得u和root是连在一起的，然后输入密码登录。<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129155433095-613026665.png" alt><br>直接输入指令</p><pre><code>set password for root@localhost = password(&apos;123456&apos;);</code></pre><p>将密码修改为123456，这里只是做例子，最好不要用这种密码2333333.<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129155836238-1490075615.png" alt><br>修改成功，可以开始使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows下MySQL的安装与配置&quot;&gt;&lt;a href=&quot;#Windows下MySQL的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Windows下MySQL的安装与配置&quot;&gt;&lt;/a&gt;Windows下MySQL的安装与配置&lt;/h2&gt;&lt;p&gt;由于
      
    
    </summary>
    
      <category term="数据库" scheme="https://cheng102e.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="工具安装" scheme="https://cheng102e.github.io/tags/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 58. Length of Last Word</title>
    <link href="https://cheng102e.github.io/LeetCode%2058.%20Length%20of%20Last%20Word.html"/>
    <id>https://cheng102e.github.io/LeetCode 58. Length of Last Word.html</id>
    <published>2020-01-28T07:08:00.000Z</published>
    <updated>2020-01-28T07:14:01.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="58-Length-of-Last-Word（最后一个单词的长度）"><a href="#58-Length-of-Last-Word（最后一个单词的长度）" class="headerlink" title="58. Length of Last Word（最后一个单词的长度）"></a>58. Length of Last Word（最后一个单词的长度）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/length-of-last-word" target="_blank" rel="noopener">https://leetcode-cn.com/problems/length-of-last-word</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。</p><p>如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p><p>如果不存在最后一个单词，请返回 0 。</p><p>说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。</p><p>示例:</p><p>  输入: “Hello World”<br>  输出: 5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>字符串题，只要注意到几处细节就不难。<br>我是从最后一位开始的，若最后一位为空格，则提前，提前到非空处，之后再按位查找，直到找到空格或者到字符串的开头为止。在按位查找的过程中增加一个num用于计数，最后输出num即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLastWord(String s) &#123;</span><br><span class="line">    if (s.length() &lt; 1) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int end = s.length() - 1;</span><br><span class="line">    while (end &gt;= 0 &amp;&amp; s.charAt(end) == &apos; &apos;) &#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (end &lt; 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int num = 0;</span><br><span class="line">    while (end &gt;= 0 &amp;&amp; s.charAt(end) != &apos; &apos;) &#123;</span><br><span class="line">      end--;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;58-Length-of-Last-Word（最后一个单词的长度）&quot;&gt;&lt;a href=&quot;#58-Length-of-Last-Word（最后一个单词的长度）&quot; class=&quot;headerlink&quot; title=&quot;58. Length of Last Word（最后
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 41. First Missing Positive</title>
    <link href="https://cheng102e.github.io/LeetCode%2041.%20First%20Missing%20Positive.html"/>
    <id>https://cheng102e.github.io/LeetCode 41. First Missing Positive.html</id>
    <published>2020-01-10T13:14:00.000Z</published>
    <updated>2020-01-28T07:05:17.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41-First-Missing-Positive（缺失的第一个正数）"><a href="#41-First-Missing-Positive（缺失的第一个正数）" class="headerlink" title="41. First Missing Positive（缺失的第一个正数）"></a>41. First Missing Positive（缺失的第一个正数）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-missing-positive</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><p>  输入: [1,2,0]<br>  输出: 3<br>示例 2:</p><p>  输入: [3,4,-1,1]<br>  输出: 2<br>示例 3:</p><p>  输入: [7,8,9,11,12]<br>  输出: 1<br>说明:</p><p>  你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较难的一类数组题目，对于复杂度和空间都有要求，结果就需要多考虑很多东西。<br>首先先设置长度为len，那么优先考虑为1-len范围的数字，每次优先把这些数字放在应该放的位置上swap(nums, i, nums[i] - 1)，之后对于数组进行遍历，如果该位置上的数字不符合条件，那么直接返回该位置应该有的数（数组号+1），如果遍历完了，那么就应该是数组长度+1.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static void swap(int nums[], int a, int b) &#123;</span><br><span class="line">    int c = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">      return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[i] != nums[nums[i] - 1]) &#123;</span><br><span class="line">        swap(nums, i, nums[i] - 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      if (nums[i] != i + 1) &#123;</span><br><span class="line">        return i + 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length + 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;41-First-Missing-Positive（缺失的第一个正数）&quot;&gt;&lt;a href=&quot;#41-First-Missing-Positive（缺失的第一个正数）&quot; class=&quot;headerlink&quot; title=&quot;41. First Missing Posi
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 283. Move Zeroes</title>
    <link href="https://cheng102e.github.io/LeetCode%20283.%20Move%20Zeroes.html"/>
    <id>https://cheng102e.github.io/LeetCode 283. Move Zeroes.html</id>
    <published>2020-01-08T14:14:00.000Z</published>
    <updated>2020-01-08T14:37:13.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="283-Move-Zeroes（移动零）"><a href="#283-Move-Zeroes（移动零）" class="headerlink" title="283. Move Zeroes（移动零）"></a>283. Move Zeroes（移动零）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><p>  输入: [0,1,0,3,12]<br>  输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>数组操作题，只要思路清晰，难度并不是很大。设置index作为标签，从数组头部开始遍历，index用于标记新数组最后不为0的数字，若不为0，就放入index中，index+1，直到结尾，然后把后面的数字置为0即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void moveZeroes(int[] nums) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      if (nums[i] != 0) &#123;</span><br><span class="line">        nums[index] = nums[i];</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    for (; index &lt; nums.length; index++) &#123;</span><br><span class="line">      nums[index] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;283-Move-Zeroes（移动零）&quot;&gt;&lt;a href=&quot;#283-Move-Zeroes（移动零）&quot; class=&quot;headerlink&quot; title=&quot;283. Move Zeroes（移动零）&quot;&gt;&lt;/a&gt;283. Move Zeroes（移动零）&lt;/h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
</feed>
