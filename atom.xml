<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-01-30T11:42:01.900Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 965. Univalued Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20965.%20Univalued%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 965. Univalued Binary Tree.html</id>
    <published>2020-01-30T11:38:00.000Z</published>
    <updated>2020-01-30T11:42:01.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="965-Univalued-Binary-Tree（单值二叉树）"><a href="#965-Univalued-Binary-Tree（单值二叉树）" class="headerlink" title="965. Univalued Binary Tree（单值二叉树）"></a>965. Univalued Binary Tree（单值二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/univalued-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/univalued-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</p><p>只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p><p>示例 1：</p><p>  输入：[1,1,1,1,1,null,1]<br>  输出：true<br>示例 2：</p><p>  输入：[2,2,2,5,2]<br>  输出：false</p><p>提示：</p><p>给定树的节点数范围是 [1, 100]。<br>每个节点的值都是整数，范围为 [0, 99] 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目不难，方法多种，我是选择直接对于每个结点进行一次判断，最后得到结果。也可以直接遍历，把所有的值存放到一个set当中，若set长度为1则成立。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(int x) &#123;</span><br><span class="line">      val = x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static boolean isUnivalTree(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left != null &amp;&amp; root.left.val != root.val) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null &amp;&amp; root.right.val != root.val) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isUnivalTree(root.left) &amp;&amp; isUnivalTree(root.right);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;965-Univalued-Binary-Tree（单值二叉树）&quot;&gt;&lt;a href=&quot;#965-Univalued-Binary-Tree（单值二叉树）&quot; class=&quot;headerlink&quot; title=&quot;965. Univalued Binary Tree（单
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 111. Minimum Depth of Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20111.%20Minimum%20Depth%20of%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 111. Minimum Depth of Binary Tree.html</id>
    <published>2020-01-30T11:30:00.000Z</published>
    <updated>2020-01-30T11:42:04.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="111-Minimum-Depth-of-Binary-Tree（二叉树的最小深度）"><a href="#111-Minimum-Depth-of-Binary-Tree（二叉树的最小深度）" class="headerlink" title="111. Minimum Depth of Binary Tree（二叉树的最小深度）"></a>111. Minimum Depth of Binary Tree（二叉树的最小深度）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最小深度  2.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树的问题，不过比起最大深度麻烦了不少。<br>首先还是空节点直接返回0；<br>如果左右两个子节点有一个为空，最大深度分别为a和b，那么空的那个就应该等于0，返回另外一个深度+0+1；<br>如果两个都不为空节点，那么返回二者中的较小值+1.<br>（这题我本来的代码对于[1,2]的结果为1，是错误的，之后参考了题解，才发现我对于题目的理解出了问题）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static int minDepth(TreeNode root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (root.left == null || root.right == null) &#123;</span><br><span class="line">    return minDepth(root.right) + minDepth(root.left) + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1 + Math.min(minDepth(root.left), minDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;111-Minimum-Depth-of-Binary-Tree（二叉树的最小深度）&quot;&gt;&lt;a href=&quot;#111-Minimum-Depth-of-Binary-Tree（二叉树的最小深度）&quot; class=&quot;headerlink&quot; title=&quot;111. Min
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 104. Maximum Depth of Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20104.%20Maximum%20Depth%20of%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 104. Maximum Depth of Binary Tree.html</id>
    <published>2020-01-30T11:18:00.000Z</published>
    <updated>2020-01-30T11:42:03.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）"><a href="#104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）" class="headerlink" title="104. Maximum Depth of Binary Tree（二叉树的最大深度）"></a>104. Maximum Depth of Binary Tree（二叉树的最大深度）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基础题，有多种方法，我选择的是简单的递归，若根为空，那么返回0，不然返回左右子树最大深度加一，然后就没了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static int maxDepth(TreeNode root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）&quot;&gt;&lt;a href=&quot;#104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）&quot; class=&quot;headerlink&quot; title=&quot;104. Max
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows下MySQL的安装与配置</title>
    <link href="https://cheng102e.github.io/Windows%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html"/>
    <id>https://cheng102e.github.io/Windows下MySQL的安装与配置.html</id>
    <published>2020-01-29T05:13:00.000Z</published>
    <updated>2020-01-29T08:07:09.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows下MySQL的安装与配置"><a href="#Windows下MySQL的安装与配置" class="headerlink" title="Windows下MySQL的安装与配置"></a>Windows下MySQL的安装与配置</h2><p>由于某些特殊原因，电脑上的mysql出了些问题，所以我就打算卸载重装一下，顺便记录一下流程。</p><h3 id="一、官网下载"><a href="#一、官网下载" class="headerlink" title="一、官网下载"></a>一、官网下载</h3><p>直接进入官网下载，下载地址<br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a><br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129132319045-720046442.png" alt><br>下载第一个即可。<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129135519941-1521318186.png" alt><br>（点击下面的No thanks，just start my download）<br>下载完成之后找个位置解压。<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129152848470-797821314.png" alt></p><h3 id="二、安装流程"><a href="#二、安装流程" class="headerlink" title="二、安装流程"></a>二、安装流程</h3><h4 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1.环境变量"></a>1.环境变量</h4><p><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129153132234-1469297161.png" alt><br>计算机中找到环境变量设置，增加环境变量，在path中增加<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129153333582-1845480771.png" alt></p><h4 id="2-新建文件"><a href="#2-新建文件" class="headerlink" title="2.新建文件"></a>2.新建文件</h4><p>在解压目录中新建data文件夹，和一个my.ini文件<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129153537506-398752680.png" alt><br>my.ini文件可以用txt改后缀，内容如下（只写了基础，有需要可以自行添加）</p><pre><code>[mysqld]# mysql根目录basedir = D:\mysql-5.7.29-winx64# 放所有数据库的data目录datadir = D:\mysql-5.7.29-winx64\data</code></pre><h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>这部分需要三条指令，先以管理员身份打开cmd，之后依次输入，初始化，安装，启动。</p><pre><code>mysqld --initialize --user=mysql --consolemysqld –install mysqlnet start mysql</code></pre><p>输入第一条指令后会生成随机密码，记得先保存，之后更改，毕竟这个贼难记。</p><p><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129154607378-1914546088.png" alt></p><h3 id="三、配置修改"><a href="#三、配置修改" class="headerlink" title="三、配置修改"></a>三、配置修改</h3><p>这里也没什么太多的，就把之前的初始密码修改下，有两种方法，一种是借助navicat等工具修改，一种是命令行修改，我采用的是命令行。</p><h4 id="1-登录"><a href="#1-登录" class="headerlink" title="1.登录"></a>1.登录</h4><p>输入登录命令</p><pre><code>mysql -uroot -p</code></pre><p>前面指root用户，后面指password密码，记得u和root是连在一起的，然后输入密码登录。<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129155433095-613026665.png" alt><br>直接输入指令</p><pre><code>set password for root@localhost = password(&apos;123456&apos;);</code></pre><p>将密码修改为123456，这里只是做例子，最好不要用这种密码2333333.<br><img src="https://img2018.cnblogs.com/blog/1493464/202001/1493464-20200129155836238-1490075615.png" alt><br>修改成功，可以开始使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows下MySQL的安装与配置&quot;&gt;&lt;a href=&quot;#Windows下MySQL的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Windows下MySQL的安装与配置&quot;&gt;&lt;/a&gt;Windows下MySQL的安装与配置&lt;/h2&gt;&lt;p&gt;由于
      
    
    </summary>
    
      <category term="数据库" scheme="https://cheng102e.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="工具安装" scheme="https://cheng102e.github.io/tags/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 58. Length of Last Word</title>
    <link href="https://cheng102e.github.io/LeetCode%2058.%20Length%20of%20Last%20Word.html"/>
    <id>https://cheng102e.github.io/LeetCode 58. Length of Last Word.html</id>
    <published>2020-01-28T07:08:00.000Z</published>
    <updated>2020-01-28T07:14:01.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="58-Length-of-Last-Word（最后一个单词的长度）"><a href="#58-Length-of-Last-Word（最后一个单词的长度）" class="headerlink" title="58. Length of Last Word（最后一个单词的长度）"></a>58. Length of Last Word（最后一个单词的长度）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/length-of-last-word" target="_blank" rel="noopener">https://leetcode-cn.com/problems/length-of-last-word</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。</p><p>如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p><p>如果不存在最后一个单词，请返回 0 。</p><p>说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。</p><p>示例:</p><p>  输入: “Hello World”<br>  输出: 5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>字符串题，只要注意到几处细节就不难。<br>我是从最后一位开始的，若最后一位为空格，则提前，提前到非空处，之后再按位查找，直到找到空格或者到字符串的开头为止。在按位查找的过程中增加一个num用于计数，最后输出num即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLastWord(String s) &#123;</span><br><span class="line">    if (s.length() &lt; 1) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int end = s.length() - 1;</span><br><span class="line">    while (end &gt;= 0 &amp;&amp; s.charAt(end) == &apos; &apos;) &#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (end &lt; 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int num = 0;</span><br><span class="line">    while (end &gt;= 0 &amp;&amp; s.charAt(end) != &apos; &apos;) &#123;</span><br><span class="line">      end--;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;58-Length-of-Last-Word（最后一个单词的长度）&quot;&gt;&lt;a href=&quot;#58-Length-of-Last-Word（最后一个单词的长度）&quot; class=&quot;headerlink&quot; title=&quot;58. Length of Last Word（最后
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 41. First Missing Positive</title>
    <link href="https://cheng102e.github.io/LeetCode%2041.%20First%20Missing%20Positive.html"/>
    <id>https://cheng102e.github.io/LeetCode 41. First Missing Positive.html</id>
    <published>2020-01-10T13:14:00.000Z</published>
    <updated>2020-01-28T07:05:17.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41-First-Missing-Positive（缺失的第一个正数）"><a href="#41-First-Missing-Positive（缺失的第一个正数）" class="headerlink" title="41. First Missing Positive（缺失的第一个正数）"></a>41. First Missing Positive（缺失的第一个正数）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-missing-positive</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><p>  输入: [1,2,0]<br>  输出: 3<br>示例 2:</p><p>  输入: [3,4,-1,1]<br>  输出: 2<br>示例 3:</p><p>  输入: [7,8,9,11,12]<br>  输出: 1<br>说明:</p><p>  你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较难的一类数组题目，对于复杂度和空间都有要求，结果就需要多考虑很多东西。<br>首先先设置长度为len，那么优先考虑为1-len范围的数字，每次优先把这些数字放在应该放的位置上swap(nums, i, nums[i] - 1)，之后对于数组进行遍历，如果该位置上的数字不符合条件，那么直接返回该位置应该有的数（数组号+1），如果遍历完了，那么就应该是数组长度+1.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static void swap(int nums[], int a, int b) &#123;</span><br><span class="line">    int c = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">      return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[i] != nums[nums[i] - 1]) &#123;</span><br><span class="line">        swap(nums, i, nums[i] - 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      if (nums[i] != i + 1) &#123;</span><br><span class="line">        return i + 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length + 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;41-First-Missing-Positive（缺失的第一个正数）&quot;&gt;&lt;a href=&quot;#41-First-Missing-Positive（缺失的第一个正数）&quot; class=&quot;headerlink&quot; title=&quot;41. First Missing Posi
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 283. Move Zeroes</title>
    <link href="https://cheng102e.github.io/LeetCode%20283.%20Move%20Zeroes.html"/>
    <id>https://cheng102e.github.io/LeetCode 283. Move Zeroes.html</id>
    <published>2020-01-08T14:14:00.000Z</published>
    <updated>2020-01-08T14:37:13.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="283-Move-Zeroes（移动零）"><a href="#283-Move-Zeroes（移动零）" class="headerlink" title="283. Move Zeroes（移动零）"></a>283. Move Zeroes（移动零）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><p>  输入: [0,1,0,3,12]<br>  输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>数组操作题，只要思路清晰，难度并不是很大。设置index作为标签，从数组头部开始遍历，index用于标记新数组最后不为0的数字，若不为0，就放入index中，index+1，直到结尾，然后把后面的数字置为0即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void moveZeroes(int[] nums) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      if (nums[i] != 0) &#123;</span><br><span class="line">        nums[index] = nums[i];</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    for (; index &lt; nums.length; index++) &#123;</span><br><span class="line">      nums[index] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;283-Move-Zeroes（移动零）&quot;&gt;&lt;a href=&quot;#283-Move-Zeroes（移动零）&quot; class=&quot;headerlink&quot; title=&quot;283. Move Zeroes（移动零）&quot;&gt;&lt;/a&gt;283. Move Zeroes（移动零）&lt;/h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 100. Same Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20100.%20Same%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 100. Same Tree.html</id>
    <published>2020-01-07T13:01:00.000Z</published>
    <updated>2020-01-07T14:10:43.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="100-Same-Tree（相同的树）"><a href="#100-Same-Tree（相同的树）" class="headerlink" title="100. Same Tree（相同的树）"></a>100. Same Tree（相同的树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/same-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><p>  输入:       1         1<br>            / \       / <br>          2   3     2   3</p><pre><code>[1,2,3],   [1,2,3]</code></pre><p>  输出: true<br>示例 2:</p><p>  输入:      1          1<br>            /           <br>          2             2</p><pre><code>[1,2],     [1,null,2]</code></pre><p>  输出: false<br>示例 3:</p><p>  输入:       1         1<br>            / \       / <br>          2   1     1   2</p><pre><code>[1,2,1],   [1,1,2]</code></pre><p>  输出: false</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历呗，先查看是否为空，都为空相同，之后同时比较左结点和右结点，没啥了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">  if (p == null &amp;&amp; q == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (p != null &amp;&amp; q != null &amp;&amp; p.val == q.val) &#123;</span><br><span class="line">    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;100-Same-Tree（相同的树）&quot;&gt;&lt;a href=&quot;#100-Same-Tree（相同的树）&quot; class=&quot;headerlink&quot; title=&quot;100. Same Tree（相同的树）&quot;&gt;&lt;/a&gt;100. Same Tree（相同的树）&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="树" scheme="https://cheng102e.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 264. Ugly Number II</title>
    <link href="https://cheng102e.github.io/LeetCode%20264.%20Ugly%20Number%20II.html"/>
    <id>https://cheng102e.github.io/LeetCode 264. Ugly Number II.html</id>
    <published>2020-01-05T03:01:00.000Z</published>
    <updated>2020-01-07T14:10:46.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="264-Ugly-Number-II（丑数-II）"><a href="#264-Ugly-Number-II（丑数-II）" class="headerlink" title="264. Ugly Number II（丑数 II）"></a>264. Ugly Number II（丑数 II）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/ugly-number-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ugly-number-ii</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个程序，找出第 n 个丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>示例:</p><p>  输入: n = 10<br>  输出: 12<br>  解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p><p>  1 是丑数。<br>  n 不超过1690。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比上一题带劲，本来打算打表打个卡的，结果发现了一个三指针法，效果很好。<br>任意丑数都是比这个数小的丑数乘以2，3，5其中之一得到的，要求按照顺序排列，那么就从之前的数中找到未被使用过的数乘一下，然后比较，就可以得到新的数了。<br>首先初始位为1，设三个指针值n2,n3,n5,初始设为0.之后开始循环，每次循环都找到235未乘过的数字乘一下，然后取最小值为新的丑数。之后，若n2n3n5使用过了，那么指针位+1，下次乘下一个数字，如果都可以，那就都加。把数字记录下来最后输出即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int nthUglyNumber(int n) &#123;</span><br><span class="line">    int[] ans = new int[n];</span><br><span class="line">    int n2 = 0, n3 = 0, n5 = 0;</span><br><span class="line">    ans[0] = 1;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">      int min = Math.min(ans[n2] * 2, Math.min(ans[n3] * 3, ans[n5] * 5));</span><br><span class="line">      ans[i] = min;</span><br><span class="line">      if (min == ans[n2]*2) &#123;</span><br><span class="line">        n2++;</span><br><span class="line">      &#125;</span><br><span class="line">      if (min == ans[n3]*3) &#123;</span><br><span class="line">        n3++;</span><br><span class="line">      &#125;</span><br><span class="line">      if (min == ans[n5]*5) &#123;</span><br><span class="line">        n5++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return ans[n-1];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;264-Ugly-Number-II（丑数-II）&quot;&gt;&lt;a href=&quot;#264-Ugly-Number-II（丑数-II）&quot; class=&quot;headerlink&quot; title=&quot;264. Ugly Number II（丑数 II）&quot;&gt;&lt;/a&gt;264. Ugly 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 231. Power of Two</title>
    <link href="https://cheng102e.github.io/LeetCode%20231.%20Power%20of%20Two.html"/>
    <id>https://cheng102e.github.io/LeetCode 231. Power of Two.html</id>
    <published>2020-01-04T06:34:00.000Z</published>
    <updated>2020-01-04T06:51:18.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="231-Power-of-Two（2的幂）"><a href="#231-Power-of-Two（2的幂）" class="headerlink" title="231. Power of Two（2的幂）"></a>231. Power of Two（2的幂）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/power-of-two" target="_blank" rel="noopener">https://leetcode-cn.com/problems/power-of-two</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p>示例 1:</p><p>  输入: 1<br>  输出: true<br>  解释: 20 = 1<br>示例 2:</p><p>  输入: 16<br>  输出: true<br>  解释: 24 = 16<br>示例 3:</p><p>  输入: 218<br>  输出: false</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>位运算，算是做之前不知道咋做，做了后就熟了的题目，代码也都简单，有两个式子。<br>先得知，若为二的幂，转换为二进制之后只有一位数字是1，别的数字都是0.</p><ol><li><p>(n &gt; 0) &amp;&amp; ((n &amp; -n) == n)<br>负数补码的存放是取反加一，假设为8，整数为1000，负数-8，为0111+0001=1000(取反加一)，二者&amp;运算，结果为1000，还是8.</p></li><li><p>(n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0)<br>同样用8举例，n-1=7为0111，二者&amp;运算，结果为0.</p></li></ol><p>两个式子的运算耗时差距也不是很大，看能想起来哪个吧，主要就是记得二进制是特殊的，适合位运算就行。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isPowerOfTwo(int n) &#123;</span><br><span class="line">    return (n &gt; 0) &amp;&amp; ((n &amp; -n) == n);</span><br><span class="line">  //  return (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;231-Power-of-Two（2的幂）&quot;&gt;&lt;a href=&quot;#231-Power-of-Two（2的幂）&quot; class=&quot;headerlink&quot; title=&quot;231. Power of Two（2的幂）&quot;&gt;&lt;/a&gt;231. Power of Two（2的幂）
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="位运算" scheme="https://cheng102e.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 263. Ugly Number</title>
    <link href="https://cheng102e.github.io/LeetCode%20263.%20Ugly%20Number.html"/>
    <id>https://cheng102e.github.io/LeetCode 263. Ugly Number.html</id>
    <published>2020-01-04T06:14:00.000Z</published>
    <updated>2020-01-04T06:16:31.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="263-Ugly-Number（丑数）"><a href="#263-Ugly-Number（丑数）" class="headerlink" title="263. Ugly Number（丑数）"></a>263. Ugly Number（丑数）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/ugly-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ugly-number</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>示例 1:</p><p>  输入: 6<br>  输出: true<br>  解释: 6 = 2 × 3<br>示例 2:</p><p>  输入: 8<br>  输出: true<br>  解释: 8 = 2 × 2 × 2<br>示例 3:</p><p>  输入: 14<br>  输出: false<br>  解释: 14 不是丑数，因为它包含了另外一个质因数 7。<br>说明：</p><p>  1 是丑数。<br>  输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单的定义题，整除方法，特殊值1，直接if判断1，while判断整除，最后输出结果。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isUgly(int num) &#123;</span><br><span class="line">    if (num &lt; 1) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    while (num % 5 == 0) &#123;</span><br><span class="line">      num = num / 5;</span><br><span class="line">    &#125;</span><br><span class="line">    while (num % 3 == 0) &#123;</span><br><span class="line">      num = num / 3;</span><br><span class="line">    &#125;</span><br><span class="line">    while (num % 2 == 0) &#123;</span><br><span class="line">      num = num / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return num == 1;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;263-Ugly-Number（丑数）&quot;&gt;&lt;a href=&quot;#263-Ugly-Number（丑数）&quot; class=&quot;headerlink&quot; title=&quot;263. Ugly Number（丑数）&quot;&gt;&lt;/a&gt;263. Ugly Number（丑数）&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 136. Single Number</title>
    <link href="https://cheng102e.github.io/LeetCode%20136.%20Single%20Number.html"/>
    <id>https://cheng102e.github.io/LeetCode 136. Single Number.html</id>
    <published>2020-01-04T02:22:00.000Z</published>
    <updated>2020-01-04T03:59:24.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="136-Single-Number（只出现一次的数字）"><a href="#136-Single-Number（只出现一次的数字）" class="headerlink" title="136. Single Number（只出现一次的数字）"></a>136. Single Number（只出现一次的数字）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题思路有点强的，我本来打算遍历加哈希来检测，之后发现了，这题可以用位运算（我从来没有想过这个问题）。<br>异或计算，如果二者相同则结果为0，不同的话结果为1，再加上异或自带的交换律，最后结果就是0异或单一数，就是要找的数字。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int singleNumber(int[] nums) &#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      n = n ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;136-Single-Number（只出现一次的数字）&quot;&gt;&lt;a href=&quot;#136-Single-Number（只出现一次的数字）&quot; class=&quot;headerlink&quot; title=&quot;136. Single Number（只出现一次的数字）&quot;&gt;&lt;/a&gt;136.
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="位运算" scheme="https://cheng102e.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 69. Sqrt(x)</title>
    <link href="https://cheng102e.github.io/LeetCode%2066.%20Plus%20One.html"/>
    <id>https://cheng102e.github.io/LeetCode 66. Plus One.html</id>
    <published>2020-01-01T03:22:00.000Z</published>
    <updated>2020-01-01T03:42:43.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="69-Sqrt-x-（x-的平方根）"><a href="#69-Sqrt-x-（x-的平方根）" class="headerlink" title="69. Sqrt(x)（x 的平方根）"></a>69. Sqrt(x)（x 的平方根）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/sqrtx" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2<br>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>平方根的求法，要么用牛顿迭代法，要么二分法，（遍历也行，但是会超时），设1，x一个开始一个结束，二分法找答案，需要注意的是要采用x/mid&gt;mid,不然会超出范围。<br>2020的第一篇，又是热爱学习的一年。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int mySqrt(int x) &#123;</span><br><span class="line">    if (x == 1 || x == 0) &#123;</span><br><span class="line">      return x;</span><br><span class="line">    &#125;</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = x ;</span><br><span class="line">    while (end - start &gt;= 1) &#123;</span><br><span class="line">      int mid = (start + end) / 2;</span><br><span class="line"></span><br><span class="line">      if (x / mid &gt; mid) &#123;</span><br><span class="line">        start = mid;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        end = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return start;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;69-Sqrt-x-（x-的平方根）&quot;&gt;&lt;a href=&quot;#69-Sqrt-x-（x-的平方根）&quot; class=&quot;headerlink&quot; title=&quot;69. Sqrt(x)（x 的平方根）&quot;&gt;&lt;/a&gt;69. Sqrt(x)（x 的平方根）&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 66. Plus One</title>
    <link href="https://cheng102e.github.io/LeetCode%2069.%20Sqrt(x).html"/>
    <id>https://cheng102e.github.io/LeetCode 69. Sqrt(x).html</id>
    <published>2019-12-29T13:22:00.000Z</published>
    <updated>2020-01-04T02:19:22.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="66-Plus-One（加一）"><a href="#66-Plus-One（加一）" class="headerlink" title="66. Plus One（加一）"></a>66. Plus One（加一）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><p>  输入: [1,2,3]<br>  输出: [1,2,4]<br>  解释: 输入数组表示数字 123。<br>示例 2:</p><p>  输入: [4,3,2,1]<br>  输出: [4,3,2,2]<br>  解释: 输入数组表示数字 4321。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不是很难的题目，只需要注意，给的数组是表示数字的，那么就从后往前加一，如果进位就考虑前一位，不然跳出。<br>如果第一位产生进位，就需要一个新数组，来存放新的第一位。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static int[] plusOne(int[] digits) &#123;</span><br><span class="line">    if (digits.length == 0) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = digits.length;</span><br><span class="line">    digits[len - 1] += 1;</span><br><span class="line">    for (int i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">      if (digits[i] &gt;= 10) &#123;</span><br><span class="line">        digits[i] -= 10;</span><br><span class="line">        digits[i - 1] += 1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (digits[0] == 10) &#123;</span><br><span class="line">      int[] newdigits = new int[len + 1];</span><br><span class="line">      newdigits[0] = 1;</span><br><span class="line">      digits[0] -= 10;</span><br><span class="line">      for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        newdigits[i + 1] = digits[i];</span><br><span class="line">      &#125;</span><br><span class="line">      return newdigits;</span><br><span class="line">    &#125;</span><br><span class="line">    return digits;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;66-Plus-One（加一）&quot;&gt;&lt;a href=&quot;#66-Plus-One（加一）&quot; class=&quot;headerlink&quot; title=&quot;66. Plus One（加一）&quot;&gt;&lt;/a&gt;66. Plus One（加一）&lt;/h2&gt;&lt;h3 id=&quot;链接&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 70. Climbing Stairs</title>
    <link href="https://cheng102e.github.io/LeetCode%2070.%20Climbing%20Stairs.html"/>
    <id>https://cheng102e.github.io/LeetCode 70. Climbing Stairs.html</id>
    <published>2019-12-28T11:08:00.000Z</published>
    <updated>2019-12-29T13:22:06.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="70-Climbing-Stairs（两数之和）"><a href="#70-Climbing-Stairs（两数之和）" class="headerlink" title="70. Climbing Stairs（两数之和）"></a>70. Climbing Stairs（两数之和）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><pre><code>输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><p>示例 2：</p><pre><code>输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>算是一个递归方法，如果只有一阶那么只有一种方法，二阶有两种方法。<br>递归方程<br>    f(n)=f(n-1)+f(n-2)</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">  if (n &lt; 3) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125;</span><br><span class="line">  int f1 = 1;</span><br><span class="line">  int f2 = 2;</span><br><span class="line">  int fn = 0;</span><br><span class="line">  for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">    fn = f1 + f2;</span><br><span class="line">    f1 = f2;</span><br><span class="line">    f2 = fn;</span><br><span class="line">  &#125;</span><br><span class="line">  return fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;70-Climbing-Stairs（两数之和）&quot;&gt;&lt;a href=&quot;#70-Climbing-Stairs（两数之和）&quot; class=&quot;headerlink&quot; title=&quot;70. Climbing Stairs（两数之和）&quot;&gt;&lt;/a&gt;70. Climbing 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 628. Maximum Product of Three Numbers</title>
    <link href="https://cheng102e.github.io/LeetCode%20628.%20Maximum%20Product%20of%20Three%20Numbers.html"/>
    <id>https://cheng102e.github.io/LeetCode 628. Maximum Product of Three Numbers.html</id>
    <published>2019-12-28T10:05:00.000Z</published>
    <updated>2019-12-28T11:13:33.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="628-Maximum-Product-of-Three-Numbers（三个数的最大乘积）"><a href="#628-Maximum-Product-of-Three-Numbers（三个数的最大乘积）" class="headerlink" title="628. Maximum Product of Three Numbers（三个数的最大乘积）"></a>628. Maximum Product of Three Numbers（三个数的最大乘积）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/submissions" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-three-numbers/submissions</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p>示例 1:</p><p>  输入: [1,2,3]<br>  输出: 6<br>示例 2:</p><p>  输入: [1,2,3,4]<br>  输出: 24<br>注意:</p><p>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。<br>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单题，分析一下思路，要求乘积的最大值，那么限定一下范围，只能是三个最大正数相乘，或者两个最小负数相乘再乘最大正数，负负得正。这里采用sort直接排序，偷了个懒，之后算出两种最大值比较输出即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int maximumProduct(int[] nums) &#123;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line">  int max1 = nums[0] * nums[1] * nums[nums.length - 1];</span><br><span class="line">  int max2 = nums[nums.length - 3] * nums[nums.length - 2] * nums[nums.length - 1];</span><br><span class="line"></span><br><span class="line">  return Math.max(max1, max2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;628-Maximum-Product-of-Three-Numbers（三个数的最大乘积）&quot;&gt;&lt;a href=&quot;#628-Maximum-Product-of-Three-Numbers（三个数的最大乘积）&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 13. Roman to Integer</title>
    <link href="https://cheng102e.github.io/LeetCode%2013.%20Roman%20to%20Integer.html"/>
    <id>https://cheng102e.github.io/LeetCode 13. Roman to Integer.html</id>
    <published>2019-12-27T09:39:00.000Z</published>
    <updated>2019-12-28T11:08:40.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13-Roman-to-Integer（罗马数字转整数）"><a href="#13-Roman-to-Integer（罗马数字转整数）" class="headerlink" title="13. Roman to Integer（罗马数字转整数）"></a>13. Roman to Integer（罗马数字转整数）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer/</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><pre><code>字符          数值I             1V             5X             10L             50C             100D             500M             1000</code></pre><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><pre><code>输入: &quot;III&quot;输出: 3</code></pre><p>示例 2:</p><pre><code>输入: &quot;IV&quot;输出: 4</code></pre><p>示例 3:</p><pre><code>输入: &quot;IX&quot;输出: 9</code></pre><p>示例 4:</p><pre><code>输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.</code></pre><p>示例 5:</p><pre><code>输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题比起之前的整数转罗马数字麻烦了很多，整数转罗马只需要考虑去除差即可，现在需要反向转换，首先可以先从头到尾把全部转化为整数，之后如果发现IV等的组合，就减去两倍的I，别的几个同理，得到正确答案。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static int romanToInt(String s) &#123;</span><br><span class="line">    int len = s.length();</span><br><span class="line">    int num = 0;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      switch (s.charAt(i)) &#123;</span><br><span class="line">        case &apos;I&apos;:</span><br><span class="line">          num += 1;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;V&apos;:</span><br><span class="line">          num += 5;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;X&apos;:</span><br><span class="line">          num += 10;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;L&apos;:</span><br><span class="line">          num += 50;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;C&apos;:</span><br><span class="line">          num += 100;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;D&apos;:</span><br><span class="line">          num += 500;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;M&apos;:</span><br><span class="line">          num += 1000;</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          System.out.println(&quot;default&quot;);</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">      if (i != 0) &#123;</span><br><span class="line">        if (s.charAt(i - 1) == &apos;I&apos;) &#123;</span><br><span class="line">          if (s.charAt(i) == &apos;V&apos; || s.charAt(i) == &apos;X&apos;) &#123;</span><br><span class="line">            num -= 2;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.charAt(i - 1) == &apos;X&apos;) &#123;</span><br><span class="line">          if (s.charAt(i) == &apos;L&apos; || s.charAt(i) == &apos;C&apos;) &#123;</span><br><span class="line">            num -= 20;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.charAt(i - 1) == &apos;C&apos;) &#123;</span><br><span class="line">          if (s.charAt(i) == &apos;D&apos; || s.charAt(i) == &apos;M&apos;) &#123;</span><br><span class="line">            num -= 200;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;13-Roman-to-Integer（罗马数字转整数）&quot;&gt;&lt;a href=&quot;#13-Roman-to-Integer（罗马数字转整数）&quot; class=&quot;headerlink&quot; title=&quot;13. Roman to Integer（罗马数字转整数）&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>CCF 2016-04-2 俄罗斯方块</title>
    <link href="https://cheng102e.github.io/CCF%202016-04-2%20%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html"/>
    <id>https://cheng102e.github.io/CCF 2016-04-2 俄罗斯方块.html</id>
    <published>2019-09-05T07:57:00.000Z</published>
    <updated>2019-09-05T08:45:38.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CCF-2016-04-2-俄罗斯方块"><a href="#CCF-2016-04-2-俄罗斯方块" class="headerlink" title="CCF 2016-04-2 俄罗斯方块"></a>CCF 2016-04-2 俄罗斯方块</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>　　　俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。<br>　　游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。<br>　　在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。<br>　　具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>　　　输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。<br>　　输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。<br>　　第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>　输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 0 0 0 1 1 1 10 0 0 0 1 0 0 0 0 00 0 0 00 1 1 10 0 0 10 0 0 03</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 1 0 0</span><br><span class="line">0 0 0 0 0 0 1 0 0 0</span><br><span class="line">0 0 0 0 0 0 1 0 0 0</span><br><span class="line">1 1 1 1 1 1 1 1 1 1</span><br><span class="line">0 0 0 0 1 1 0 0 0 0</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以前的代码，暴力向下计算即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,k,j,t,x;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>][<span class="number">11</span>],b[<span class="number">4</span>][<span class="number">4</span>],c[<span class="number">20</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">c[i][j]=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">16</span>;i&lt;=<span class="number">19</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=<span class="number">1</span>;</span><br><span class="line">c[i][j]=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line"><span class="keyword">int</span> po=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">19</span>&amp;&amp;po;i++)</span><br><span class="line">&#123;</span><br><span class="line">po=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">4</span>;j&gt;=<span class="number">1</span>&amp;&amp;po&amp;&amp;i+j<span class="number">-4</span>&gt;=<span class="number">1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>;x&lt;=<span class="number">4</span>&amp;&amp;po;x++)</span><br><span class="line">&#123;</span><br><span class="line">c[i+j<span class="number">-4</span>][k+x<span class="number">-1</span>]=a[i+j<span class="number">-4</span>][k+x<span class="number">-1</span>]+b[j][x];</span><br><span class="line"><span class="keyword">if</span>(c[i+j<span class="number">-4</span>][k+x<span class="number">-1</span>]&gt;<span class="number">1</span>)</span><br><span class="line">po=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">i=i<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">4</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>;x&lt;=<span class="number">4</span>;x++)</span><br><span class="line">&#123;</span><br><span class="line">a[i+j<span class="number">-4</span>][k+x<span class="number">-1</span>]=a[i+j<span class="number">-4</span>][k+x<span class="number">-1</span>]+b[j][x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[i][j];</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">15</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CCF-2016-04-2-俄罗斯方块&quot;&gt;&lt;a href=&quot;#CCF-2016-04-2-俄罗斯方块&quot; class=&quot;headerlink&quot; title=&quot;CCF 2016-04-2 俄罗斯方块&quot;&gt;&lt;/a&gt;CCF 2016-04-2 俄罗斯方块&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="CCF" scheme="https://cheng102e.github.io/categories/CCF/"/>
    
    
  </entry>
  
  <entry>
    <title>CCF 2016-04-1 折点计数</title>
    <link href="https://cheng102e.github.io/CCF%202016-04-1%20%E6%8A%98%E7%82%B9%E8%AE%A1%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/CCF 2016-04-1 折点计数.html</id>
    <published>2019-09-05T07:56:00.000Z</published>
    <updated>2019-09-05T08:45:38.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CCF-2016-04-1-折点计数"><a href="#CCF-2016-04-1-折点计数" class="headerlink" title="CCF 2016-04-1 折点计数"></a>CCF 2016-04-1 折点计数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>　　　给定<em>n</em>个整数表示一个商店连续<em>n</em>天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。<br><img src="http://118.190.20.162/RequireFile.do?fid=gbLRbhR7" alt="img"><br>　　给定<em>n</em>个整数<em>a</em>1, <em>a</em>2, …, <em>an<em>表示销售量，请计算出这些天总共有多少个折点。<br>　　为了减少歧义，我们给定的数据保证：在这</em>n<em>天中相邻两天的销售量总是不同的，即</em>ai</em>-1≠<em>ai</em>。注意，如果两天不相邻，销售量可能相同。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>​        输入的第一行包含一个整数<em>n</em>。<br>　　第二行包含<em>n</em>个整数，用空格分隔，分别表示<em>a</em>1, <em>a</em>2, …, <em>an</em>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>​        输出一个整数，表示折点出现的数量。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>75 4 1 2 3 6 4</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h4><p>　　所有评测用例满足：1 ≤ <em>n</em> ≤ 1000，每天的销售量是不超过10000的非负整数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历一遍，满足条件加一。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[n],i,t=<span class="number">0</span>,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((a[i]&gt;a[i<span class="number">-1</span>])&amp;&amp;(a[i]&gt;a[i+<span class="number">1</span>]))</span><br><span class="line">t++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((a[i]&lt;a[i<span class="number">-1</span>])&amp;&amp;(a[i]&lt;a[i+<span class="number">1</span>]))</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CCF-2016-04-1-折点计数&quot;&gt;&lt;a href=&quot;#CCF-2016-04-1-折点计数&quot; class=&quot;headerlink&quot; title=&quot;CCF 2016-04-1 折点计数&quot;&gt;&lt;/a&gt;CCF 2016-04-1 折点计数&lt;/h2&gt;&lt;h3 id=&quot;题
      
    
    </summary>
    
      <category term="CCF" scheme="https://cheng102e.github.io/categories/CCF/"/>
    
    
  </entry>
  
  <entry>
    <title>洛谷 P1927 防护伞</title>
    <link href="https://cheng102e.github.io/%E6%B4%9B%E8%B0%B7%20P1927%20%E9%98%B2%E6%8A%A4%E4%BC%9E.html"/>
    <id>https://cheng102e.github.io/洛谷 P1927 防护伞.html</id>
    <published>2019-09-03T12:28:00.000Z</published>
    <updated>2019-09-05T08:45:40.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="洛谷-P1927-防护伞"><a href="#洛谷-P1927-防护伞" class="headerlink" title="洛谷 P1927 防护伞"></a>洛谷 P1927 防护伞</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.org/problem/P1927" target="_blank" rel="noopener">https://www.luogu.org/problem/P1927</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>据说 2012 的灾难和太阳黑子的爆发有关。于是地球防卫小队决定制造一个特殊防护 伞，挡住太阳黑子爆发的区域，减少其对地球的影响。由于太阳相对于地球来说实在是太 大了，我们可以把太阳表面看作一个平面，中心定为(0,0)。根据情报，在 2012 年时， 太阳表面上会产生 N 个黑子区域，每个黑子视为一个点。特殊防护伞可以看作一个巨大 的圆面，现在地球防卫小队决定将它的中心定位于某个黑子，然后用伞面挡住其他黑子。 因为制造防护伞的材料成本特别高，所以我们希望伞面尽可能的小。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行：一个整数 N，表示黑子个数。</p><p>第 2 到 N-1 行：每行两个整数，表示黑子的坐标（x, y）。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>第一行：一个实数，表示伞的面积。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入 #1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0  1 </span><br><span class="line">-8  -4 </span><br><span class="line">-1  4</span><br></pre></td></tr></table></figure><p>输出 #1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">279.6017</span><br></pre></td></tr></table></figure><h4 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h4><p>【数据范围】</p><p>对于 50%的数据： 2≤N≤100。</p><p>对于 100%的数据： 2≤N≤1000。</p><p>-10000≤x,y≤10000。</p><p>【注意】</p><p>精确到小数点后 4 位</p><p>π=3.1415926535</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>水题，遍历一下找到两点间的最远距离，直接公式算结果，控制输出位数即可。</p><p>寻找逆序对的话，排序就行，这里的数据量肯定不能冒泡，所以归并（方便统计数量），归并排序的算法不是很难，以后我会补个排序算法集合（鸽德），这里只需要注意两点，一点是sum每次增加mid-left+1，这个1可能会漏；第二点是数据范围，数组要50w的，答案要longlong。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> x[n],y[n];</span><br><span class="line"><span class="keyword">double</span> len[n][n],minlen[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">len[i][j]=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x[i]-x[j],<span class="number">2</span>)+<span class="built_in">pow</span>(y[i]-y[j],<span class="number">2</span>));</span><br><span class="line">        minlen[i]=max(minlen[i],len[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> min=<span class="number">30000</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(minlen[i]&lt;min)</span><br><span class="line">min=minlen[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans=min*min*<span class="number">3.1415926535</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;洛谷-P1927-防护伞&quot;&gt;&lt;a href=&quot;#洛谷-P1927-防护伞&quot; class=&quot;headerlink&quot; title=&quot;洛谷 P1927 防护伞&quot;&gt;&lt;/a&gt;洛谷 P1927 防护伞&lt;/h2&gt;&lt;h3 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;
      
    
    </summary>
    
      <category term="洛谷" scheme="https://cheng102e.github.io/categories/%E6%B4%9B%E8%B0%B7/"/>
    
    
  </entry>
  
</feed>
