<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-02-14T14:44:02.856Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 88. Merge Sorted Array</title>
    <link href="https://cheng102e.github.io/LeetCode%2088.%20Merge%20Sorted%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 88. Merge Sorted Array.html</id>
    <published>2020-02-14T14:50:00.000Z</published>
    <updated>2020-02-14T14:44:02.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="88-Merge-Sorted-Array（合并两个有序数组）"><a href="#88-Merge-Sorted-Array（合并两个有序数组）" class="headerlink" title="88. Merge Sorted Array（合并两个有序数组）"></a>88. Merge Sorted Array（合并两个有序数组）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><p>  输入:<br>  nums1 = [1,2,3,0,0,0], m = 3<br>  nums2 = [2,5,6],       n = 3</p><p>  输出: [1,2,2,3,5,6]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道数组题目，解法多种。<br>可以直接合并再排序，也可以两个数组开头慢慢遍历，倒是官方给了一种很cool的题解，直接从数组后方开始。<br>三指针，两个指针指向两个数组最后的数字，一个指针指向数组1的末尾，比较之后将数字放到数组1的末尾，不需要额外空间，最后将数组2未使用的数字（如果存在的话）放到数组1的前面即可。<br>（这题我去年好像做过，还没做出来233333）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">  int index = m + n - 1;</span><br><span class="line">  int m1 = m - 1;</span><br><span class="line">  int n1 = n - 1;</span><br><span class="line">  while (m1 &gt;= 0 &amp;&amp; n1 &gt;= 0) &#123;</span><br><span class="line">    if (nums1[m1] &lt; nums2[n1]) &#123;</span><br><span class="line">      nums1[index] = nums2[n1];</span><br><span class="line">      n1--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      nums1[index] = nums1[m1];</span><br><span class="line">      m1--;</span><br><span class="line">    &#125;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">  while (n1 &gt;= 0) &#123;</span><br><span class="line">    nums1[index] = nums2[n1];</span><br><span class="line">    n1--;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;88-Merge-Sorted-Array（合并两个有序数组）&quot;&gt;&lt;a href=&quot;#88-Merge-Sorted-Array（合并两个有序数组）&quot; class=&quot;headerlink&quot; title=&quot;88. Merge Sorted Array（合并两个有序数
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 75. Sort Colors</title>
    <link href="https://cheng102e.github.io/LeetCode%2075.%20Sort%20Colors.html"/>
    <id>https://cheng102e.github.io/LeetCode 75. Sort Colors.html</id>
    <published>2020-02-14T12:50:00.000Z</published>
    <updated>2020-02-14T12:48:27.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="75-Sort-Colors（颜色分类）"><a href="#75-Sort-Colors（颜色分类）" class="headerlink" title="75. Sort Colors（颜色分类）"></a>75. Sort Colors（颜色分类）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><p>  输入: [2,0,2,1,1,0]<br>  输出: [0,0,1,1,2,2]<br>进阶：</p><p>  一个直观的解决方案是使用计数排序的两趟扫描算法。<br>  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>  你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道数组题目，解法多种。<br>说不让用代码库中的排序函数，那自己写一个应该不算违规吧23333.<br>只有三种数字，012，那么可以遍历统计每个数字的数量，之后直接更改。<br>也可以用三指针法，index012，一共三个变量，index0和1初始值是0，index2初始值是nums.length-1.遍历使用index1，发现那个数字为0，就和index0的数交换，为2就和index2的数交换，这里要注意，index2换过来的数还需要再判断一下。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  public static void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">  int temp = nums[i];</span><br><span class="line">  nums[i] = nums[j];</span><br><span class="line">  nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">  int index0 = 0, index1 = 0, index2 = nums.length - 1;</span><br><span class="line">  while (index1 &lt;= index2) &#123;</span><br><span class="line">    if (nums[index1] == 0) &#123;</span><br><span class="line">      swap(nums, index1, index0);</span><br><span class="line">      index0++;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125; else if (nums[index1] == 2) &#123;</span><br><span class="line">      swap(nums, index1, index2);</span><br><span class="line">      index2--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;75-Sort-Colors（颜色分类）&quot;&gt;&lt;a href=&quot;#75-Sort-Colors（颜色分类）&quot; class=&quot;headerlink&quot; title=&quot;75. Sort Colors（颜色分类）&quot;&gt;&lt;/a&gt;75. Sort Colors（颜色分类）&lt;/h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 581. Shortest Unsorted Continuous Subarray</title>
    <link href="https://cheng102e.github.io/LeetCode%20581.%20Shortest%20Unsorted%20Continuous%20Subarray.html"/>
    <id>https://cheng102e.github.io/LeetCode 581. Shortest Unsorted Continuous Subarray.html</id>
    <published>2020-02-12T03:13:00.000Z</published>
    <updated>2020-02-12T03:20:18.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）"><a href="#581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）" class="headerlink" title="581. Shortest Unsorted Continuous Subarray（最短无序连续子数组）"></a>581. Shortest Unsorted Continuous Subarray（最短无序连续子数组）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:</p><p>  输入: [2, 6, 4, 8, 10, 9, 15]<br>  输出: 5<br>  解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。<br>说明 :</p><p>输入的数组长度范围在 [1, 10,000]。<br>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题方法多种，可以排序之后对比，也可以用别的方法。<br>首先遍历，由前往后由后往前，分别确定两个边界。前向后时寻找右边界，每个数字判断是否小于前方最大值，若小于，就代表这个数需要排序，若大于，就代表这个数可以放在当前位置，若最后全为升序排列那就不用排序，后向前同理。<br>以输入示范，首先max为2，之后往后遍历，6&gt;2,max=6,4&lt;6,需要排序，一直往后，right=5，15大于前方所有数字，无需排序。反向遍历，2小于后方所有数，left=1，5-1+1=5.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int findUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">  int len = nums.length;</span><br><span class="line">  int max = nums[0];</span><br><span class="line">  int min = nums[len - 1];</span><br><span class="line">  int left = 0, right = -1;</span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    if (max &gt; nums[i]) &#123;</span><br><span class="line">      right = i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = len - 1; i &gt; -1; i--) &#123;</span><br><span class="line">    if (min &lt; nums[i]) &#123;</span><br><span class="line">      left = i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      min = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return right - left + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）&quot;&gt;&lt;a href=&quot;#581-Shortest-Unsorted-Continuous-Subarray（最短无序连续子数组）&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 20. Valid Parentheses</title>
    <link href="https://cheng102e.github.io/LeetCode%2020.%20Valid%20Parentheses.html"/>
    <id>https://cheng102e.github.io/LeetCode 20. Valid Parentheses.html</id>
    <published>2020-02-11T14:20:00.000Z</published>
    <updated>2020-02-12T02:26:37.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20-Valid-Parentheses（有效的括号）"><a href="#20-Valid-Parentheses（有效的括号）" class="headerlink" title="20. Valid Parentheses（有效的括号）"></a>20. Valid Parentheses（有效的括号）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>  输入: “()”<br>  输出: true<br>示例 2:</p><p>  输入: “()[]{}”<br>  输出: true<br>示例 3:</p><p>  输入: “(]”<br>  输出: false<br>示例 4:</p><p>  输入: “([)]”<br>  输出: false<br>示例 5:</p><p>  输入: “{[]}”<br>  输出: true</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断括号嘛，我用了最基础的解法，借助栈一个一个找，如果为左括号则入栈，若为右括号且栈顶为对应左括号则出栈，不然直接返回false，一直到遍历结束，如果栈为空就返回true。效率虽然不是很高但是思路很清晰。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">  Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">  for (char c : s.toCharArray()) &#123;</span><br><span class="line">    if (c == &apos;)&apos; &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">      if (stack.peek() == &apos;(&apos;) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (c == &apos;]&apos; &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">      if (stack.peek() == &apos;[&apos;) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (c == &apos;&#125;&apos; &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">      if (stack.peek() == &apos;&#123;&apos;) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      stack.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;20-Valid-Parentheses（有效的括号）&quot;&gt;&lt;a href=&quot;#20-Valid-Parentheses（有效的括号）&quot; class=&quot;headerlink&quot; title=&quot;20. Valid Parentheses（有效的括号）&quot;&gt;&lt;/a&gt;20. 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="栈与队列" scheme="https://cheng102e.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 53. Maximum Subarray</title>
    <link href="https://cheng102e.github.io/LeetCode%2053.%20Maximum%20Subarray.html"/>
    <id>https://cheng102e.github.io/LeetCode 53. Maximum Subarray.html</id>
    <published>2020-02-11T13:50:00.000Z</published>
    <updated>2020-02-12T02:26:36.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="53-Maximum-Subarray（最大子序和）"><a href="#53-Maximum-Subarray（最大子序和）" class="headerlink" title="53. Maximum Subarray（最大子序和）"></a>53. Maximum Subarray（最大子序和）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>  输入: [-2,1,-3,4,-1,2,1,-5,4],<br>  输出: 6<br>  解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p><p>  如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没尝试分治法，那个有点麻烦，等做到别的分治时候再做。<br>这边有动态规划的思想在里面，从头到尾遍历，如果和小于0，那么直接无视，重新开始，和大于0，就加上之前的和。每次都保留当前最大的和，直到输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums) &#123;</span><br><span class="line">    int ans = nums[0];</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">      if (sum &gt;= 0) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        sum = num;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = Math.max(sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;53-Maximum-Subarray（最大子序和）&quot;&gt;&lt;a href=&quot;#53-Maximum-Subarray（最大子序和）&quot; class=&quot;headerlink&quot; title=&quot;53. Maximum Subarray（最大子序和）&quot;&gt;&lt;/a&gt;53. Max
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 461. Hamming Distance</title>
    <link href="https://cheng102e.github.io/LeetCode%20461.%20Hamming%20Distance.html"/>
    <id>https://cheng102e.github.io/LeetCode 461. Hamming Distance.html</id>
    <published>2020-02-11T11:50:00.000Z</published>
    <updated>2020-02-12T12:20:05.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="461-Hamming-Distance（汉明距离）"><a href="#461-Hamming-Distance（汉明距离）" class="headerlink" title="461. Hamming Distance（汉明距离）"></a>461. Hamming Distance（汉明距离）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/hamming-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hamming-distance</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><p>注意：<br>0 ≤ x, y &lt; 231.</p><p>示例:</p><p>  输入: x = 1, y = 4</p><p>  输出: 2</p><p>  解释:<br>  1   (0 0 0 1)<br>  4   (0 1 0 0)<br>        ↑   ↑</p><p>上面的箭头指出了对应二进制位不同的位置。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题的名词也就是转换一下，需要我们找到二进制位的不同，这时候异或最简单，直接找到不同位，然后可以按位寻找，也可以直接和1进行与运算，然后右移。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  public static int hammingDistance(int x, int y) &#123;</span><br><span class="line">  int xor = x ^ y;</span><br><span class="line">  int num = 0;</span><br><span class="line">  while (xor != 0) &#123;</span><br><span class="line">    if ((xor &amp; 1) == 1) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    xor = xor &gt;&gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;461-Hamming-Distance（汉明距离）&quot;&gt;&lt;a href=&quot;#461-Hamming-Distance（汉明距离）&quot; class=&quot;headerlink&quot; title=&quot;461. Hamming Distance（汉明距离）&quot;&gt;&lt;/a&gt;461. Ha
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="位运算" scheme="https://cheng102e.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 448. Find All Numbers Disappeared in an Array</title>
    <link href="https://cheng102e.github.io/LeetCode%20448.%20Find%20All%20Numbers%20Disappeared%20in%20an%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 448. Find All Numbers Disappeared in an Array.html</id>
    <published>2020-02-11T11:50:00.000Z</published>
    <updated>2020-02-11T12:11:42.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="448-Find-All-Numbers-Disappeared-in-an-Array（找到所有数组中消失的数字）"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array（找到所有数组中消失的数字）" class="headerlink" title="448. Find All Numbers Disappeared in an Array（找到所有数组中消失的数字）"></a>448. Find All Numbers Disappeared in an Array（找到所有数组中消失的数字）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:</p><p>  输入:<br>  [4,3,2,7,8,2,3,1]</p><p>  输出:<br>  [5,6]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题的题意很简单，就是要找到缺失的数字，但是思路很巧妙，对于每个数字，都设置一个位置，就像例子一样，第一个数字为4，就将第四个数字设置为-7，一遍循环之后，数组就成为[-4,-3,-2,-7,8,2,-3,-1],然后第二次遍历，如果数字为正，就代表数组中不存在这个数，记录到答案中即可，这里要注意数组从0开始，而数字从1开始。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  public static List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;</span><br><span class="line">  for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">    int temp = Math.abs(nums[i]);</span><br><span class="line">    nums[temp-1]=-Math.abs(nums[temp-1]);</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;Integer&gt;ans = new ArrayList(nums.length);</span><br><span class="line">  for(int i=0;i&lt;nums.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    if(nums[i]&gt;0)&#123;</span><br><span class="line">      ans.add(i+1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;448-Find-All-Numbers-Disappeared-in-an-Array（找到所有数组中消失的数字）&quot;&gt;&lt;a href=&quot;#448-Find-All-Numbers-Disappeared-in-an-Array（找到所有数组中消失的数字）&quot; cl
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 976. Largest Perimeter Triangle</title>
    <link href="https://cheng102e.github.io/LeetCode%20976.%20Largest%20Perimeter%20Triangle.html"/>
    <id>https://cheng102e.github.io/LeetCode 976. Largest Perimeter Triangle.html</id>
    <published>2020-02-05T03:11:00.000Z</published>
    <updated>2020-02-05T03:17:12.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="976-Largest-Perimeter-Triangle（三角形的最大周长）"><a href="#976-Largest-Perimeter-Triangle（三角形的最大周长）" class="headerlink" title="976. Largest Perimeter Triangle（三角形的最大周长）"></a>976. Largest Perimeter Triangle（三角形的最大周长）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-perimeter-triangle</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。</p><p>如果不能形成任何面积不为零的三角形，返回 0。</p><p>示例 1：</p><p>  输入：[2,1,2]<br>  输出：5<br>示例 2：</p><p>  输入：[1,2,1]<br>  输出：0<br>示例 3：</p><p>  输入：[3,2,3,4]<br>  输出：10<br>示例 4：</p><p>  输入：[3,6,2,3]<br>  输出：8</p><p>提示：</p><p>  3 &lt;= A.length &lt;= 10000<br>  1 &lt;= A[i] &lt;= 10^6</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题偷了个懒，直接用了自带的sort函数，之后就是一共从后向前的循环，每三个为一组，若该组可以构成三角形，返回长度，不然跳出。<br>这里还有一个数学问题，为什么是连续的三个而不是中断的三个，这里假设有四个数字abcd，升序排列，先判断bcd，在判断abc，因为如果b+c&lt;d，无法构成,那么a+c&lt;b+c更无法构成了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int largestPerimeter(int[] A) &#123;</span><br><span class="line">  Arrays.sort(A);</span><br><span class="line">  for (int i = A.length - 1; i &gt; 1; i--) &#123;</span><br><span class="line">    if (A[i] &lt; A[i - 1] + A[i - 2]) &#123;</span><br><span class="line">      return A[i] + A[i - 1] + A[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;976-Largest-Perimeter-Triangle（三角形的最大周长）&quot;&gt;&lt;a href=&quot;#976-Largest-Perimeter-Triangle（三角形的最大周长）&quot; class=&quot;headerlink&quot; title=&quot;976. Largest
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1295. Find Numbers with Even Number of Digits</title>
    <link href="https://cheng102e.github.io/LeetCode%201295.%20Find%20Numbers%20with%20Even%20Number%20of%20Digits.html"/>
    <id>https://cheng102e.github.io/LeetCode 1295. Find Numbers with Even Number of Digits.html</id>
    <published>2020-02-04T03:29:00.000Z</published>
    <updated>2020-02-04T03:31:22.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1295-Find-Numbers-with-Even-Number-of-Digits（统计位数为偶数的数字）"><a href="#1295-Find-Numbers-with-Even-Number-of-Digits（统计位数为偶数的数字）" class="headerlink" title="1295. Find Numbers with Even Number of Digits（统计位数为偶数的数字）"></a>1295. Find Numbers with Even Number of Digits（统计位数为偶数的数字）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。</p><p>示例 1：</p><p>  输入：nums = [12,345,2,6,7896]<br>  输出：2<br>  解释：<br>  12 是 2 位数字（位数为偶数）<br>  345 是 3 位数字（位数为奇数）<br>  2 是 1 位数字（位数为奇数）<br>  6 是 1 位数字 位数为奇数）<br>  7896 是 4 位数字（位数为偶数）<br>  因此只有 12 和 7896 是位数为偶数的数字<br>示例 2：</p><p>  输入：nums = [555,901,482,1771]<br>  输出：1<br>  解释：<br>  只有 1771 是位数为偶数的数字。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>emmm我也不知道算是什么题目，从头到尾判断一下就行了，对于数字的范围判断一下，其实也可以转字符串判断长度，不过没必要。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int findNumbers(int[] nums) &#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  for (int num : nums) &#123;</span><br><span class="line">    if ((10 &lt;= num &amp;&amp; num &lt;= 99) || (1000 &lt;= num &amp;&amp; num &lt;= 9999) || num == 100000) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1295-Find-Numbers-with-Even-Number-of-Digits（统计位数为偶数的数字）&quot;&gt;&lt;a href=&quot;#1295-Find-Numbers-with-Even-Number-of-Digits（统计位数为偶数的数字）&quot; class=
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 374. Guess Number Higher or Lower</title>
    <link href="https://cheng102e.github.io/LeetCode%20374.%20Guess%20Number%20Higher%20or%20Lower.html"/>
    <id>https://cheng102e.github.io/LeetCode 374. Guess Number Higher or Lower.html</id>
    <published>2020-02-03T12:19:00.000Z</published>
    <updated>2020-02-03T12:19:33.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="374-Guess-Number-Higher-or-Lower（猜数字大小）"><a href="#374-Guess-Number-Higher-or-Lower（猜数字大小）" class="headerlink" title="374. Guess Number Higher or Lower（猜数字大小）"></a>374. Guess Number Higher or Lower（猜数字大小）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower" target="_blank" rel="noopener">https://leetcode-cn.com/problems/guess-number-higher-or-lower</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：</p><p>-1 : 我的数字比较小<br> 1 : 我的数字比较大<br> 0 : 恭喜！你猜对了！<br>示例 :</p><p>  输入: n = 10, pick = 6<br>  输出: 6</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个也是二分查找，只不过又换了一种问法。<br>这里只需要注意到leftright的更新与guess函数的返回值即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int guessNumber(int n) &#123;</span><br><span class="line">  int left = 1;</span><br><span class="line">  int right = n;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (guess(mid) == 0) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (guess(mid) == 1) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (guess(mid) == -1) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;374-Guess-Number-Higher-or-Lower（猜数字大小）&quot;&gt;&lt;a href=&quot;#374-Guess-Number-Higher-or-Lower（猜数字大小）&quot; class=&quot;headerlink&quot; title=&quot;374. Guess Num
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 278. First Bad Version</title>
    <link href="https://cheng102e.github.io/LeetCode%20278.%20First%20Bad%20Version.html"/>
    <id>https://cheng102e.github.io/LeetCode 278. First Bad Version.html</id>
    <published>2020-02-03T12:09:00.000Z</published>
    <updated>2020-02-03T12:21:46.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="278-First-Bad-Version（第一个错误的版本）"><a href="#278-First-Bad-Version（第一个错误的版本）" class="headerlink" title="278. First Bad Version（第一个错误的版本）"></a>278. First Bad Version（第一个错误的版本）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/first-bad-version" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p>示例:</p><p>  给定 n = 5，并且 version = 4 是第一个错误的版本。</p><p>  调用 isBadVersion(3) -&gt; false<br>  调用 isBadVersion(5) -&gt; true<br>  调用 isBadVersion(4) -&gt; true</p><p>  所以，4 是第一个错误的版本。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个也是二分查找，问题相对来说不是很大，只需要注意几个细节即可，返回值为true表示版本错误，同时注意left和right的顺序，并且mid取值的时候要注意到不能溢出，最后返回left即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  public static int firstBadVersion(int n) &#123;</span><br><span class="line">  int left = 1;</span><br><span class="line">  int right = n;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (isBadVersion(mid) == true) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (isBadVersion(mid) == false) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;278-First-Bad-Version（第一个错误的版本）&quot;&gt;&lt;a href=&quot;#278-First-Bad-Version（第一个错误的版本）&quot; class=&quot;headerlink&quot; title=&quot;278. First Bad Version（第一个错误的版
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 35. Search Insert Position</title>
    <link href="https://cheng102e.github.io/LeetCode%2035.%20Search%20Insert%20Position.html"/>
    <id>https://cheng102e.github.io/LeetCode 35. Search Insert Position.html</id>
    <published>2020-02-03T05:09:00.000Z</published>
    <updated>2020-02-03T05:45:28.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="35-Search-Insert-Position（二分查找）"><a href="#35-Search-Insert-Position（二分查找）" class="headerlink" title="35. Search Insert Position（二分查找）"></a>35. Search Insert Position（二分查找）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><p>  输入: [1,3,5,6], 5<br>  输出: 2<br>示例 2:</p><p>  输入: [1,3,5,6], 2<br>  输出: 1<br>示例 3:</p><p>  输入: [1,3,5,6], 7<br>  输出: 4<br>示例 4:</p><p>  输入: [1,3,5,6], 0<br>  输出: 0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找加了一些别的东西，升序数组，找到返回下标，未找到就返回可以加入的位置.<br>代码和正常的二分查找相同，需要注意的是，最后一个返回的应该是left，因为在最后一次循环中，left=right，然后left++，这个位置，就是应该存放的位置。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  public static int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;35-Search-Insert-Position（二分查找）&quot;&gt;&lt;a href=&quot;#35-Search-Insert-Position（二分查找）&quot; class=&quot;headerlink&quot; title=&quot;35. Search Insert Position（二分查
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>查找算法-二分查找</title>
    <link href="https://cheng102e.github.io/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <id>https://cheng102e.github.io/查找算法-二分查找.html</id>
    <published>2020-02-03T05:00:00.000Z</published>
    <updated>2020-02-12T12:00:03.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找算法-二分查找"><a href="#查找算法-二分查找" class="headerlink" title="查找算法-二分查找"></a>查找算法-二分查找</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置两个标签，一个为left一个为right，分别表示左侧与右侧，常见初始值为0，length-1.<br>之后进行while循环，这里注意，判断条件选择left&lt;=right，这里当然可以改变，但是最好是熟练之后再进行改变。<br>循环中定义mid = (left + right) / 2，其实更好的是left+（right-left）/2；这样避免越界。<br>若找到了所需要的值，直接返回，找不到的话，就先判断nums[mid]与目标值的大小关系，重新确立leftright，进行下一步运算。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>O(log2n)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查找算法-二分查找&quot;&gt;&lt;a href=&quot;#查找算法-二分查找&quot; class=&quot;headerlink&quot; title=&quot;查找算法-二分查找&quot;&gt;&lt;/a&gt;查找算法-二分查找&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="算法" scheme="https://cheng102e.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="https://cheng102e.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 796. Rotate String</title>
    <link href="https://cheng102e.github.io/LeetCode%20796.%20Rotate%20String.html"/>
    <id>https://cheng102e.github.io/LeetCode 796. Rotate String.html</id>
    <published>2020-02-02T12:00:00.000Z</published>
    <updated>2020-02-02T13:18:03.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="796-Rotate-String（旋转字符串）"><a href="#796-Rotate-String（旋转字符串）" class="headerlink" title="796. Rotate String（旋转字符串）"></a>796. Rotate String（旋转字符串）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/rotate-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-string</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串, A 和 B。</p><p>A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = ‘abcde’，在移动一次之后结果就是’bcdea’ 。如果在若干次旋转操作之后，A 能变成B，那么返回True。</p><p>示例 1:<br>  输入: A = ‘abcde’, B = ‘cdeab’<br>  输出: true</p><p>示例 2:<br>  输入: A = ‘abcde’, B = ‘abced’<br>  输出: false<br>注意：</p><p>A 和 B 长度不超过 100。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目不是很难，但是好的思路可以大大减少所需时间。这里的思路是借鉴的，首先确保AB的长度相同，然后建立A+A，如果这里面包含B的话，就满足条件，因为A+A中随便截取等长的串都可能满足B的条件。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static boolean rotateString(String A, String B) &#123;</span><br><span class="line">    if (A.length() == B.length() &amp;&amp; ((A + A).contains(B))) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;796-Rotate-String（旋转字符串）&quot;&gt;&lt;a href=&quot;#796-Rotate-String（旋转字符串）&quot; class=&quot;headerlink&quot; title=&quot;796. Rotate String（旋转字符串）&quot;&gt;&lt;/a&gt;796. Rotate S
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 27. Remove Element</title>
    <link href="https://cheng102e.github.io/LeetCode%2027.%20Remove%20Element.html"/>
    <id>https://cheng102e.github.io/LeetCode 27. Remove Element.html</id>
    <published>2020-02-02T12:00:00.000Z</published>
    <updated>2020-02-02T13:17:58.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="27-Remove-Element（移除元素）"><a href="#27-Remove-Element（移除元素）" class="headerlink" title="27. Remove Element（移除元素）"></a>27. Remove Element（移除元素）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-element</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><p>  给定 nums = [3,2,2,3], val = 3,</p><p>  函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>  你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>  给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p><p>  函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>  注意这五个元素可为任意顺序。</p><p>  你不需要考虑数组中超出新长度后面的元素。<br>说明:</p><p>  为什么返回数值是整数，但输出的答案是数组呢?</p><p>  请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>  你可以想象内部操作如下:</p><p>  // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>  int len = removeElement(nums, val);</p><p>  // 在函数里修改输入数组对于调用者是可见的。<br>  // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>  for (int i = 0; i &lt; len; i++) {<br>      print(nums[i]);<br>  }</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目内容清晰，但是要求要用原地算法，不给额外空间，所以直接用双指针法，和前一题思路相同。<br>新建一个index，然后遍历数组，如果发现和val不相同，就存储进来，相同就无视，最后输出index即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int removeElement(int[] nums, int val) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      if (nums[i] != val) &#123;</span><br><span class="line">        nums[index]=nums[i];</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;27-Remove-Element（移除元素）&quot;&gt;&lt;a href=&quot;#27-Remove-Element（移除元素）&quot; class=&quot;headerlink&quot; title=&quot;27. Remove Element（移除元素）&quot;&gt;&lt;/a&gt;27. Remove Eleme
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 26. Remove Duplicates from Sorted Array</title>
    <link href="https://cheng102e.github.io/LeetCode%2026.%20Remove%20Duplicates%20from%20Sorted%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 26. Remove Duplicates from Sorted Array.html</id>
    <published>2020-02-02T11:59:00.000Z</published>
    <updated>2020-02-02T13:19:22.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="26-Remove-Duplicates-from-Sorted-Array（删除排序数组中的重复项）"><a href="#26-Remove-Duplicates-from-Sorted-Array（删除排序数组中的重复项）" class="headerlink" title="26. Remove Duplicates from Sorted Array（删除排序数组中的重复项）"></a>26. Remove Duplicates from Sorted Array（删除排序数组中的重复项）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><p>  给定数组 nums = [1,1,2], </p><p>  函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>  你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>  给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>  函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>  你不需要考虑数组中超出新长度后面的元素。<br>说明:</p><p>  为什么返回数值是整数，但输出的答案是数组呢?</p><p>  请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>  你可以想象内部操作如下:</p><p>  // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>  int len = removeDuplicates(nums);</p><p>  // 在函数里修改输入数组对于调用者是可见的。<br>  // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>  for (int i = 0; i &lt; len; i++) {<br>      print(nums[i]);<br>  }</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目内容清晰，但是要求要用原地算法，不给额外空间，所以直接用双指针法。<br>新建一个index，然后遍历数组，如果发现二者相同就跳过，不同的话，就在index的下一位更换，这里要注意index的变化顺序，最后输出index+1即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int removeDuplicates(int[] nums) &#123;</span><br><span class="line">  int index = 0;</span><br><span class="line">  for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    if (nums[i] != nums[index]) &#123;</span><br><span class="line">      index++;</span><br><span class="line">      nums[index] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return index+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;26-Remove-Duplicates-from-Sorted-Array（删除排序数组中的重复项）&quot;&gt;&lt;a href=&quot;#26-Remove-Duplicates-from-Sorted-Array（删除排序数组中的重复项）&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 704. Binary Search</title>
    <link href="https://cheng102e.github.io/LeetCode%20704.%20Binary%20Search.html"/>
    <id>https://cheng102e.github.io/LeetCode 704. Binary Search.html</id>
    <published>2020-02-02T10:00:00.000Z</published>
    <updated>2020-02-02T10:41:38.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="704-Binary-Search（二分查找）"><a href="#704-Binary-Search（二分查找）" class="headerlink" title="704. Binary Search（二分查找）"></a>704. Binary Search（二分查找）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>  输入: nums = [-1,0,3,5,9,12], target = 9<br>  输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p><p>  输入: nums = [-1,0,3,5,9,12], target = 2<br>  输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><p>提示：</p><p>  你可以假设 nums 中的所有元素是不重复的。<br>  n 将在 [1, 10000]之间。<br>  nums 的每个元素都将在 [-9999, 9999]之间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>标准的二分查找，升序数组，找到返回下标，未找到就返回-1.<br>首先如果长度为0，直接返回-11，之后确定左端右端，然后借助while循环进行，注意这里我用的是&lt;=判断，然后循环，如果得到答案返回下标，不然直接输出-1.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;704-Binary-Search（二分查找）&quot;&gt;&lt;a href=&quot;#704-Binary-Search（二分查找）&quot; class=&quot;headerlink&quot; title=&quot;704. Binary Search（二分查找）&quot;&gt;&lt;/a&gt;704. Binary Sear
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 961. N-Repeated Element in Size 2N Array</title>
    <link href="https://cheng102e.github.io/LeetCode%20961.%20N-Repeated%20Element%20in%20Size%202N%20Array.html"/>
    <id>https://cheng102e.github.io/LeetCode 961. N-Repeated Element in Size 2N Array.html</id>
    <published>2020-02-02T02:00:00.000Z</published>
    <updated>2020-02-02T09:24:22.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="961-N-Repeated-Element-in-Size-2N-Array（重复-N-次的元素）"><a href="#961-N-Repeated-Element-in-Size-2N-Array（重复-N-次的元素）" class="headerlink" title="961. N-Repeated Element in Size 2N Array（重复 N 次的元素）"></a>961. N-Repeated Element in Size 2N Array（重复 N 次的元素）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。</p><p>返回重复了 N 次的那个元素。</p><p>示例 1：</p><p>  输入：[1,2,3,3]<br>  输出：3<br>示例 2：</p><p>  输入：[2,1,2,5,3,2]<br>  输出：2<br>示例 3：</p><p>  输入：[5,1,5,2,5,3,5,4]<br>  输出：5</p><p>提示：</p><p>  4 &lt;= A.length &lt;= 10000<br>  0 &lt;= A[i] &lt; 10000<br>  A.length 为偶数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题不是很难，就是想找到那个出现次数为N的数字，一共只有2N个数字，如果分布的最开的话，是每个数字之间都插一个数字，这样可以证明一定存在连续的三个数字，使那一个数字出现两次及以上。<br>所以只要从头到尾检查一下，若三个数字中出现两个相同数字，该数字即为所求解，不然就是最后一个数字。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int repeatedNTimes(int[] A) &#123;</span><br><span class="line">  int len = A.length;</span><br><span class="line">  for (int i = 0; i &lt; len - 2; i++) &#123;</span><br><span class="line">    if (A[i] == A[i + 1] || A[i] == A[i + 2]) &#123;</span><br><span class="line">      return A[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return A[len - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;961-N-Repeated-Element-in-Size-2N-Array（重复-N-次的元素）&quot;&gt;&lt;a href=&quot;#961-N-Repeated-Element-in-Size-2N-Array（重复-N-次的元素）&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1051. Height Checker</title>
    <link href="https://cheng102e.github.io/LeetCode%201051.%20Height%20Checker.html"/>
    <id>https://cheng102e.github.io/LeetCode 1051. Height Checker.html</id>
    <published>2020-02-01T14:30:00.000Z</published>
    <updated>2020-02-02T01:58:28.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1051-Height-Checker（高度检查器）"><a href="#1051-Height-Checker（高度检查器）" class="headerlink" title="1051. Height Checker（高度检查器）"></a>1051. Height Checker（高度检查器）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/height-checker" target="_blank" rel="noopener">https://leetcode-cn.com/problems/height-checker</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。</p><p>请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。</p><p>示例：</p><p>  输入：heights = [1,1,4,2,1,3]<br>  输出：3</p><p>提示：</p><p>  1 &lt;= heights.length &lt;= 100<br>  1 &lt;= heights[i] &lt;= 100</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不是很懂这题的意义，直接排序然后和原数组比较，每一个不同的就加一，直接输出即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int heightChecker(int[] heights) &#123;</span><br><span class="line">    int[] other = heights.clone();</span><br><span class="line">    Arrays.sort(other);</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; heights.length; i++) &#123;</span><br><span class="line">      if (other[i] != heights[i]) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1051-Height-Checker（高度检查器）&quot;&gt;&lt;a href=&quot;#1051-Height-Checker（高度检查器）&quot; class=&quot;headerlink&quot; title=&quot;1051. Height Checker（高度检查器）&quot;&gt;&lt;/a&gt;1051. H
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 67. Add Binary</title>
    <link href="https://cheng102e.github.io/LeetCode%2067.%20Add%20Binary.html"/>
    <id>https://cheng102e.github.io/LeetCode 67. Add Binary.html</id>
    <published>2020-01-31T04:50:00.000Z</published>
    <updated>2020-01-31T04:53:50.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="67-Add-Binary（二进制求和）"><a href="#67-Add-Binary（二进制求和）" class="headerlink" title="67. Add Binary（二进制求和）"></a>67. Add Binary（二进制求和）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/add-binary" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-binary</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为非空字符串且只包含数字 1 和 0。</p><p>示例 1:</p><p>  输入: a = “11”, b = “1”<br>  输出: “100”<br>示例 2:</p><p>  输入: a = “1010”, b = “1011”<br>  输出: “10101”</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>做起来比想象中麻烦不少，很多小细节需要注意。这里我直接用了一个StringBuilder来存储答案。<br>从后往前计算，num用于保存进位。若ab该位都存在，则二者加num为计算结果，num只有四种情况0123，01无进位，写入。23有进位，-2后写入，进位则置num为1否则为0，然后参与下一步运算。<br>如果ab都计算完了，num为1，则再产生进位，细节问题较多。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  public static String addBinary(String a, String b) &#123;</span><br><span class="line">  StringBuilder ans = new StringBuilder();</span><br><span class="line">  int len1 = a.length() - 1;</span><br><span class="line">  int len2 = b.length() - 1;</span><br><span class="line">  int num = 0;</span><br><span class="line">  while (len1 &gt;= 0 || len2 &gt;= 0) &#123;</span><br><span class="line">    if (len1 &gt;= 0) &#123;</span><br><span class="line">      num += a.charAt(len1) - &apos;0&apos;;</span><br><span class="line">      len1--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len2 &gt;= 0) &#123;</span><br><span class="line">      num += b.charAt(len2) - &apos;0&apos;;</span><br><span class="line">      len2--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num &lt; 2) &#123;</span><br><span class="line">      ans.insert(0, num);</span><br><span class="line">      num = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ans.insert(0, num - 2);</span><br><span class="line">      num = 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (num == 1) &#123;</span><br><span class="line">    ans.insert(0, 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;67-Add-Binary（二进制求和）&quot;&gt;&lt;a href=&quot;#67-Add-Binary（二进制求和）&quot; class=&quot;headerlink&quot; title=&quot;67. Add Binary（二进制求和）&quot;&gt;&lt;/a&gt;67. Add Binary（二进制求和）&lt;/h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
</feed>
