<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-03-18T06:16:27.826Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 543. Diameter of Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20543.%20Diameter%20of%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 543. Diameter of Binary Tree.html</id>
    <published>2020-03-18T06:00:00.000Z</published>
    <updated>2020-03-18T06:16:27.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="543-Diameter-of-Binary-Tree（二叉树的直径）"><a href="#543-Diameter-of-Binary-Tree（二叉树的直径）" class="headerlink" title="543. Diameter of Binary Tree（二叉树的直径）"></a>543. Diameter of Binary Tree（二叉树的直径）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>    1   / \  2   3 / \     4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目和翻译简直就是两码事，可以把题目理解成每个节点左右子树的深度和，遍历整棵树找到最大值即可，这里还是用递归舒服一点，求子树深度顺便加个max记录最大值即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next;</span><br><span class="line"></span><br><span class="line">  ListNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">  List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">  while (head != null) &#123;</span><br><span class="line">    list.add(head.val);</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  int len = list.size();</span><br><span class="line">  Integer[] num = list.toArray(new Integer [len]);</span><br><span class="line">  for (int i = 0; i &lt;= len / 2; i++) &#123;</span><br><span class="line">    if (!num[i].equals(num[len - 1 - i])) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;543-Diameter-of-Binary-Tree（二叉树的直径）&quot;&gt;&lt;a href=&quot;#543-Diameter-of-Binary-Tree（二叉树的直径）&quot; class=&quot;headerlink&quot; title=&quot;543. Diameter of Binar
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 234. Palindrome Linked List</title>
    <link href="https://cheng102e.github.io/LeetCode%20234.%20Palindrome%20Linked%20List.html"/>
    <id>https://cheng102e.github.io/LeetCode 234. Palindrome Linked List.html</id>
    <published>2020-03-18T05:00:00.000Z</published>
    <updated>2020-03-18T05:50:21.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="234-Palindrome-Linked-List（回文链表）"><a href="#234-Palindrome-Linked-List（回文链表）" class="headerlink" title="234. Palindrome Linked List（回文链表）"></a>234. Palindrome Linked List（回文链表）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>  输入: 1-&gt;2<br>  输出: false<br>示例 2:</p><p>  输入: 1-&gt;2-&gt;2-&gt;1<br>  输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目不是很难，但是要是用各种方法可能会出不少问题。<br>我用的方法是最简单的把数字放到数组当中，然后头尾双指针比较，相同即为回文。<br>但是中间转换的时候可能出了些问题，只支持-128到127的(谁家int这么小),之后用equals又莫名其妙对了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next;</span><br><span class="line"></span><br><span class="line">  ListNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">  List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">  while (head != null) &#123;</span><br><span class="line">    list.add(head.val);</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  int len = list.size();</span><br><span class="line">  Integer[] num = list.toArray(new Integer [len]);</span><br><span class="line">  for (int i = 0; i &lt;= len / 2; i++) &#123;</span><br><span class="line">    if (!num[i].equals(num[len - 1 - i])) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;234-Palindrome-Linked-List（回文链表）&quot;&gt;&lt;a href=&quot;#234-Palindrome-Linked-List（回文链表）&quot; class=&quot;headerlink&quot; title=&quot;234. Palindrome Linked List（
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 206. Reverse Linked List</title>
    <link href="https://cheng102e.github.io/LeetCode%20206.%20Reverse%20Linked%20List.html"/>
    <id>https://cheng102e.github.io/LeetCode 206. Reverse Linked List.html</id>
    <published>2020-03-18T03:00:00.000Z</published>
    <updated>2020-03-18T06:08:53.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="206-Reverse-Linked-List（反转链表）"><a href="#206-Reverse-Linked-List（反转链表）" class="headerlink" title="206. Reverse Linked List（反转链表）"></a>206. Reverse Linked List（反转链表）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>反转一个单链表。</p><p>示例:</p><p>  输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>  输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>算是迭代法吧，用pre存放前一个结点，用temp存放下一个结点，然后调换一下，最后输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"> </span><br><span class="line">  int val;</span><br><span class="line">  ListNode next;</span><br><span class="line"></span><br><span class="line">  ListNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">  ListNode pre = null;</span><br><span class="line">  ListNode cur = head;</span><br><span class="line">  while (cur != null) &#123;</span><br><span class="line">    ListNode temp = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;206-Reverse-Linked-List（反转链表）&quot;&gt;&lt;a href=&quot;#206-Reverse-Linked-List（反转链表）&quot; class=&quot;headerlink&quot; title=&quot;206. Reverse Linked List（反转链表）&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 160. Intersection of Two Linked Lists</title>
    <link href="https://cheng102e.github.io/LeetCode%20160.%20Intersection%20of%20Two%20Linked%20Lists.html"/>
    <id>https://cheng102e.github.io/LeetCode 160. Intersection of Two Linked Lists.html</id>
    <published>2020-03-17T06:00:00.000Z</published>
    <updated>2020-03-17T14:27:27.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="160-Intersection-of-Two-Linked-Lists（相交链表）"><a href="#160-Intersection-of-Two-Linked-Lists（相交链表）" class="headerlink" title="160. Intersection of Two Linked Lists（相交链表）"></a>160. Intersection of Two Linked Lists（相交链表）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>示例 1：</p><p>  输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>  输出：Reference of the node with value = 8<br>  输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>  输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>  输出：Reference of the node with value = 2<br>  输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>  输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>  输出：null<br>  输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>  解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>  如果两个链表没有交点，返回 null.<br>  在返回结果后，两个链表仍须保持原有的结构。<br>  可假定整个链表结构中没有循环。<br>  程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设两个链表长度为a+x和b+x，x就是相同部分，那么首先两个结点都从头结点开始，当自己的链表遍历完后跳到另外一个链表头，当每个节点都走a+b+x步之后，两个链表应该相遇在交点处。若不相交，最后都是null。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next;</span><br><span class="line"></span><br><span class="line">  ListNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">    next = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line"></span><br><span class="line">  if (headA == null || headB == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode pA = headA, pB = headB;</span><br><span class="line">  while (pA != pB) &#123;</span><br><span class="line">    if (pA == null) &#123;</span><br><span class="line">      pA = headB;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pA = pA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pB == null) &#123;</span><br><span class="line">      pB = headA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pB = pB.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;160-Intersection-of-Two-Linked-Lists（相交链表）&quot;&gt;&lt;a href=&quot;#160-Intersection-of-Two-Linked-Lists（相交链表）&quot; class=&quot;headerlink&quot; title=&quot;160. Int
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1160. Find Words That Can Be Formed by Characters</title>
    <link href="https://cheng102e.github.io/LeetCode%201160.%20Find%20Words%20That%20Can%20Be%20Formed%20by%20Characters.html"/>
    <id>https://cheng102e.github.io/LeetCode 1160. Find Words That Can Be Formed by Characters.html</id>
    <published>2020-03-17T03:40:00.000Z</published>
    <updated>2020-03-17T06:00:26.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1160-Find-Words-That-Can-Be-Formed-by-Characters（拼写单词）"><a href="#1160-Find-Words-That-Can-Be-Formed-by-Characters（拼写单词）" class="headerlink" title="1160. Find Words That Can Be Formed by Characters（拼写单词）"></a>1160. Find Words That Can Be Formed by Characters（拼写单词）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p>示例 1：</p><p>  输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”<br>  输出：6<br>  解释：<br>  可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。<br>示例 2：</p><p>  输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”<br>  输出：10<br>  解释：<br>  可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。</p><p>提示：</p><p>  1 &lt;= words.length &lt;= 1000<br>  1 &lt;= words[i].length, chars.length &lt;= 100<br>  所有字符串中都仅包含小写英文字母</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>仅包含小写字母，那么就可以拿数组存储，之后比较单词中各个字母数量和给的字母数量，全部满足才能成立，最后统计一下长度即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> public int countCharacters(String[] words, String chars) &#123;</span><br><span class="line">  int[] num = new int[26];</span><br><span class="line">  int count = 0;</span><br><span class="line">  getnum(chars, num);</span><br><span class="line">  for (String s : words) &#123;</span><br><span class="line">    if (fit(s, num)) &#123;</span><br><span class="line">      count += s.length();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getnum(String chars, int[] num) &#123;</span><br><span class="line">  StringBuffer str = new StringBuffer(chars);</span><br><span class="line">  for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">    num[str.charAt(i) - &apos;a&apos;]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean fit(String word, int[] num) &#123;</span><br><span class="line">  int[] wordnum = new int[26];</span><br><span class="line">  getnum(word, wordnum);</span><br><span class="line">  boolean flag = true;</span><br><span class="line">  for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">    if (wordnum[i] &gt; num[i]) &#123;</span><br><span class="line">      flag = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1160-Find-Words-That-Can-Be-Formed-by-Characters（拼写单词）&quot;&gt;&lt;a href=&quot;#1160-Find-Words-That-Can-Be-Formed-by-Characters（拼写单词）&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 面试题 01.06. Compress String LCCI</title>
    <link href="https://cheng102e.github.io/LeetCode%20%E9%9D%A2%E8%AF%95%E9%A2%98%2001.06.%20Compress%20String%20LCCI.html"/>
    <id>https://cheng102e.github.io/LeetCode 面试题 01.06. Compress String LCCI.html</id>
    <published>2020-03-16T09:21:00.000Z</published>
    <updated>2020-03-17T03:41:16.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题-01-06-Compress-String-LCCI（字符串压缩）"><a href="#面试题-01-06-Compress-String-LCCI（字符串压缩）" class="headerlink" title="面试题 01.06. Compress String LCCI（字符串压缩）"></a>面试题 01.06. Compress String LCCI（字符串压缩）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/compress-string-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/compress-string-lcci</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><p>示例1:</p><p> 输入：”aabcccccaaa”<br> 输出：”a2b1c5a3”</p><p>示例2:</p><p> 输入：”abbccd”<br> 输出：”abbccd”<br> 解释：”abbccd”压缩后为”a1b2c2d1”，比原字符串长度更长。</p><p>提示：</p><p>  字符串长度在[0, 50000]范围内。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历一下就行了，先是传统艺能，判断一下是否成立，然后遍历字符串，若相同就数字加一，不同就更新字母，最后比较长度即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String compressString(String S) &#123;</span><br><span class="line">  if(S==null||S.length()==0)&#123;</span><br><span class="line">    return S;</span><br><span class="line">  &#125;</span><br><span class="line">  StringBuffer str = new StringBuffer(S);</span><br><span class="line">  StringBuffer ans = new StringBuffer();</span><br><span class="line">  int num=1;</span><br><span class="line">  char c = str.charAt(0);</span><br><span class="line">  for(int i=1;i&lt;str.length();i++)&#123;</span><br><span class="line">    if(str.charAt(i)==c)&#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      ans.append(c);</span><br><span class="line">      ans.append(num);</span><br><span class="line">      num=1;</span><br><span class="line">      c=str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans.append(c);</span><br><span class="line">  ans.append(num);</span><br><span class="line">  if(ans.length()&gt;=str.length())&#123;</span><br><span class="line">    return S;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    return ans.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题-01-06-Compress-String-LCCI（字符串压缩）&quot;&gt;&lt;a href=&quot;#面试题-01-06-Compress-String-LCCI（字符串压缩）&quot; class=&quot;headerlink&quot; title=&quot;面试题 01.06. Compres
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1038. Binary Search Tree to Greater Sum Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%201038.%20Binary%20Search%20Tree%20to%20Greater%20Sum%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 1038. Binary Search Tree to Greater Sum Tree.html</id>
    <published>2020-03-14T09:21:00.000Z</published>
    <updated>2020-03-14T09:53:50.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree（从二叉搜索树到更大和树）"><a href="#1038-Binary-Search-Tree-to-Greater-Sum-Tree（从二叉搜索树到更大和树）" class="headerlink" title="1038. Binary Search Tree to Greater Sum Tree（从二叉搜索树到更大和树）"></a>1038. Binary Search Tree to Greater Sum Tree（从二叉搜索树到更大和树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给出二叉 搜索 树的根节点，该二叉树的节点值各不相同，修改二叉树，使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p><p>示例：</p><p>  输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>  输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><p>提示：</p><p>树中的节点数介于 1 和 100 之间。<br>每个节点的值介于 0 和 100 之间。<br>给定的树为二叉搜索树。</p><p>注意：该题目与 538: <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a>  相同</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>偷了个懒，代码和538的是一样的。<br>直接递归，新建一个sum拿来存储值，然后修改结点值，这里记得右中左的方式。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line"></span><br><span class="line">public TreeNode bstToGst(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line"></span><br><span class="line">    bstToGst(root.right);</span><br><span class="line">    sum += root.val;</span><br><span class="line">    root.val = sum;</span><br><span class="line">    bstToGst(root.left);</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1038-Binary-Search-Tree-to-Greater-Sum-Tree（从二叉搜索树到更大和树）&quot;&gt;&lt;a href=&quot;#1038-Binary-Search-Tree-to-Greater-Sum-Tree（从二叉搜索树到更大和树）&quot; class=
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 538. Convert BST to Greater Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20538.%20Convert%20BST%20to%20Greater%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 538. Convert BST to Greater Tree.html</id>
    <published>2020-03-14T09:20:00.000Z</published>
    <updated>2020-03-14T09:19:52.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="538-Convert-BST-to-Greater-Tree（把二叉搜索树转换为累加树）"><a href="#538-Convert-BST-to-Greater-Tree（把二叉搜索树转换为累加树）" class="headerlink" title="538. Convert BST to Greater Tree（把二叉搜索树转换为累加树）"></a>538. Convert BST to Greater Tree（把二叉搜索树转换为累加树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：</p><p>输入: 原始二叉搜索树:<br>              5<br>            /   <br>           2     13</p><p>输出: 转换为累加树:<br>             18<br>            /   <br>          20     13</p><p>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接递归，新建一个sum拿来存储值，然后修改结点值，这里记得右中左的方式。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line"></span><br><span class="line">public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line"></span><br><span class="line">    convertBST(root.right);</span><br><span class="line">    sum += root.val;</span><br><span class="line">    root.val = sum;</span><br><span class="line">    convertBST(root.left);</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;538-Convert-BST-to-Greater-Tree（把二叉搜索树转换为累加树）&quot;&gt;&lt;a href=&quot;#538-Convert-BST-to-Greater-Tree（把二叉搜索树转换为累加树）&quot; class=&quot;headerlink&quot; title=&quot;53
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 141. Linked List Cycle</title>
    <link href="https://cheng102e.github.io/LeetCode%20141.%20Linked%20List%20Cycle.html"/>
    <id>https://cheng102e.github.io/LeetCode 141. Linked List Cycle.html</id>
    <published>2020-03-14T07:40:00.000Z</published>
    <updated>2020-03-14T08:17:22.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="141-Linked-List-Cycle（环形链表）"><a href="#141-Linked-List-Cycle（环形链表）" class="headerlink" title="141. Linked List Cycle（环形链表）"></a>141. Linked List Cycle（环形链表）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><p>  输入：head = [3,2,0,-4], pos = 1<br>  输出：true<br>  解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：</p><p>  输入：head = [1,2], pos = 0<br>  输出：true<br>  解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：</p><p>  输入：head = [1], pos = -1<br>  输出：false<br>  解释：链表中没有环。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>快慢指针法，快的一次走两步，慢的一次走一步，每次的差值都是1步，如果快的能追上慢的，就代表成环。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next;</span><br><span class="line"></span><br><span class="line">  ListNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">    next = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">  if (head == null || head.next == null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode slow = head;</span><br><span class="line">  ListNode fast = head.next;</span><br><span class="line">  while (slow != fast) &#123;</span><br><span class="line">    if (fast.next == null || fast.next.next == null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;141-Linked-List-Cycle（环形链表）&quot;&gt;&lt;a href=&quot;#141-Linked-List-Cycle（环形链表）&quot; class=&quot;headerlink&quot; title=&quot;141. Linked List Cycle（环形链表）&quot;&gt;&lt;/a&gt;141.
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 155. Min Stack</title>
    <link href="https://cheng102e.github.io/LeetCode%20155.%20Min%20Stack.html"/>
    <id>https://cheng102e.github.io/LeetCode 155. Min Stack.html</id>
    <published>2020-03-14T03:40:00.000Z</published>
    <updated>2020-03-14T03:43:03.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="155-Min-Stack（最小栈）"><a href="#155-Min-Stack（最小栈）" class="headerlink" title="155. Min Stack（最小栈）"></a>155. Min Stack（最小栈）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br>示例:</p><p>  MinStack minStack = new MinStack();<br>  minStack.push(-2);<br>  minStack.push(0);<br>  minStack.push(-3);<br>  minStack.getMin();   –&gt; 返回 -3.<br>  minStack.pop();<br>  minStack.top();      –&gt; 返回 0.<br>  minStack.getMin();   –&gt; 返回 -2.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里用了两个栈，一个栈用于存放数据，一个栈用于存放最小值。<br>对于新的数据，如果x小于最小值栈的栈顶，那就将这个数字进入最小值栈，不然就将栈顶数字再入栈一次，出栈的时候两个一起出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Stack&lt;Integer&gt; stackdata;</span><br><span class="line"> Stack&lt;Integer&gt; stackmin;</span><br><span class="line"></span><br><span class="line">/* public MinStack() &#123;</span><br><span class="line">   stackdata = new Stack&lt;&gt;();</span><br><span class="line">   stackmin = new Stack&lt;&gt;();</span><br><span class="line"> &#125;*/</span><br><span class="line"></span><br><span class="line"> public void push(int x) &#123;</span><br><span class="line">   stackdata.push(x);</span><br><span class="line"></span><br><span class="line">   if (stackmin.empty()) &#123;</span><br><span class="line">     stackmin.push(x);</span><br><span class="line">   &#125; else if (x &lt; stackmin.peek()) &#123;</span><br><span class="line">     stackmin.push(x);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     stackmin.push(stackmin.peek());</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void pop() &#123;</span><br><span class="line">   if (!stackdata.empty()) &#123;</span><br><span class="line">     stackdata.pop();</span><br><span class="line">     stackmin.pop();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public int top() &#123;</span><br><span class="line">   return stackdata.peek();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public int getMin() &#123;</span><br><span class="line">   return stackmin.peek();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;155-Min-Stack（最小栈）&quot;&gt;&lt;a href=&quot;#155-Min-Stack（最小栈）&quot; class=&quot;headerlink&quot; title=&quot;155. Min Stack（最小栈）&quot;&gt;&lt;/a&gt;155. Min Stack（最小栈）&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 300. Longest Increasing Subsequence</title>
    <link href="https://cheng102e.github.io/LeetCode%20300.%20Longest%20Increasing%20Subsequence.html"/>
    <id>https://cheng102e.github.io/LeetCode 300. Longest Increasing Subsequence.html</id>
    <published>2020-03-14T01:58:00.000Z</published>
    <updated>2020-03-14T02:04:08.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="300-Longest-Increasing-Subsequence（最长上升子序列）"><a href="#300-Longest-Increasing-Subsequence（最长上升子序列）" class="headerlink" title="300. Longest Increasing Subsequence（最长上升子序列）"></a>300. Longest Increasing Subsequence（最长上升子序列）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>  输入: [10,9,2,5,3,7,101,18]<br>  输出: 4<br>  解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p><p>  可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>  你算法的时间复杂度应该为 O(n2) 。</p><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>n2的我是拿动态规划做的，但是nlogn我没什么思路，就没写。<br>增加一个dp数组，初始值为1，当遍历到第i个数时，比较前方的所有数，若比第i个数小，就可以构成上升子序列，找到最长的那个存储在dp中，最后输出最大值即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">  int len = nums.length;</span><br><span class="line">  if (len &lt;= 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] dp = new int[len];</span><br><span class="line">  dp[0] = 1;</span><br><span class="line">  int max = 1;</span><br><span class="line">  for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i] = 1;</span><br><span class="line">    for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">      if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[i] &gt; max) &#123;</span><br><span class="line">      max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;300-Longest-Increasing-Subsequence（最长上升子序列）&quot;&gt;&lt;a href=&quot;#300-Longest-Increasing-Subsequence（最长上升子序列）&quot; class=&quot;headerlink&quot; title=&quot;300. L
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 617. Merge Two Binary Trees</title>
    <link href="https://cheng102e.github.io/LeetCode%20617.%20Merge%20Two%20Binary%20Trees.html"/>
    <id>https://cheng102e.github.io/LeetCode 617. Merge Two Binary Trees.html</id>
    <published>2020-03-13T14:16:00.000Z</published>
    <updated>2020-03-14T01:59:07.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="617-Merge-Two-Binary-Trees（合并二叉树）"><a href="#617-Merge-Two-Binary-Trees（合并二叉树）" class="headerlink" title="617. Merge Two Binary Trees（合并二叉树）"></a>617. Merge Two Binary Trees（合并二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和前面几道树的题相似，都借助了递归。<br>这里将t2加到t1上，若某一个为空，就接入不为空的，都不为空，就将数值相加。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;</span><br><span class="line">  if (t1 == null) &#123;</span><br><span class="line">    return t2;</span><br><span class="line">  &#125;if (t2 == null) &#123;</span><br><span class="line">    return t1;</span><br><span class="line">  &#125;</span><br><span class="line">  t1.val += t2.val;</span><br><span class="line">  t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">  t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">  return t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;617-Merge-Two-Binary-Trees（合并二叉树）&quot;&gt;&lt;a href=&quot;#617-Merge-Two-Binary-Trees（合并二叉树）&quot; class=&quot;headerlink&quot; title=&quot;617. Merge Two Binary Tree
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 226. Invert Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20226.%20Invert%20Binary%20Tree%20copy.html"/>
    <id>https://cheng102e.github.io/LeetCode 226. Invert Binary Tree copy.html</id>
    <published>2020-03-13T11:16:00.000Z</published>
    <updated>2020-03-13T12:03:51.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="226-Invert-Binary-Tree（翻转二叉树）"><a href="#226-Invert-Binary-Tree（翻转二叉树）" class="headerlink" title="226. Invert Binary Tree（翻转二叉树）"></a>226. Invert Binary Tree（翻转二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>输出：</p><pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单题目，对于每一个结点，都交换左右子节点，然后交换完整棵树就结束了。设置一个临时结点，然后递归即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    if (root.left != null) &#123;</span><br><span class="line">      invertTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null) &#123;</span><br><span class="line">      invertTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;226-Invert-Binary-Tree（翻转二叉树）&quot;&gt;&lt;a href=&quot;#226-Invert-Binary-Tree（翻转二叉树）&quot; class=&quot;headerlink&quot; title=&quot;226. Invert Binary Tree（翻转二叉树）&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 226. Invert Binary Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20226.%20Invert%20Binary%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 226. Invert Binary Tree.html</id>
    <published>2020-03-13T11:16:00.000Z</published>
    <updated>2020-03-13T11:58:52.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="226-Invert-Binary-Tree（翻转二叉树）"><a href="#226-Invert-Binary-Tree（翻转二叉树）" class="headerlink" title="226. Invert Binary Tree（翻转二叉树）"></a>226. Invert Binary Tree（翻转二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>输出：</p><pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单题目，对于每一个结点，都交换左右子节点，然后交换完整棵树就结束了。设置一个临时结点，然后递归即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">  if (root != null) &#123;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    if (root.left != null) &#123;</span><br><span class="line">      invertTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null) &#123;</span><br><span class="line">      invertTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;226-Invert-Binary-Tree（翻转二叉树）&quot;&gt;&lt;a href=&quot;#226-Invert-Binary-Tree（翻转二叉树）&quot; class=&quot;headerlink&quot; title=&quot;226. Invert Binary Tree（翻转二叉树）&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 101. Symmetric Tree</title>
    <link href="https://cheng102e.github.io/LeetCode%20101.%20Symmetric%20Tree.html"/>
    <id>https://cheng102e.github.io/LeetCode 101. Symmetric Tree.html</id>
    <published>2020-03-13T07:16:00.000Z</published>
    <updated>2020-03-13T07:15:39.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="101-Symmetric-Tree（对称二叉树）"><a href="#101-Symmetric-Tree（对称二叉树）" class="headerlink" title="101. Symmetric Tree（对称二叉树）"></a>101. Symmetric Tree（对称二叉树）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>1</code></pre><p>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>1</code></pre><p>   / <br>  2   2<br>   \   <br>   3    3<br>说明:</p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>树的题目，尤其是二叉树，用递归和迭代都能减少运算量，这里用递归。<br>首先是根节点的判断，为空那么符合，之后就是递归过程，先查看左右子节点，相同的话继续比较左子树左节点和右子树右节点，左子树右节点和右子树左节点，如果不同，直接false。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean test(TreeNode l, TreeNode r) &#123;</span><br><span class="line">  if (l == null &amp;&amp; r == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (l == null || r == null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (l.val == r.val) &#123;</span><br><span class="line">    return test(l.left, r.right) &amp;&amp; test(l.right, r.left);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return test(root.left, root.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;101-Symmetric-Tree（对称二叉树）&quot;&gt;&lt;a href=&quot;#101-Symmetric-Tree（对称二叉树）&quot; class=&quot;headerlink&quot; title=&quot;101. Symmetric Tree（对称二叉树）&quot;&gt;&lt;/a&gt;101. Symme
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 21. Merge Two Sorted Lists</title>
    <link href="https://cheng102e.github.io/LeetCode%2021.%20Merge%20Two%20Sorted%20Lists.html"/>
    <id>https://cheng102e.github.io/LeetCode 21. Merge Two Sorted Lists.html</id>
    <published>2020-03-13T06:46:00.000Z</published>
    <updated>2020-03-13T06:52:56.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-Merge-Two-Sorted-Lists（合并两个有序链表）"><a href="#21-Merge-Two-Sorted-Lists（合并两个有序链表）" class="headerlink" title="21. Merge Two Sorted Lists（合并两个有序链表）"></a>21. Merge Two Sorted Lists（合并两个有序链表）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>  输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>  输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单的链表题目，可以循环做，也可以递归做，这里采用的是递归。<br>如果结点为空，那么后面就不用继续判断，直接加到尾部即可，不然的话就需要比较两个结点的大小，小的加入，大的继续运算。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line"></span><br><span class="line">  int val;</span><br><span class="line">  ListNode next;</span><br><span class="line"></span><br><span class="line">  ListNode(int x) &#123;</span><br><span class="line">    val = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">  if (l1 == null) &#123;</span><br><span class="line">    return l2;</span><br><span class="line">  &#125;</span><br><span class="line">  if (l2 == null) &#123;</span><br><span class="line">    return l1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(l1.val&lt;l2.val)&#123;</span><br><span class="line">    l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">    return l1;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">    return l2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-Merge-Two-Sorted-Lists（合并两个有序链表）&quot;&gt;&lt;a href=&quot;#21-Merge-Two-Sorted-Lists（合并两个有序链表）&quot; class=&quot;headerlink&quot; title=&quot;21. Merge Two Sorted L
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1071. Greatest Common Divisor of Strings</title>
    <link href="https://cheng102e.github.io/LeetCode%201071.%20Greatest%20Common%20Divisor%20of%20Strings.html"/>
    <id>https://cheng102e.github.io/LeetCode 1071. Greatest Common Divisor of Strings.html</id>
    <published>2020-03-11T03:29:00.000Z</published>
    <updated>2020-03-12T03:51:07.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1071-Greatest-Common-Divisor-of-Strings（字符串的最大公因子）"><a href="#1071-Greatest-Common-Divisor-of-Strings（字符串的最大公因子）" class="headerlink" title="1071. Greatest Common Divisor of Strings（字符串的最大公因子）"></a>1071. Greatest Common Divisor of Strings（字符串的最大公因子）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-common-divisor-of-strings</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p>示例 1：</p><p>  输入：str1 = “ABCABC”, str2 = “ABC”<br>  输出：”ABC”<br>示例 2：</p><p>  输入：str1 = “ABABAB”, str2 = “ABAB”<br>  输出：”AB”<br>示例 3：</p><p>  输入：str1 = “LEET”, str2 = “CODE”<br>  输出：””</p><p>提示：</p><p>  1 &lt;= str1.length &lt;= 1000<br>  1 &lt;= str2.length &lt;= 1000<br>  str1[i] 和 str2[i] 为大写英文字母</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>算是数学题吧，如果str1+str2和str2+str1相同的话，那就存在想要求的公约数，并且长度就已经知道了，就是字符串长度的公约数，只需要输出长的字符串截取的那部分即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int gcd(int a, int b) &#123;</span><br><span class="line">  if (b == 0) &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return gcd(b, a % b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String gcdOfStrings(String str1, String str2) &#123;</span><br><span class="line">  if ((str1 + str2).equals(str2 + str1)) &#123;</span><br><span class="line">    return str1.substring(0, gcd(str1.length(), str2.length()));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1071-Greatest-Common-Divisor-of-Strings（字符串的最大公因子）&quot;&gt;&lt;a href=&quot;#1071-Greatest-Common-Divisor-of-Strings（字符串的最大公因子）&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1013. Partition Array Into Three Parts With Equal Sum</title>
    <link href="https://cheng102e.github.io/LeetCode%201013.%20Partition%20Array%20Into%20Three%20Parts%20With%20Equal%20Sum.html"/>
    <id>https://cheng102e.github.io/LeetCode 1013. Partition Array Into Three Parts With Equal Sum.html</id>
    <published>2020-03-11T01:29:00.000Z</published>
    <updated>2020-03-11T02:16:28.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1013-Partition-Array-Into-Three-Parts-With-Equal-Sum（将数组分成和相等的三个部分）"><a href="#1013-Partition-Array-Into-Three-Parts-With-Equal-Sum（将数组分成和相等的三个部分）" class="headerlink" title="1013. Partition Array Into Three Parts With Equal Sum（将数组分成和相等的三个部分）"></a>1013. Partition Array Into Three Parts With Equal Sum（将数组分成和相等的三个部分）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p><p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p><p>示例 1：</p><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1<br>示例 2：</p><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false<br>示例 3：</p><p>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p><p>提示：</p><p>3 &lt;= A.length &lt;= 50000<br>-10^4 &lt;= A[i] &lt;= 10^4</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>普通的数组题，最多多挖了几个坑。<br>首先统计整个数组的和，如果能被三整除就进行下一步。<br>从前从后同时开始，如果部分和等于总数的三分之一，那么就不在前进，等到两边都为1/3，中间自然也是1/3.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean canThreePartsEqualSum(int[] A) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (int i = 0; i &lt; A.length; i++) &#123;</span><br><span class="line">    sum += A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  if (sum % 3 != 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = sum / 3;</span><br><span class="line">  int suma = A[0], sumc = A[A.length - 1];</span><br><span class="line">  int i = 1, j = A.length - 2;</span><br><span class="line">  while (i &lt; j) &#123;</span><br><span class="line">    if (suma != sum) &#123;</span><br><span class="line">      suma += A[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    if (sumc != sum) &#123;</span><br><span class="line">      sumc += A[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    if (suma == sum &amp;&amp; sumc == sum &amp;&amp; i &lt;= j) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1013-Partition-Array-Into-Three-Parts-With-Equal-Sum（将数组分成和相等的三个部分）&quot;&gt;&lt;a href=&quot;#1013-Partition-Array-Into-Three-Parts-With-Equal-Sum（
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 322. Coin Change</title>
    <link href="https://cheng102e.github.io/LeetCode%20322.%20Coin%20Change.html"/>
    <id>https://cheng102e.github.io/LeetCode 322. Coin Change.html</id>
    <published>2020-03-08T13:29:00.000Z</published>
    <updated>2020-03-09T02:41:01.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="322-Coin-Change（零钱兑换）"><a href="#322-Coin-Change（零钱兑换）" class="headerlink" title="322. Coin Change（零钱兑换）"></a>322. Coin Change（零钱兑换）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>示例 1:</p><p>  输入: coins = [1, 2, 5], amount = 11<br>  输出: 3<br>  解释: 11 = 5 + 5 + 1</p><p>示例 2:</p><p>  输入: coins = [2], amount = 3<br>  输出: -1</p><p>说明:<br>  你可以认为每种硬币的数量是无限的。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划题目，设置一个dp数组用于存储中间结果，外层循环的i就代表金额的数量，内层代表硬币，状态转移方程是dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)，</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">  if (coins.length == 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] dp = new int[amount + 1];</span><br><span class="line">  dp[0] = 0;</span><br><span class="line">  for (int i = 1; i &lt;= amount; i++) &#123;</span><br><span class="line">    dp[i] = amount + 1;</span><br><span class="line">    for (int j = 0; j &lt; coins.length; j++) &#123;</span><br><span class="line">      if (i &gt;= coins[j]) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (dp[amount] == amount + 1) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;322-Coin-Change（零钱兑换）&quot;&gt;&lt;a href=&quot;#322-Coin-Change（零钱兑换）&quot; class=&quot;headerlink&quot; title=&quot;322. Coin Change（零钱兑换）&quot;&gt;&lt;/a&gt;322. Coin Change（零钱兑换）
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 0.n个骰子的点数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%200.n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 0.n个骰子的点数.html</id>
    <published>2020-03-07T02:40:00.000Z</published>
    <updated>2020-03-07T02:38:42.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer-0-n个骰子的点数"><a href="#剑指offer-0-n个骰子的点数" class="headerlink" title="剑指offer 0.n个骰子的点数"></a>剑指offer 0.n个骰子的点数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p>示例 1:</p><p>  输入: 1<br>  输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]<br>示例 2:</p><p>  输入: 2<br>  输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</p><p>限制：</p><p>  1 &lt;= n &lt;= 11</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题本来是在书里面的，但是牛客上面没有，所以我就去LeetCode做了这道题。<br>动态规划方法，用dp[i][j]来存储出现的次数，i表示骰子的个数，j表示点数。<br>dp[i][j]=dp[i-1][j-1]+dp[i-1][j-2]+dp[i-1][j-3]+dp[i-1][j-4]+dp[i-1][j-5]+dp[i-1][j-6],设置循环即可。<br>(剑指offer这本书到这就算刷完了)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public double[] twoSum(int n) &#123;</span><br><span class="line">  int[][] dp = new int[n + 1][6 * n + 1];</span><br><span class="line">  double[] ans = new double[5 * n + 1];</span><br><span class="line">  double all = Math.pow(6, n);</span><br><span class="line">  for (int i = 1; i &lt;= 6; i++) &#123;</span><br><span class="line">    dp[1][i] = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    for (int j = i; j &lt;= 6 * n; j++) &#123;</span><br><span class="line">      for (int k = 1; k &lt;= 6; k++) &#123;</span><br><span class="line">        dp[i][j] += j &gt;= k ? dp[i - 1][j - k] : 0;</span><br><span class="line">        if (i == n) &#123;</span><br><span class="line">          ans[j - i] = dp[i][j] / all;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剑指offer-0-n个骰子的点数&quot;&gt;&lt;a href=&quot;#剑指offer-0-n个骰子的点数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer 0.n个骰子的点数&quot;&gt;&lt;/a&gt;剑指offer 0.n个骰子的点数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
