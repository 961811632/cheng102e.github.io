<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cheng102e的博客</title>
  
  <subtitle>缘何不懂，坚持不懈磨砺精炼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cheng102e.github.io/"/>
  <updated>2020-02-27T10:25:15.855Z</updated>
  <id>https://cheng102e.github.io/</id>
  
  <author>
    <name>cheng102e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 213. House Robber II</title>
    <link href="https://cheng102e.github.io/LeetCode%20213.%20House%20Robber%20II.html"/>
    <id>https://cheng102e.github.io/LeetCode 213. House Robber II.html</id>
    <published>2020-02-27T10:23:00.000Z</published>
    <updated>2020-02-27T10:25:15.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="213-House-Robber-II（打家劫舍-II）"><a href="#213-House-Robber-II（打家劫舍-II）" class="headerlink" title="213. House Robber II（打家劫舍 II）"></a>213. House Robber II（打家劫舍 II）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/house-robber-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-ii</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。<br>示例 2:</p><p>输入: [1,2,3,1]<br>输出: 4<br>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划，对于第三间之后的房子，有拿或者不拿两种选择，如果选择拿，那么前一间房子就不能拿，这样可以得到状态转移方程dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])，还要考虑到一点就是，第一个和最后一个不能都拿，可以考虑设两个方程，第一个是1到n-1，第二个是2到n，选最大值即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">  int[] dp_0 = new int[nums.length];</span><br><span class="line">  int[] dp_1 = new int[nums.length];</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (nums.length == 1) &#123;</span><br><span class="line">    return nums[0];</span><br><span class="line">  &#125;</span><br><span class="line">  if (nums.length == 2) &#123;</span><br><span class="line">    return Math.max(nums[0], nums[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  dp_0[0] = nums[0];</span><br><span class="line">  dp_0[1] = Math.max(nums[0], nums[1]);</span><br><span class="line">  for (int i = 2; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">    dp_0[i] = Math.max(dp_0[i - 1], dp_0[i - 2] + nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  dp_1[1] = nums[1];</span><br><span class="line">  dp_1[2] = Math.max(nums[1], nums[2]);</span><br><span class="line">  for (int i = 3; i &lt; nums.length; i++) &#123;</span><br><span class="line">    dp_1[i] = Math.max(dp_1[i - 1], dp_1[i - 2] + nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(dp_0[nums.length - 2], dp_1[nums.length - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;213-House-Robber-II（打家劫舍-II）&quot;&gt;&lt;a href=&quot;#213-House-Robber-II（打家劫舍-II）&quot; class=&quot;headerlink&quot; title=&quot;213. House Robber II（打家劫舍 II）&quot;&gt;&lt;/a&gt;2
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 198. House Robber</title>
    <link href="https://cheng102e.github.io/LeetCode%20198.%20House%20Robber.html"/>
    <id>https://cheng102e.github.io/LeetCode 198. House Robber.html</id>
    <published>2020-02-27T09:55:00.000Z</published>
    <updated>2020-02-27T10:04:30.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="198-House-Robber（打家劫舍）"><a href="#198-House-Robber（打家劫舍）" class="headerlink" title="198. House Robber（打家劫舍）"></a>198. House Robber（打家劫舍）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><p>  输入: [1,2,3,1]<br>  输出: 4<br>  解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>       偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 2:</p><p>  输入: [2,7,9,3,1]<br>  输出: 12<br>  解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>       偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>标准的动态规划题目，对于第三间之后的房子，有拿或者不拿两种选择，如果选择拿，那么前一间房子就不能拿，这样可以得到状态转移方程dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])，之后循环得到答案即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">  int[] dp = new int[nums.length];</span><br><span class="line">  if (nums.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (nums.length == 1) &#123;</span><br><span class="line">    return nums[0];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[0] = nums[0];</span><br><span class="line">  dp[1] = Math.max(nums[0], nums[1]);</span><br><span class="line">  for (int i = 2; i &lt; nums.length; i++) &#123;</span><br><span class="line">    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[nums.length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;198-House-Robber（打家劫舍）&quot;&gt;&lt;a href=&quot;#198-House-Robber（打家劫舍）&quot; class=&quot;headerlink&quot; title=&quot;198. House Robber（打家劫舍）&quot;&gt;&lt;/a&gt;198. House Robber（打
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 303. Range Sum Query - Immutable</title>
    <link href="https://cheng102e.github.io/LeetCode%20303.%20Range%20Sum%20Query%20-%20Immutable.html"/>
    <id>https://cheng102e.github.io/LeetCode 303. Range Sum Query - Immutable.html</id>
    <published>2020-02-27T09:33:00.000Z</published>
    <updated>2020-02-27T09:29:01.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="303-Range-Sum-Query-Immutable（区域和检索-数组不可变）"><a href="#303-Range-Sum-Query-Immutable（区域和检索-数组不可变）" class="headerlink" title="303. Range Sum Query - Immutable（区域和检索 - 数组不可变）"></a>303. Range Sum Query - Immutable（区域和检索 - 数组不可变）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-query-immutable</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：</p><p>  给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</p><p>  sumRange(0, 2) -&gt; 1<br>  sumRange(2, 5) -&gt; -1<br>  sumRange(0, 5) -&gt; -3<br>说明:</p><p>你可以假设数组不可变。<br>会多次调用 sumRange 方法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于需要多次调用，建议面向答案编程，先建立一个sum数组，存放从开头到这个数的和，若要(i,j)那么就用sum[j]-sum[i-1]即可。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private int[] sum;</span><br><span class="line"></span><br><span class="line">public void NumArray(int[] nums) &#123;</span><br><span class="line">  if(nums.length==0)</span><br><span class="line">  &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = new int[nums.length];</span><br><span class="line">  sum[0] = nums[0];</span><br><span class="line">  for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">    sum[i] += sum[i - 1] + nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sumRange(int i, int j) &#123;</span><br><span class="line">  if (i == 0) &#123;</span><br><span class="line">    return sum[j];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return sum[j] - sum[i - 1];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;303-Range-Sum-Query-Immutable（区域和检索-数组不可变）&quot;&gt;&lt;a href=&quot;#303-Range-Sum-Query-Immutable（区域和检索-数组不可变）&quot; class=&quot;headerlink&quot; title=&quot;303. Ran
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://cheng102e.github.io/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"/>
    <id>https://cheng102e.github.io/算法-动态规划.html</id>
    <published>2020-02-27T05:00:00.000Z</published>
    <updated>2020-02-27T08:41:16.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分治法：将问题划分为不相交的子问题,递归的求解子问题,在将它们的解组合起来,求出原问题的解。</p><p>动态规划：通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划和递归的最大的区别，就是在碰到重叠子问题时，是否只需要计算一次。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>拆分子问题，把整体问题拆成可以用递推或是递归实现的小问题，在某一状态下最佳选择是什么</li><li>定义问题和状态之间的关系，寻找到状态转移方程</li><li>进行编码</li></ol><h3 id="例题-LeetCode746"><a href="#例题-LeetCode746" class="headerlink" title="例题(LeetCode746)"></a>例题(LeetCode746)</h3><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p>示例 1:</p><pre><code>输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</code></pre><p>示例 2:</p><pre><code>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</code></pre><p>注意：</p><p>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>上升到某级(i)有两种方法，从i-1级上一步，从i-2级上两步，那么就可以知道状态转移方程了<br>dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]，顺着这个思路从3开始，最后再输出一下就行。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">  int len = cost.length;</span><br><span class="line">  int dp[] = new int[len + 1];</span><br><span class="line"></span><br><span class="line">  dp[0] = cost[0];</span><br><span class="line">  dp[1] = cost[1];</span><br><span class="line">  for (int i = 2; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.min(dp[len - 1], dp[len - 2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://cheng102e.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 746. Min Cost Climbing Stairs</title>
    <link href="https://cheng102e.github.io/LeetCode%20746.%20Min%20Cost%20Climbing%20Stairs.html"/>
    <id>https://cheng102e.github.io/LeetCode 746. Min Cost Climbing Stairs.html</id>
    <published>2020-02-27T04:33:00.000Z</published>
    <updated>2020-02-27T09:27:09.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="746-Min-Cost-Climbing-Stairs-（使用最小花费爬楼梯）"><a href="#746-Min-Cost-Climbing-Stairs-（使用最小花费爬楼梯）" class="headerlink" title="746. Min Cost Climbing Stairs （使用最小花费爬楼梯）"></a>746. Min Cost Climbing Stairs （使用最小花费爬楼梯）</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-cost-climbing-stairs</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p>示例 1:</p><pre><code>输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</code></pre><p>示例 2:</p><pre><code>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</code></pre><p>注意：</p><p>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划题目，上升到某级(i)有两种方法，从i-1级上一步，从i-2级上两步，那么就可以知道状态转移方程了<br>dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]，顺着这个思路从3开始，最后再输出一下就行。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">  int len = cost.length;</span><br><span class="line">  int dp[] = new int[len + 1];</span><br><span class="line"></span><br><span class="line">  dp[0] = cost[0];</span><br><span class="line">  dp[1] = cost[1];</span><br><span class="line">  for (int i = 2; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.min(dp[len - 1], dp[len - 2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;746-Min-Cost-Climbing-Stairs-（使用最小花费爬楼梯）&quot;&gt;&lt;a href=&quot;#746-Min-Cost-Climbing-Stairs-（使用最小花费爬楼梯）&quot; class=&quot;headerlink&quot; title=&quot;746. Min Cos
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://cheng102e.github.io/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="https://cheng102e.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 12.数值的整数次方</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2012.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html"/>
    <id>https://cheng102e.github.io/剑指offer 12.数值的整数次方.html</id>
    <published>2020-02-26T14:17:00.000Z</published>
    <updated>2020-02-27T14:07:53.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>问题也不是很大，如果不是要求效率就可以直接分类讨论，一个循环解决，要求效率的话就要用快速幂，我没用快速幂，就分类讨论了一下，最后输出结果。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">  if (exponent == 0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (base == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  double ans = 1;</span><br><span class="line">  boolean flag = false;</span><br><span class="line">  if (exponent &gt; 0) &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    flag = false;</span><br><span class="line">    exponent = -exponent;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 1; i &lt;= exponent; i++) &#123;</span><br><span class="line">    ans = ans * base;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!flag) &#123;</span><br><span class="line">    ans = 1.0 / ans;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;12-数值的整数次方&quot;&gt;&lt;a href=&quot;#12-数值的整数次方&quot; class=&quot;headerlink&quot; title=&quot;12.数值的整数次方&quot;&gt;&lt;/a&gt;12.数值的整数次方&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 11.二进制中1的个数</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2011.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://cheng102e.github.io/剑指offer 11.二进制中1的个数.html</id>
    <published>2020-02-26T10:17:00.000Z</published>
    <updated>2020-02-26T10:34:36.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对我来说蛮难的，虽然解法有多种吧。<br>一开始想的就是直接转二进制字符串遍历，简单，但是这题本意应该是位运算，这方面我不是很熟。<br>把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。这句话是书上的，每次运算都把一个1变成0，当成为0的时候运算的次数就是1的数量。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">  int count = 0;</span><br><span class="line"></span><br><span class="line">  while (n != 0) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    n = (n - 1) &amp; n;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-二进制中1的个数&quot;&gt;&lt;a href=&quot;#11-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;11.二进制中1的个数&quot;&gt;&lt;/a&gt;11.二进制中1的个数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;head
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="位运算" scheme="https://cheng102e.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 9.变态跳台阶</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%209.%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.html"/>
    <id>https://cheng102e.github.io/剑指offer 9.变态跳台阶.html</id>
    <published>2020-02-26T08:17:00.000Z</published>
    <updated>2020-02-26T08:22:49.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与上题相似，假设要到3级，那么可以从0，1，2级直接到三级，那么f3=f1+f2+1，f2=f1+1，f3=4，找规律。<br>也可以换一种思路，不限制长度，那就是每一级都可以跳，只有选择跳和不跳，那么就是2^(n-1)，结果一样。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int JumpFloor(int target) &#123;</span><br><span class="line">  if (target &lt;= 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if(target==1)</span><br><span class="line">  &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (target==2)</span><br><span class="line">  &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  int f[] = new int[target + 1];</span><br><span class="line">  f[1] = 1;</span><br><span class="line">  f[2] = 2;</span><br><span class="line">  for (int i = 3; i &lt;= target; i++) &#123;</span><br><span class="line">    f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">  &#125;</span><br><span class="line">  return f[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;9-变态跳台阶&quot;&gt;&lt;a href=&quot;#9-变态跳台阶&quot; class=&quot;headerlink&quot; title=&quot;9.变态跳台阶&quot;&gt;&lt;/a&gt;9.变态跳台阶&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 10.矩形覆盖</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%2010.%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.html"/>
    <id>https://cheng102e.github.io/剑指offer 10.矩形覆盖.html</id>
    <published>2020-02-26T08:17:00.000Z</published>
    <updated>2020-02-26T09:42:49.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>比如n=3时，2*3的矩形块有3种覆盖方法：</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>还是斐波那契数列，2<em>2的矩阵有两种方法填装，3\</em>2的就是3种方法，n*2的就是n-1和n-2的方法的和</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int JumpFloor(int target) &#123;</span><br><span class="line">  if (target &lt;= 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if(target==1)</span><br><span class="line">  &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (target==2)</span><br><span class="line">  &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  int f[] = new int[target + 1];</span><br><span class="line">  f[1] = 1;</span><br><span class="line">  f[2] = 2;</span><br><span class="line">  for (int i = 3; i &lt;= target; i++) &#123;</span><br><span class="line">    f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">  &#125;</span><br><span class="line">  return f[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;10-矩形覆盖&quot;&gt;&lt;a href=&quot;#10-矩形覆盖&quot; class=&quot;headerlink&quot; title=&quot;10.矩形覆盖&quot;&gt;&lt;/a&gt;10.矩形覆盖&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 7.斐波那契数列</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%207.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 7.斐波那契数列.html</id>
    <published>2020-02-26T07:54:00.000Z</published>
    <updated>2020-02-26T07:56:16.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.斐波那契数列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这就是看下效率的，建议采用迭代，递归的耗时太长了，还有别的方法，比如公式法，比如面向答案编程的打表法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static  int Fibonacci(int n) &#123;</span><br><span class="line">  int a0 = 0;</span><br><span class="line">  int a1 = 1;</span><br><span class="line">  int a2 = 0;</span><br><span class="line">  if (n == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (n == 1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    a2 = a0 + a1;</span><br><span class="line">    a0 = a1;</span><br><span class="line">    a1 = a2;</span><br><span class="line">  &#125;</span><br><span class="line">  return a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7-斐波那契数列&quot;&gt;&lt;a href=&quot;#7-斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;7.斐波那契数列&quot;&gt;&lt;/a&gt;7.斐波那契数列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 8.跳台阶</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%208.%E8%B7%B3%E5%8F%B0%E9%98%B6.html"/>
    <id>https://cheng102e.github.io/剑指offer 8.跳台阶.html</id>
    <published>2020-02-26T07:54:00.000Z</published>
    <updated>2020-02-26T08:08:44.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和斐波那契算是一道题，只要转换一下得到f[i] = f[i - 1] + f[i - 2]即可，因为到达该级可以在前一级一步上来，在前两级两步上来。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int JumpFloor(int target) &#123;</span><br><span class="line">  if (target &lt;= 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if(target==1)</span><br><span class="line">  &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (target==2)</span><br><span class="line">  &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  int f[] = new int[target + 1];</span><br><span class="line">  f[1] = 1;</span><br><span class="line">  f[2] = 2;</span><br><span class="line">  for (int i = 3; i &lt;= target; i++) &#123;</span><br><span class="line">    f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">  &#125;</span><br><span class="line">  return f[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;8-跳台阶&quot;&gt;&lt;a href=&quot;#8-跳台阶&quot; class=&quot;headerlink&quot; title=&quot;8.跳台阶&quot;&gt;&lt;/a&gt;8.跳台阶&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 6.旋转数组的最小数字</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%206.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 6.旋转数组的最小数字.html</id>
    <published>2020-02-26T07:35:00.000Z</published>
    <updated>2020-02-26T07:46:25.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目有个坑的地方，就是这里是非递减排序，所以可能相同。<br>直接找就是O(n)，但是这题显然是让人进行二分查找的，所以采用二分查找的格式。<br>与正常二分查找不同，如果左侧等于右侧，就只能一个一个找，到那时候直接用个循环就可以了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int minNumberInRotateArray(int[] array) &#123;</span><br><span class="line">  if (array.length == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int left = 0;</span><br><span class="line">  int right = array.length - 1;</span><br><span class="line"></span><br><span class="line">  while (array[left] &gt;= array[right]) &#123;</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line">    if (array[mid] &gt; array[right]) &#123;</span><br><span class="line">      left = mid + 1;</span><br><span class="line">    &#125; else if (array[mid] == array[right]) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125; else if (array[mid] &lt; array[right]) &#123;</span><br><span class="line">      right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return array[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;6-旋转数组的最小数字&quot;&gt;&lt;a href=&quot;#6-旋转数组的最小数字&quot; class=&quot;headerlink&quot; title=&quot;6.旋转数组的最小数字&quot;&gt;&lt;/a&gt;6.旋转数组的最小数字&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;head
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 5.用两个栈实现队列</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%205.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html"/>
    <id>https://cheng102e.github.io/剑指offer 5.用两个栈实现队列.html</id>
    <published>2020-02-26T07:10:00.000Z</published>
    <updated>2020-02-26T07:13:45.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>栈是先进后出，队列是先进先出，两个栈，那么负负得正，就可以得到先进先出。<br>入栈就直接使用第一个栈，栈内关系有序，出栈时，若第二个栈为空，就将第一个栈转移到第二个栈，先进第一个栈后出第一个栈后进第二个栈，先出第一个栈，方向调过来了。若第二个栈不为空，那就输出第二个栈的顶端，顺序一样的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">public void push(int node) &#123;</span><br><span class="line">  stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int pop() &#123;</span><br><span class="line">  if (stack2.empty()) &#123;</span><br><span class="line">    while (!stack1.empty()) &#123;</span><br><span class="line">      int temp = stack1.pop();</span><br><span class="line">      stack2.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int temp = stack2.peek();</span><br><span class="line">  stack2.pop();</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;5-用两个栈实现队列&quot;&gt;&lt;a href=&quot;#5-用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;5.用两个栈实现队列&quot;&gt;&lt;/a&gt;5.用两个栈实现队列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 4.重建二叉树</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%204.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://cheng102e.github.io/剑指offer 4.重建二叉树.html</id>
    <published>2020-02-26T06:56:00.000Z</published>
    <updated>2020-02-26T07:11:16.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a>4.重建二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这就和二叉树的性质相关了，由前序和中序可以确定一棵树，前序的第一个就是树的根，然后中序找到这个根，在前面的就是左子树，在后面的就是右子树。然后就先不管别的，直接深挖，左子树的前序和中序都有那就能得到左子树的根节点，一层一层，如果长度为0就不存在，为null。<br>这里函数的输入是两个数组，递归的输入还是两个数组，所以截取数组计算，不然可以用索引值，效果一样。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123;</span><br><span class="line">  if (pre.length == 0 || in.length == 0) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode root = new TreeNode(pre[0]);</span><br><span class="line">  for (int i = 0; i &lt; in.length; i++) &#123;</span><br><span class="line">    if (pre[0] == in[i]) &#123;</span><br><span class="line">      root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1),</span><br><span class="line">          Arrays.copyOfRange(in, 0, i));</span><br><span class="line">      root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length),</span><br><span class="line">          Arrays.copyOfRange(in, i + 1, in.length));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;4-重建二叉树&quot;&gt;&lt;a href=&quot;#4-重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;4.重建二叉树&quot;&gt;&lt;/a&gt;4.重建二叉树&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="https://cheng102e.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE.html"/>
    <id>https://cheng102e.github.io/数据结构-图.html</id>
    <published>2020-02-26T03:42:00.000Z</published>
    <updated>2020-02-26T03:47:47.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构-图"><a href="#数据结构-图" class="headerlink" title="数据结构-图"></a>数据结构-图</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>图是一些顶点的集合，这些顶点通过一些边想连接，顶点用圈表示，边通过线表示，是一个多对多的数据结构。<br>可以拆分，就是点集V和边集E的集合。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>边可以是有方向的，只能单向前进，也可能是双向的，可以来回运动，也有的边带有权重，模拟为长度什么的物理量。</p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><ol><li>邻接表<br>每一个顶点会存储一个从该节点开始的链表，比如说A可以到BC，那么就是A-&gt;B-&gt;C。</li><li>邻接矩阵<br>用一个矩阵来存储，假设A能到B且距离为5，那么m[0][1]=5.</li></ol><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ol><li>有向图：边是有方向的图</li><li>无向图：边没有方向，正反都可</li><li>简单图：不存在重复边，顶点不能直接到自身</li><li>完全图：任意两点都存在边(有向的话要有两条方向相反的边)</li><li>子图：点集和边集都是原图的子集，且构成图</li><li>顶点的度：以该顶点为一个端点的边的数目</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构-图&quot;&gt;&lt;a href=&quot;#数据结构-图&quot; class=&quot;headerlink&quot; title=&quot;数据结构-图&quot;&gt;&lt;/a&gt;数据结构-图&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cheng102e.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构-树</title>
    <link href="https://cheng102e.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html"/>
    <id>https://cheng102e.github.io/数据结构-树.html</id>
    <published>2020-02-26T02:42:00.000Z</published>
    <updated>2020-02-26T03:14:42.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构-树"><a href="#数据结构-树" class="headerlink" title="数据结构-树"></a>数据结构-树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树是一种非线性的数据结构，由n(n&gt;0)个有限节点组成，是一个有层次关系的集合，像一棵倒立着的树。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>每个节点都只有有限个子节点或无子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点</li><li>除了根节点外，每个子节点可以分为多个不相交的子树</li><li>树里面没有环路(cycle)</li></ol><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ol><li>节点：每个元素都叫节点</li><li>根节点：树的顶端节点</li><li>父子节点：除了根节点以外每个节点都可以找到向上的唯一节点为父节点，下方就是子节点。</li><li>兄弟节点：拥有相同父节点的节点</li><li>叶节点：没有子树的节点</li><li>子树：每个子节点作为根节点所产生的树</li><li>节点的度：节点含有子节点的数量</li><li>树的度：最大的节点的度</li><li>森林：若干棵不相交的树组成的集合</li></ol><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class tree&#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private int parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是简单的写了一下，因为除根外必有一个父节点，所以这里就写了两部分，值域和指针域，一个存放节点的值，一个指向父节点，具体的操作等我复习到二叉树之类再细写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构-树&quot;&gt;&lt;a href=&quot;#数据结构-树&quot; class=&quot;headerlink&quot; title=&quot;数据结构-树&quot;&gt;&lt;/a&gt;数据结构-树&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cheng102e.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构-栈和队列</title>
    <link href="https://cheng102e.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html"/>
    <id>https://cheng102e.github.io/数据结构-栈和队列.html</id>
    <published>2020-02-25T12:42:00.000Z</published>
    <updated>2020-02-25T14:33:16.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构-栈和队列"><a href="#数据结构-栈和队列" class="headerlink" title="数据结构-栈和队列"></a>数据结构-栈和队列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈和队列是两种特殊的线性表。<br>栈(Stack)是一种后进先出的数据结构,可以想象成一个瓶子，先进去的在下层，要后出来。<br>而队列(Queue)则是先进先出，就像排队一样，先进队伍的先出来。</p><h3 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h3><ol><li>Stack<t>()  创建一个空的栈</t></li><li>void push(T s)  往栈中添加一个新的元素</li><li>T pop()  移除并返回最近添加的元素</li><li>T peek()  返回最近添加的元素，不删除</li><li>boolean isempty()  栈是否为空</li><li>int size()  栈中元素的个数</li></ol><h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><ol><li>Queue<t>()  创建一个空的栈</t></li><li>T Add()  往队列中添加一个新的元素</li><li>T remove()  移除最早添加的元素</li><li>T element()  返回最早添加的元素，不删除</li><li>boolean isempty()  队列是否为空</li><li>int size()   队列中元素的个数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构-栈和队列&quot;&gt;&lt;a href=&quot;#数据结构-栈和队列&quot; class=&quot;headerlink&quot; title=&quot;数据结构-栈和队列&quot;&gt;&lt;/a&gt;数据结构-栈和队列&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cheng102e.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构-线性表</title>
    <link href="https://cheng102e.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8.html"/>
    <id>https://cheng102e.github.io/数据结构-线性表.html</id>
    <published>2020-02-25T11:42:00.000Z</published>
    <updated>2020-02-25T13:36:55.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构-线性表"><a href="#数据结构-线性表" class="headerlink" title="数据结构-线性表"></a>数据结构-线性表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p><p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol><li>集合中必存在唯一的一个“第一元素”。</li><li>集合中必存在唯一的一个 “最后元素” 。</li><li>除最后一个元素之外，均有唯一的后继(后件)。</li><li>除第一个元素之外，均有唯一的前驱(前件)。</li></ol><h3 id="存储方式与优缺点"><a href="#存储方式与优缺点" class="headerlink" title="存储方式与优缺点"></a>存储方式与优缺点</h3><ol><li>顺序存储(顺序表)<br> 优点：<br> 1.空间利用率高<br> 2.存取速度快<br> 缺点：<br> 1.插入删除操作较慢<br> 2.初始要定义长度，可能溢出</li><li>链式存储(链表)<br> 优点：<br> 1.插入删除操作较快<br> 2.没有空间限制<br> 缺点：<br> 1.空间消耗多<br> 2.存取速度慢</li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li>求当前元素个数</li><li>插入</li><li>删除</li><li>查找</li><li>判断是否为空</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构-线性表&quot;&gt;&lt;a href=&quot;#数据结构-线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构-线性表&quot;&gt;&lt;/a&gt;数据结构-线性表&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据结构" scheme="https://cheng102e.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 3.从尾到头打印链表</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%203.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html"/>
    <id>https://cheng102e.github.io/剑指offer 3.从尾到头打印链表.html</id>
    <published>2020-02-24T11:42:00.000Z</published>
    <updated>2020-02-24T11:45:53.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路给了两种，一种是递归，先到下一个结点再输出自身的值，但是可能会存在溢出情况。还有一种就是用栈，先进后出，负负得正，就行了。<br>(两个问题，1.牛客网在线评测头文件要自己打，这个真没想到 2.注意空链表的判断)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">  Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line">  ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">  if (listNode == null) &#123;</span><br><span class="line">    return arrayList;</span><br><span class="line">  &#125;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    int temp = listNode.val;</span><br><span class="line">    stack.push(temp);</span><br><span class="line">    if (listNode.next == null) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode = listNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  while (!stack.isEmpty()) &#123;</span><br><span class="line">    arrayList.add(stack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  return arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-从尾到头打印链表&quot;&gt;&lt;a href=&quot;#3-从尾到头打印链表&quot; class=&quot;headerlink&quot; title=&quot;3.从尾到头打印链表&quot;&gt;&lt;/a&gt;3.从尾到头打印链表&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer 2.替换空格</title>
    <link href="https://cheng102e.github.io/%E5%89%91%E6%8C%87offer%202.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html"/>
    <id>https://cheng102e.github.io/剑指offer 2.替换空格.html</id>
    <published>2020-02-24T11:00:00.000Z</published>
    <updated>2020-02-24T11:43:29.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>书上的思路，是先记录空格位置，然后从后往前转移字符串，遇到空格就输出%20，但是java的字符串简单了很多，用一个StringBuffer就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">  StringBuffer ans = new StringBuffer();</span><br><span class="line">  for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">    if (str.charAt(i) != &apos; &apos;) &#123;</span><br><span class="line">      ans.append(str.charAt(i));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ans.append(&quot;%20&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2-替换空格&quot;&gt;&lt;a href=&quot;#2-替换空格&quot; class=&quot;headerlink&quot; title=&quot;2.替换空格&quot;&gt;&lt;/a&gt;2.替换空格&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://cheng102e.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
