<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer 56.删除链表中重复的结点]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2056.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.html</url>
    <content type="text"><![CDATA[剑指offer 56.删除链表中重复的结点题目在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路直接找就行了,记得先新建一个结点用于避免头结点也和别的相同值，如果下一个结点和当前节点相等，那么再到下一个结点直到不一样未知，然后直接把连起来就行。 代码123456789101112131415161718192021222324252627282930313233public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null) &#123; return null; &#125; ListNode newhead = new ListNode(1); newhead.next = pHead; ListNode cur = pHead; ListNode pre = newhead; while (cur != null) &#123; if (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123; while (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123; cur = cur.next; &#125; pre.next = cur.next; cur = cur.next; &#125; else &#123; pre = pre.next; cur = cur.next; &#125; &#125; return newhead.next;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 55.链表中环的入口结点]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2055.%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.html</url>
    <content type="text"><![CDATA[剑指offer 55.链表中环的入口结点题目给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路现在成了数学题了，首先设快慢两点都在开头，快结点一下走两步，慢结点一下走一步，当快结点追上慢结点就代表存在环。当二者相遇，快结点回到开头，慢结点继续走，当二者再次相遇时，结点就为环的入口结点。记得要考虑到没有下一个结点的可能性。数学问题我就不证明了，画一个图就能理解了。 代码123456789101112131415161718192021222324252627282930public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode fast = pHead; ListNode slow = pHead; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; break; &#125; &#125; if (fast == null || fast.next == null) &#123; return null; &#125; fast = pHead; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 54.字符流中第一个不重复的字符]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2054.%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.html</url>
    <content type="text"><![CDATA[剑指offer 54.字符流中第一个不重复的字符题目题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述: 如果当前字符流没有存在出现一次的字符，返回#字符。 思路我用LinkedHashMap，然后迭代器老是有问题，所以只能改成Hashmap加ArrayList，多了一个步骤。首先是insert，在这里存放，通过hashmap存放字符和次数，list存放顺序，最后读取一下就行了。 代码1234567891011121314151617181920212223HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();public void Insert(char ch) &#123; if (map.containsKey(ch)) &#123; map.put(ch, map.get(ch) + 1); &#125; else &#123; map.put(ch, 1); &#125; list.add(ch);&#125;public char FirstAppearingOnce() &#123; char c = &apos;#&apos;; for (char key : list) &#123; if (map.get(key) == 1) &#123; c = key; break; &#125; &#125; return c;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 53.表示数值的字符串]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2053.%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[剑指offer 53.表示数值的字符串题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 思路三种思路： 正则表达式，这里要注意转义符号的使用。 自动机，编译原理中的概念，已经忘了. 遍历，硬算，设几个标签量来记录符号等，然后ifelse结束. 代码1234public boolean isNumeric(char[] str) &#123; String que=String.valueOf(str); return que.matches(&quot;[\\+-]?[0-9]*(\\.[0-9]*)?([eE][\\+-]?[0-9]+)?&quot;);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 52.正则表达式匹配]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2052.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.html</url>
    <content type="text"><![CDATA[剑指offer 52.正则表达式匹配题目请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 思路我对这题还真没什么思路，就，硬算，对于’.’的情况，不需要太过在意，只需要在用到的时候加一个判断即可。对于’*’的时候，需要多加讨论，是匹配当前0个字符就不用，还是匹配一个字符就不用，还是留下来匹配下一个字符。 代码1234567891011121314151617181920212223242526272829303132333435public static boolean mate(char[] str, char[] pattern, int si, int pi) &#123; if (str.length == si &amp;&amp; pattern.length == pi) &#123; return true; &#125; if (str.length != si &amp;&amp; pattern.length == pi) &#123; return false; &#125; if (pi + 1 &lt; pattern.length &amp;&amp; pattern[pi + 1] == &apos;*&apos;) &#123; if (si != str.length &amp;&amp; ((str[si] == pattern[pi] || pattern[pi] == &apos;.&apos;))) &#123; boolean t0 = mate(str, pattern, si, pi + 2); boolean t1 = mate(str, pattern, si + 1, pi + 2); boolean t2 = mate(str, pattern, si + 1, pi); return t0 || t1 || t2; &#125; else &#123; return mate(str, pattern, si, pi + 2); &#125; &#125; if (si != str.length) &#123; if (str[si] == pattern[pi] || pattern[pi] == &apos;.&apos;) &#123; return mate(str, pattern, si + 1, pi + 1); &#125; &#125; return false;&#125;public static boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) &#123; return false; &#125; int si = 0; int pi = 0; return mate(str, pattern, si, pi);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 51.构建乘积数组]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2051.%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.html</url>
    <content type="text"><![CDATA[剑指offer 51.构建乘积数组题目给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];） 思路这就要从双向往中间计算，首先计算前半部分，就是第一个for循环，对于B[i]来说，这里已经乘上了前半部分，还缺A[i+1]后面的，这时候第二个循环，反向，先给A[len-1]，然后向前逼近，设置一个临时变量表示后半的A乘积。 代码12345678910111213141516public int[] multiply(int[] A) &#123; int len = A.length; int[] B = new int[len]; if (len != 0) &#123; B[0] = 1; for (int i = 1; i &lt; len; i++) &#123; B[i] = B[i - 1] * A[i - 1]; &#125; int temp = 1; for (int j = len - 2; j &gt;= 0; j--) &#123; temp *= A[j + 1]; B[j] *= temp; &#125; &#125; return B;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 50.数组中重复的数字]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2050.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[剑指offer 50.数组中重复的数字题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路没什么特殊的，先判断特殊情况，然后遍历就行，如果数组已经有了，直接返回。 代码123456789101112131415161718192021 public boolean duplicate(int numbers[], int length, int[] duplication) &#123; if (numbers == null || length &lt;= 0) &#123; return false; &#125; for (int i : numbers) &#123; if (i &lt; 0 || i &gt; length - 1) &#123; return false; &#125; &#125; int[] ans = new int[length]; for (int i : numbers) &#123; if (ans[i] == 0) &#123; ans[i] = i; &#125; else &#123; duplication[0] = i; return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 49.把字符串转换成整数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2049.%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0.html</url>
    <content type="text"><![CDATA[剑指offer 49.把字符串转换成整数题目题目描述 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 输入描述: 输入一个字符串,包括数字字母符号,可以为空 输出描述: 如果是合法的数值表达则返回该数字，否则返回0 示例 输入 +2147483647 1a33 输出 2147483647 0 思路面向结果编程了，最小负数我技穷做不出来，就额外加了个判断。首先是首位的符号位，若有则记录下来，别的都是*10，再加当前位数，最后输出时候注意前面的符号位。 代码123456789101112131415161718192021222324252627public int StrToInt(String str) &#123; if (str.equals(&quot;&quot;) || str.length() == 0) &#123; return 0; &#125; if (str.equals(&quot;-2147483648&quot;)) &#123; return -2147483648; &#125; char[] c = str.toCharArray(); boolean flag = true; int sum = 0; for (char i : c) &#123; if (i == &apos;+&apos;) &#123; continue; &#125; else if (i == &apos;-&apos;) &#123; flag = false; &#125; else if (i &lt; 48 || i &gt; 57) &#123; return 0; &#125; else &#123; int temp = sum * 10 + i - 48; if (((temp - i + 48) / 10 != sum) || temp % 10 &lt; 0) &#123; return 0; &#125; sum = temp; &#125; &#125; return flag ? sum : (-1) * sum;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 48.不用加减乘除做加法]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2048.%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.html</url>
    <content type="text"><![CDATA[剑指offer 48.不用加减乘除做加法题目写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路(和上题把要用的删差不多了)二进制相加操作就是异或操作，二进制进位操作就是与操作，首先temp就是相加，然后&amp;就是计算进位，左移一位，进位是有极限的，所以用num2存贮进位并且当做跳出条件，num1存放结果，等到没进位的时候，异或就是相加，直接输出。 代码12345678public int Add(int num1, int num2) &#123; while (num2 != 0) &#123; int temp = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = temp; &#125; return num1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 47.求1+2+3+...+n]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2047.%E6%B1%821%2B2%2B3%2B...%2Bn.html</url>
    <content type="text"><![CDATA[剑指offer 47.求1+2+3+…+n题目求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 思路这题就不谈了，懒得动弹，借助&amp;&amp;来做判断，或者用递归来实现while。 代码12345public int Sum_Solution(int n) &#123; int sum = n; boolean flag = (sum &gt; 0) &amp;&amp; ((sum += Sum_Solution(--n)) &gt; 0); return sum;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 46.孩子们的游戏(圆圈中最后剩下的数)]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2046.%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F(%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0).html</url>
    <content type="text"><![CDATA[剑指offer 46.孩子们的游戏(圆圈中最后剩下的数)题目每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 如果没有小朋友，请返回-1 思路约瑟夫问题，我大一就做这个了，现在大四还在做这个，233333.借助list，先把编号存储进去，然后循环减，每次去除一个index，初试应该是0+m-1，因为这个是从0开始，之后就是index+m-1了，最后输出编号即可。 代码12345678910111213141516 public int LastRemaining_Solution(int n, int m) &#123; if (n == 0) &#123; return -1; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; list.add(i); &#125; int index = (m - 1) % list.size(); while (list.size() &gt; 1) &#123; list.remove(index); index = (m - 1 + index) % list.size(); &#125; return list.get(0);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 45.扑克牌顺子]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2045.%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90.html</url>
    <content type="text"><![CDATA[剑指offer 45.扑克牌顺子题目LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 思路首先看题目，一共五张牌，如果有对子肯定不行，除去王，别的最大差值最大只能为4，12345，所以当最大差值小于5且没有重复的时候，才能成为顺子，没必要统计王的数量，再加hashset去重。 代码1234567891011121314151617181920212223public boolean isContinuous(int[] numbers) &#123; if (numbers == null || numbers.length &lt; 5) &#123; return false; &#125; Arrays.sort(numbers); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int max = 0, min = 14; for (int i : numbers) &#123; if (i != 0) &#123; if (set.contains(i)) &#123; return false; &#125; else &#123; max = Math.max(max, i); min = Math.min(min, i); set.add(i); &#125; &#125; &#125; if (max - min &lt; 5) &#123; return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 44.翻转单词顺序列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2044.%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97.html</url>
    <content type="text"><![CDATA[剑指offer 44.翻转单词顺序列题目牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路同样是转置问题，这里需要多考虑一步，对于单词转置，这里设置index用于记录空格位置，最后在结尾还要再转置一次。(话说上午我笔试就有这道题，不过用的Stringbuffer硬来,思路相同，就是空格处理的时候麻烦点) 代码123456789101112131415161718192021222324public void reverse(char[] c, int start, int end) &#123; while (start &lt; end) &#123; char temp = c[start]; c[start++] = c[end]; c[end--] = temp; &#125;&#125;public String ReverseSentence(String str) &#123; int len = str.length(); char[] c = str.toCharArray(); reverse(c, 0, len - 1); int index = -1; for (int i = 0; i &lt; len; i++) &#123; if (c[i] == &apos; &apos;) &#123; reverse(c, index + 1, i - 1); index = i; &#125; &#125; reverse(c, index + 1, len - 1); return new String(c);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 43.左旋转字符串]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2043.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[剑指offer 43.左旋转字符串题目汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路这个就是转置问题了，如果是java，可以直接新建stringbuffer直接加，先加后面再加前面。书上的思路就普适性多了，先转置前n个，再转置后面的，最后再全部转置，但是写起来还是遇到了一些问题的，特殊值需要处理等等。 代码1234567891011121314151617181920212223 public void reverse(char[] c, int start, int end) &#123; while (start &lt; end) &#123; char temp = c[start]; c[start++] = c[end]; c[end--] = temp; &#125;&#125;public String LeftRotateString(String str, int n) &#123; int len = str.length(); if (len &lt; n) &#123; return &quot;&quot;; &#125; char[] c = str.toCharArray(); reverse(c, 0, n - 1); reverse(c, n, len - 1); reverse(c, 0, len - 1); String ans = &quot;&quot;; for (char q : c) &#123; ans += q; &#125; return ans;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 42.和为S的两个数字]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2042.%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[剑指offer 42.和为S的两个数字题目题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述: 对应每个测试案例，输出两个数，小的先输出。 思路同样是滑动窗口题目，设置左右两个游标，然后计算和，若和小，那么左侧游标增加，区间和大，右侧游标减小，保存结果的时候要比较一下更符合条件的数。 代码1234567891011121314151617181920212223242526272829public ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int l = 0; int r = array.length - 1; int a = 0; int b = 0; int mul = Integer.MAX_VALUE; while (l &lt; r) &#123; int num = array[l] + array[r]; if (num == sum) &#123; int temp = array[l] * array[r]; if (temp &lt; mul) &#123; mul = temp; a = array[l]; b = array[r]; &#125; r--; &#125; else if (sum &gt; num) &#123; l++; &#125; else &#123; r--; &#125; &#125; if (a != 0 &amp;&amp; b != 0) &#123; list.add(a); list.add(b); &#125; return list;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 41.和为S的连续正数序列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2041.%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97.html</url>
    <content type="text"><![CDATA[剑指offer 41.和为S的连续正数序列题目小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 思路这一看就是标准的滑动窗口题目，设置左右两个游标，然后计算区间和，若区间和小，那么右侧游标增加，区间和大，左侧游标增加，记得保存符合条件的结果。若左右游标重合，那就可以结束了，因为这个区间至少包括两个数。 代码123456789101112131415161718192021public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); int l = 1; int r = 2; while (l &lt; r) &#123; int num = (r - l + 1) * (l + r) / 2; if (num == sum) &#123; ArrayList&lt;Integer&gt; one = new ArrayList&lt;&gt;(); for (int i = l; i &lt;= r; i++) &#123; one.add(i); &#125; list.add(one); r++; &#125; else if (sum &gt; num) &#123; r++; &#125; else &#123; l++; &#125; &#125; return list; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 40.数组中只出现一次的数字]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2040.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[剑指offer 40.数组中只出现一次的数字题目一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路如果只有一个数，当然是异或更好用，相同数字异或为0，但是有两个数字，这种方法无法快速找到，所以不如用hashset，如果存在就删除，不存在就加入，最后把两个数字取出来即可。 代码1234567891011121314151617181920public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i : array) &#123; if (set.contains(i)) &#123; set.remove(i); &#125; else &#123; set.add(i); &#125; &#125; int[] t = new int[2]; int temp = 0; Iterator&lt;Integer&gt; iterator = set.iterator(); while (iterator.hasNext()) &#123; t[temp++] = iterator.next(); &#125; num1[0] = t[0]; num2[0] = t[1];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 39.平衡二叉树]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2039.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content type="text"><![CDATA[剑指offer 39.平衡二叉树题目输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路继续偷懒，用前一题的代码，求深度，在返回之前比较一下左右子树深度，若差值大于1，结果置为false。 代码12345678910111213141516171819202122232425262728293031public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;boolean ans = true;public int TreeDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = TreeDepth(root.left); int right = TreeDepth(root.right); if (Math.abs(left - right) &gt; 1) &#123; ans = false; &#125; return Math.max(left, right) + 1;&#125;public boolean IsBalanced_Solution(TreeNode root) &#123; int i = TreeDepth(root); return ans;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 38.二叉树的深度]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2038.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.html</url>
    <content type="text"><![CDATA[剑指offer 38.二叉树的深度题目输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路偷个懒，直接用递归，如果结点为空就不增长深度，不为空就返回子树的深度加一。 代码1234567891011121314151617public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public int TreeDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; return Math.max(TreeDepth(root.left), TreeDepth(root.right)) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 37.数字在排序数组中出现的次数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2037.%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.html</url>
    <content type="text"><![CDATA[剑指offer 37.数字在排序数组中出现的次数题目统计一个数字在排序数组中出现的次数。 思路虽然递归已经是O(n)了，但是还要缩小，所以二分查找，找到前后的位置就行了。查找设k-0.5和k+0.5，反正都没有，所以能找到应该在的位置，然后减法就行。 代码1234567891011121314151617181920public int search(int[] array, double k) &#123; int l = 0; int r = array.length - 1; int m = (r - l) / 2 + l; while (l &lt;= r) &#123; if (array[m] &lt; k) &#123; l = m + 1; &#125; else &#123; r = m - 1; &#125; m = (r - l) / 2 + l; &#125; return l;&#125;public int GetNumberOfK(int[] array, int k) &#123; int start = search(array, k - 0.5); int end = search(array, k + 0.5); return end - start;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 36.两个链表的第一个公共结点]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2036.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9.html</url>
    <content type="text"><![CDATA[剑指offer 36.两个链表的第一个公共结点题目输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 思路如果可以的话，从后往前比较最合适。但是不行，我们需要考虑两个链表的长度不同，长度为len1和len2，长的先走完差值，然后两个一起往后面走，就可以找到相同的结点。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if (pHead1 == null || pHead2 == null) &#123; return null; &#125; ListNode p1 = pHead1; ListNode p2 = pHead2; int len1 = 0; int len2 = 0; while (p1.next != null) &#123; len1++; p1 = p1.next; &#125; while (p2.next != null) &#123; len2++; p2 = p2.next; &#125; p1 = pHead1; p2 = pHead2; if (len1 &gt; len2) &#123; for (int i = len1 - len2; i &gt;= 0; i--) &#123; p1 = p1.next; &#125; &#125; else &#123; for (int i = len2 - len1; i &gt;= 0; i--) &#123; p2 = p2.next; &#125; &#125; while (p1 != p2) &#123; p1 = p1.next; p2 = p2.next; &#125; return p1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 35.数组中的逆序对]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2035.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html</url>
    <content type="text"><![CDATA[剑指offer 35.数组中的逆序对题目题目描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述: 题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 思路这题好麻烦的，最后选择了模拟归并排序的方法，分成最小的块然后进行归并，归并时内部的逆序对就已经计算了，不需要再计算一次。以158，236为例子，首先1&lt;2，逆序不用计算，然后5&gt;3，应该放3，逆序增加5，8两个数字，为mid-l+1，行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142long count = 0;public void merge(int[] array, int[] copy, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int mid = (end - start) / 2 + start; merge(array, copy, start, mid); merge(array, copy, mid + 1, end); int l = start; int r = mid + 1; int temp = start; while (l &lt;= mid &amp;&amp; r &lt;= end) &#123; if (array[l] &lt;= array[r]) &#123; copy[temp++] = array[l++]; &#125; else &#123; count += mid - l + 1; copy[temp++] = array[r++]; if (count &gt; 1000000007) &#123; count %= 1000000007; &#125; &#125; &#125; while (l &lt;= mid) &#123; copy[temp++] = array[l++]; &#125; while (r &lt;= end) &#123; copy[temp++] = array[r++]; &#125; for (int i = start; i &lt;= end; i++) &#123; array[i] = copy[i]; &#125;&#125;public int InversePairs(int[] array) &#123; int start = 0; int end = array.length - 1; int[] copy = new int[array.length]; merge(array, copy, start, end); return (int) count;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 34.第一个只出现一次的字符]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2034.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.html</url>
    <content type="text"><![CDATA[剑指offer 34.第一个只出现一次的字符题目在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 思路这种统计数量的，优先拿hashmap，遍历时若不存在，直接放入，存在的话，数字加一。最后按照字符串中的顺序遍历一下，若次数为1直接输出。 代码12345678910111213141516171819202122public int FirstNotRepeatingChar(String str) &#123; if (str == null || str.length() == 0) &#123; return -1; &#125; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); StringBuffer que = new StringBuffer(str); for (int i = 0; i &lt; que.length(); i++) &#123; char temp = que.charAt(i); if (map.containsKey(temp)) &#123; int num = map.get(temp); map.put(temp, ++num); &#125; else &#123; map.put(temp, 1); &#125; &#125; for (int i = 0; i &lt; que.length(); i++) &#123; if (map.get(que.charAt(i)) == 1) &#123; return i; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 33.丑数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2033.%E4%B8%91%E6%95%B0.html</url>
    <content type="text"><![CDATA[剑指offer 33.丑数题目把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路这里采用的是三指针法，任意丑数都是比这个数小的丑数乘以2，3，5其中之一得到的，要求按照顺序排列，那么就从之前的数中找到未被使用过的数乘一下，然后比较，就可以得到新的数了。首先初始位为1，设三个指针值n2,n3,n5,初始设为0.之后开始循环，每次循环都找到235未乘过的数字乘一下，然后取最小值为新的丑数。之后，若n2n3n5使用过了，那么指针位+1，下次乘下一个数字，如果都可以，那就都加。把数字记录下来最后输出即可。 代码1234567891011121314151617181920212223public int GetUglyNumber_Solution(int index) &#123; if(index==0)&#123; return 0; &#125; int[] ans = new int[index]; int n2 = 0, n3 = 0, n5 = 0; ans[0] = 1; for (int i = 1; i &lt; index; i++) &#123; int min = Math.min(ans[n2] * 2, Math.min(ans[n3] * 3, ans[n5] * 5)); ans[i] = min; if (min == ans[n2]*2) &#123; n2++; &#125; if (min == ans[n3]*3) &#123; n3++; &#125; if (min == ans[n5]*5) &#123; n5++; &#125; &#125; return ans[index-1];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 32.把数组排成最小的数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2032.%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html</url>
    <content type="text"><![CDATA[剑指offer 32.把数组排成最小的数题目输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 思路思路就是，先建一个ArrayList存放数字，对这个进行排序，然后转换成字符串。问题就是中间的排序，排序直接用了sort，改一下比较器就行，假设有两个数字，12，34，1234&lt;3412，所以12就往前面排，以此类推，最后得到答案。 代码12345678910111213141516171819public static String PrintMinNumber(int[] numbers) &#123; StringBuffer str = new StringBuffer(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i:numbers) &#123; list.add(i); &#125; Collections.sort(list, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; String s1 = o1 + &quot;&quot; + o2; String s2 = o2 + &quot;&quot; + o1; return s1.compareTo(s2); &#125; &#125;); for (int i:list)&#123; str.append(i); &#125; return str.toString();&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 31.整数中1出现的次数（从1到n整数中1出现的次数）]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2031.%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89.html</url>
    <content type="text"><![CDATA[剑指offer 31.整数中1出现的次数（从1到n整数中1出现的次数）题目求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 思路虽然有不少比较巧妙的算法，但我还是选择了最快的方法(思路最清晰)。新建一个StringBuffer，然后把数字全塞进去，遍历一下，成了。 代码1234567891011121314public int NumberOf1Between1AndN_Solution(int n) &#123; StringBuffer str = new StringBuffer(); for (int i = 1; i &lt;= n; i++) &#123; str.append(i); &#125; int count = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == &apos;1&apos;) &#123; count++; &#125; &#125; return count;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 30.连续子数组的最大和]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2030.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html</url>
    <content type="text"><![CDATA[剑指offer 30.连续子数组的最大和题目HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 思路这个思路就是动态规划，但是没必要照状态转移方程来写，先设置两个变量，sum代表当前序列的和，max代表最大子序列的和，对于每个数组，若这时的sum已经小于0，那么对于新的序列就是负收益，直接舍弃，若此时sum大于0，那么就是正收益，不用舍弃，继续叠加。于此同时记得保存最大值。 代码123456789101112131415public int FindGreatestSumOfSubArray(int[] array) &#123; int sum = array[0]; int max = sum; for (int i = 1; i &lt; array.length; i++) &#123; if (sum &lt; 0) &#123; sum = 0; &#125; sum += array[i]; if (sum &gt; max) &#123; max = sum; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 29.最小的K个数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2029.%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0.html</url>
    <content type="text"><![CDATA[剑指offer 29.最小的K个数题目输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 思路几种方法，我一开始想到的是直接快排函数，然后输出k个就行，之后改用优先队列建堆，大小控制为k，大于这个数量就删除堆顶(最大值),最后只剩k个，输出到ans当中即可。 代码123456789101112131415161718192021222324public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (input == null || k &lt;= 0 || k &gt; input.length) &#123; return ans; &#125; Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1); for (int i = 0; i &lt; input.length; i++) &#123; if (queue.size() &lt; k) &#123; queue.add(input[i]); &#125; else &#123; if (input[i] &lt; queue.peek()) &#123; queue.remove(); queue.add(input[i]); &#125; &#125; &#125; while (!queue.isEmpty()) &#123; ans.add(queue.remove()); &#125; return ans;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 28.数组中出现次数超过一半的数字]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2028.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[剑指offer 28.数组中出现次数超过一半的数字题目数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路这有多种方法，我最后选择了图，思路清晰。首先把数组放进一个hashmap当中，value值做出现次数。然后拿迭代器一对一对取出来，若数量大于总长度一半就输出值，不然就下一个。 代码1234567891011121314151617181920212223public int MoreThanHalfNum_Solution(int[] array) &#123; if (array == null || array.length == 0) &#123; return 0; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; array.length; i++) &#123; if (map.containsKey(array[i])) &#123; int count = map.get(array[i]); map.put(array[i], ++count); &#125; else &#123; map.put(array[i], 1); &#125; &#125; Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = (Entry&lt;Integer, Integer&gt;) iter.next(); if (entry.getValue() &gt; array.length / 2) &#123; return entry.getKey(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 27.字符串的排列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2027.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html</url>
    <content type="text"><![CDATA[剑指offer 27.字符串的排列题目题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述: 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 思路回溯法加上递归思路，找到所有可能的排列情况，全部加入到最后的结果集合中，这里要记得去重，最后输出。 代码12345678910111213141516171819202122232425262728293031323334 public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; resultList = new ArrayList&lt;&gt;(); if (str.length() == 0) &#123; return resultList; &#125; fun(str.toCharArray(), resultList, 0); Collections.sort(resultList); return resultList;&#125;public void fun(char[] ch, List&lt;String&gt; list, int i) &#123; if (i == ch.length - 1) &#123; if (!list.contains(new String(ch))) &#123; list.add(new String(ch)); return; &#125; &#125; else &#123; for (int j = i; j &lt; ch.length; j++) &#123; swap(ch, i, j); fun(ch, list, i + 1); swap(ch, i, j); &#125; &#125;&#125;public void swap(char[] str, int i, int j) &#123; if (i != j) &#123; char t = str[i]; str[i] = str[j]; str[j] = t; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 26.二叉搜索树与双向链表]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2026.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[26.二叉搜索树与双向链表题目输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路二叉树还是要递归方法，对于每个节点，若为空直接返回，不然就递归到子节点。这里和正常的不一样，先寻找右节点，然后在找左节点，可以省下来一个存储位。 代码12345678910111213141516171819202122232425262728 public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;TreeNode ans = null;public TreeNode Convert(TreeNode pRootOfTree) &#123; if (pRootOfTree == null) &#123; return pRootOfTree; &#125; Convert(pRootOfTree.right); if (ans == null) &#123; ans = pRootOfTree; &#125; else &#123; ans.left = pRootOfTree; pRootOfTree.right = ans; ans = pRootOfTree; &#125; Convert(pRootOfTree.left); return ans;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 25.复杂链表的复制]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2025.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html</url>
    <content type="text"><![CDATA[25.复杂链表的复制题目输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路好繁琐一道题，用了三次遍历，赋值的时候用了三目运算符缩短代码。 在每个节点后增加一个新节点，只有节点本身。 给每个新增节点增加random。 分开两个链表。 代码1234567891011121314151617181920212223242526272829303132333435363738 public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;public RandomListNode Clone(RandomListNode pHead) &#123; if (pHead == null) &#123; return null; &#125; RandomListNode cur = pHead; while (cur != null) &#123; RandomListNode nextnode = cur.next; RandomListNode clone = new RandomListNode(cur.label); cur.next = clone; clone.next = nextnode; cur = nextnode; &#125; cur = pHead; while (cur != null) &#123; cur.next.random = cur.random == null ? null : cur.random.next; cur = cur.next.next; &#125; cur = pHead; RandomListNode newHead = pHead.next; while (cur != null) &#123; RandomListNode clone = cur.next; cur.next = clone.next; cur = cur.next; clone.next = clone.next == null ? null : clone.next.next; &#125; return newHead;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 23.二叉搜索树的后序遍历序列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2023.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.html</url>
    <content type="text"><![CDATA[23.二叉搜索树的后序遍历序列题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路二叉搜索树性质就是左子树小于根节点小于右节点，以最右侧为根，判断一下让数组左侧均小于根，根小于右侧，然后分成两块继续运算即可。(我真的不知道为什么越界啊，我也不知道为什么突然就不越界了) 代码123456789101112131415161718192021222324252627282930313233343536 public boolean vt(int[] sequence, int start, int end) &#123; if (start&gt;=end) &#123; return true; &#125; int root = sequence[end]; int mid = start; for (; mid &lt; end; mid++) &#123; if (root &lt; sequence[mid]) &#123; break; &#125; &#125; for (int i = mid; i &lt; end; i++) &#123; if (root &gt; sequence[i]) &#123; return false; &#125; &#125; boolean left = true; boolean right = true; if (start &lt;= mid - 1) &#123; left = vt(sequence, start, mid - 1); &#125; if (mid &lt;= end - 1) &#123; right = vt(sequence, mid, end - 1); &#125; return left &amp;&amp; right;&#125;public boolean VerifySquenceOfBST(int[] sequence) &#123; if (sequence == null || sequence.length == 0) &#123; return false; &#125; if (sequence.length &lt; 3) &#123; return true; &#125; return vt(sequence, 0, sequence.length - 1);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 24.二叉树中和为某一值的路径]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2024.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.html</url>
    <content type="text"><![CDATA[24.二叉树中和为某一值的路径题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路路径问题就直接递归就行了，用一个list存储当前路径，如果成功就加入答案集，不成功就删除最后一个结点回溯。这里还要用sort比较一下，Collections.sort(all, ((o1, o2) -&gt; o2.size() - o1.size()))，比较的时候就是降序排列。 代码1234567891011121314151617181920212223242526272829303132333435 public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public void find(TreeNode root, int target, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; all, ArrayList list) &#123; if (root == null) &#123; return; &#125; int value = root.val; list.add(value); if (target == value &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; all.add(new ArrayList&lt;&gt;(list)); &#125; else &#123; find(root.left, target - value, all, list); find(root.right, target - value, all, list); &#125; list.remove(list.size() - 1);&#125;public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; all = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); find(root, target, all, list); Collections.sort(all, ((o1, o2) -&gt; o2.size() - o1.size())); return all;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 22.从上往下打印二叉树]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2022.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content type="text"><![CDATA[22.从上往下打印二叉树题目从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路这题就是简单的树的遍历，调节顺序就可以用队列来帮助存储，先把结点存放进队列，从队列头部取出节点，然后查看左子节点和右子节点，取出的时候记得保存值。 代码123456789101112131415161718192021222324252627282930public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if (root == null) &#123; return list; &#125; queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode temp = queue.poll(); if (temp.left != null) &#123; queue.offer(temp.left); &#125; if (temp.right != null) &#123; queue.offer(temp.right); &#125; list.add(temp.val); &#125; return list; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 21.栈的压入、弹出序列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2021.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html</url>
    <content type="text"><![CDATA[21.栈的压入、弹出序列题目输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路这题思路倒是比较清晰，设置一个栈模拟进栈出栈过程，坑一点的就是边界问题，我本来是以出栈为循环条件的，边界越整越多，最后换了入栈为循环条件，简单了很多。如果栈不为空且栈顶和出栈顺序一样，出栈，不然下一位。 代码1234567891011121314151617public boolean IsPopOrder(int[] pushA, int[] popA) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int len = pushA.length; int in = 0, out = 0; for (; in &lt; len; in++) &#123; stack.push(pushA[in]); while (!stack.empty() &amp;&amp; stack.peek() == popA[out]) &#123; stack.pop(); out++; &#125; &#125; return stack.empty();&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 20.包含min函数的栈]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2020.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html</url>
    <content type="text"><![CDATA[20.包含min函数的栈题目定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。 思路这题给人的启发很深，可以增加一个新的栈专门来存储最小值，push的时候，第一个数据栈直接push，第二个最小值栈若为空或者顶端值大于node，都是直接加入node，如果不是，那么就把栈顶的数再次加入，最小值栈就用于存放最小值，插入值不为最小值就把最小值再次插入一遍确保两个栈相同长度。 代码123456789101112131415161718192021222324252627Stack&lt;Integer&gt; stackdata = new Stack&lt;&gt;();Stack&lt;Integer&gt; stackmin = new Stack&lt;&gt;();public void push(int node) &#123; stackdata.push(node); if (stackmin.empty()) &#123; stackmin.push(node); &#125; else if (node &lt; stackmin.peek()) &#123; stackmin.push(node); &#125; else &#123; stackmin.push(stackmin.peek()); &#125;&#125;public void pop() &#123; stackmin.pop(); stackdata.pop();&#125;public int top() &#123; return stackdata.peek();&#125;public int min() &#123; return stackmin.peek();&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 19.顺时针打印矩阵]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2019.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html</url>
    <content type="text"><![CDATA[19.顺时针打印矩阵题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路这个。。我没找什么特别的方法，就用思路最清晰的方法，用循环来做，并且几个判断条件都要带=，不然结果会出错。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int EndX = matrix.length - 1; int EndY = matrix[0].length - 1; int StartX = 0; int StartY = 0; int x = StartX, y = StartY; while (StartX &lt;= EndX &amp;&amp; StartY &lt;= EndY) &#123; if (StartX &lt;= EndX) &#123; while (y &lt;= EndY) &#123; list.add(matrix[x][y]); y++; &#125; y--; StartX++; x = StartX; &#125; if (StartY &lt;= EndY) &#123; while (x &lt;= EndX) &#123; list.add(matrix[x][y]); x++; &#125; x--; EndY--; y = EndY; &#125; if (StartX &lt;= EndX) &#123; while (y &gt;= StartY) &#123; list.add(matrix[x][y]); y--; &#125; y++; EndX--; x = EndX; &#125; if (StartY &lt;= EndY) &#123; while (x &gt;= StartX) &#123; list.add(matrix[x][y]); x--; &#125; x++; StartY++; y = StartY; &#125; &#125; return list;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 18.二叉树的镜像]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2018.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.html</url>
    <content type="text"><![CDATA[18.二叉树的镜像题目题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树 8 / 6 10 / \ / 5 7 9 11 镜像二叉树 8 / 10 6 / \ / 11 9 7 5 思路同样是递归，不过这题思路很清晰，如果根节点存在，直接交换左右节点，之后递归以左右节点为根，子节点的子节点左右交换，一层一层就行了。 代码123456789101112131415161718192021222324252627 public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public void Mirror(TreeNode root) &#123; if (root != null) &#123; TreeNode temp = root.left; root.left = root.right; root.right = temp; if (root.left != null) &#123; Mirror(root.left); &#125; if (root.right != null) &#123; Mirror(root.right); &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 17.树的子结构]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2017.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[17.树的子结构题目输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路这题应该用递归的，关于树类型的题目递归的话思路会很清晰。首先在A中寻找到B的根节点，找到之后就开始递归比较左子节点和右子节点是否相同，如果找到就返回true，不然的话就是false。 代码12345678910111213141516171819202122232425262728293031323334353637383940 public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; if (root1 != null &amp;&amp; root2 != null) &#123; if (root1.val == root2.val) &#123; result = Does1Has2(root1, root2); &#125; if (!result) &#123; result = HasSubtree(root1.left, root2); &#125; if (!result) &#123; result = HasSubtree(root1.right, root2); &#125; &#125; return result;&#125;public boolean Does1Has2(TreeNode root1, TreeNode root2) &#123; if (root2 == null) &#123; return true; &#125; if (root1 == null) &#123; return false; &#125; if (root1.val != root2.val) &#123; return false; &#125; return Does1Has2(root1.left, root2.left) &amp;&amp; Does1Has2(root1.right, root2.right);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 16.合并两个排序的链表]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2016.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[16.合并两个排序的链表题目输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路这题以前也做过的，只需要新建一个表头，然后比较两边的大小，依次加入新的链表，最后再把没用上的加到结尾即可。now代表当前节点，base代表头结点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;public ListNode Merge(ListNode list1, ListNode list2) &#123; if (list1 == null) &#123; return list2; &#125; if (list2 == null) &#123; return list1; &#125; ListNode base = null; ListNode now = null; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt;= list2.val) &#123; if (base == null) &#123; base = list1; now = list1; &#125; else &#123; now.next = list1; now = now.next; &#125; list1 = list1.next; &#125; else &#123; if (base == null) &#123; base = list2; now = list2; &#125; else &#123; now.next = list2; now = now.next; &#125; list2 = list2.next; &#125; &#125; if (list1 == null) &#123; now.next = list2; &#125; else &#123; now.next = list1; &#125; return base;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 15.反转链表]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2015.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[15.反转链表题目输入一个链表，反转链表后，输出新链表的表头。 思路翻转链表并不是很难，只需要注意一下特殊情况，这里设置两个空节点存储前一个结点和后一个结点。头结点为空直接结束，不为空就开始循环，假设链表为0-&gt;1，head=0，next=null，pre=null；然后next=1，head.next=null(最后一位没有子节点),pre=0,head=1;然后next=null，head.next=0，pre=1，head=null，跳出循环，头结点为pre(1)，结束。最后返回的应该是pre不是head，因为原本尾结点现在是pre，多走了一步，head归为null了。 代码123456789101112131415161718192021222324public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;public ListNode ReverseList(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode pre = null; ListNode next = null; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 14.链表中倒数第k个结点]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2014.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.html</url>
    <content type="text"><![CDATA[14.链表中倒数第k个结点题目输入一个链表，输出该链表中倒数第k个结点。 思路假设原链表有n个结点，倒数第k个结点就是n-k+1个结点，那么这里可以设置两个结点，一个结点先走k-1步，是第k个结点，然后两个结点一起走，第一个结点再走n-k步就到达末尾，此时第二个结点也走了n-k步，到达了n-k+1个结点，就是所求的值。这里有几点需要注意，就是k的范围，若k&lt;=0那么直接返回null，若链表为空那也返回null，若链表长度小于k一样返回null 代码12345678910111213141516171819202122232425262728public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;public ListNode FindKthToTail(ListNode head, int k) &#123; if (head == null || k &lt;= 0) &#123; return null; &#125; ListNode ans = head; for (int i = 0; i &lt; k - 1; i++) &#123; if (head.next != null) &#123; head = head.next; &#125; else &#123; return null; &#125; &#125; while (head.next != null) &#123; head = head.next; ans = ans.next; &#125; return ans;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 13.调整数组顺序使奇数位于偶数前面]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2013.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html</url>
    <content type="text"><![CDATA[13.调整数组顺序使奇数位于偶数前面题目输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路采用了空间换时间，确保相对位置，新建数组把奇数放前面偶数放后面，再赋值给原数组。 代码12345678910111213141516171819 public void reOrderArray(int[] array) &#123; int[] newarray = new int[array.length]; int index = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] % 2 == 1) &#123; newarray[index] = array[i]; index++; &#125; &#125; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] % 2 == 0) &#123; newarray[index] = array[i]; index++; &#125; &#125; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = newarray[i]; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 12.数值的整数次方]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2012.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html</url>
    <content type="text"><![CDATA[12.数值的整数次方题目给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 思路问题也不是很大，如果不是要求效率就可以直接分类讨论，一个循环解决，要求效率的话就要用快速幂，我没用快速幂，就分类讨论了一下，最后输出结果。 代码1234567891011121314151617181920212223public double Power(double base, int exponent) &#123; if (exponent == 0) &#123; return 1; &#125; if (base == 0) &#123; return 0; &#125; double ans = 1; boolean flag = false; if (exponent &gt; 0) &#123; flag = true; &#125; else &#123; flag = false; exponent = -exponent; &#125; for (int i = 1; i &lt;= exponent; i++) &#123; ans = ans * base; &#125; if (!flag) &#123; ans = 1.0 / ans; &#125; return ans;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 213. House Robber II]]></title>
    <url>%2FLeetCode%20213.%20House%20Robber%20II.html</url>
    <content type="text"><![CDATA[213. House Robber II（打家劫舍 II）链接https://leetcode-cn.com/problems/house-robber-ii 题目你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。示例 2: 输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 思路动态规划，对于第三间之后的房子，有拿或者不拿两种选择，如果选择拿，那么前一间房子就不能拿，这样可以得到状态转移方程dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])，还要考虑到一点就是，第一个和最后一个不能都拿，可以考虑设两个方程，第一个是1到n-1，第二个是2到n，选最大值即可。 代码123456789101112131415161718192021222324public int rob(int[] nums) &#123; int[] dp_0 = new int[nums.length]; int[] dp_1 = new int[nums.length]; if (nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; if (nums.length == 2) &#123; return Math.max(nums[0], nums[1]); &#125; dp_0[0] = nums[0]; dp_0[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length - 1; i++) &#123; dp_0[i] = Math.max(dp_0[i - 1], dp_0[i - 2] + nums[i]); &#125; dp_1[1] = nums[1]; dp_1[2] = Math.max(nums[1], nums[2]); for (int i = 3; i &lt; nums.length; i++) &#123; dp_1[i] = Math.max(dp_1[i - 1], dp_1[i - 2] + nums[i]); &#125; return Math.max(dp_0[nums.length - 2], dp_1[nums.length - 1]);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 11.二进制中1的个数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2011.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html</url>
    <content type="text"><![CDATA[11.二进制中1的个数题目输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路对我来说蛮难的，虽然解法有多种吧。一开始想的就是直接转二进制字符串遍历，简单，但是这题本意应该是位运算，这方面我不是很熟。把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。这句话是书上的，每次运算都把一个1变成0，当成为0的时候运算的次数就是1的数量。 代码123456789public int NumberOf1(int n) &#123; int count = 0; while (n != 0) &#123; count++; n = (n - 1) &amp; n; &#125; return count;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 198. House Robber]]></title>
    <url>%2FLeetCode%20198.%20House%20Robber.html</url>
    <content type="text"><![CDATA[198. House Robber（打家劫舍）链接https://leetcode-cn.com/problems/house-robber 题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 思路标准的动态规划题目，对于第三间之后的房子，有拿或者不拿两种选择，如果选择拿，那么前一间房子就不能拿，这样可以得到状态转移方程dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])，之后循环得到答案即可。 代码123456789101112131415public int rob(int[] nums) &#123; int[] dp = new int[nums.length]; if (nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; i++) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[nums.length - 1];&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 303. Range Sum Query - Immutable]]></title>
    <url>%2FLeetCode%20303.%20Range%20Sum%20Query%20-%20Immutable.html</url>
    <content type="text"><![CDATA[303. Range Sum Query - Immutable（区域和检索 - 数组不可变）链接https://leetcode-cn.com/problems/range-sum-query-immutable 题目给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange() sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3说明: 你可以假设数组不可变。会多次调用 sumRange 方法。 思路由于需要多次调用，建议面向答案编程，先建立一个sum数组，存放从开头到这个数的和，若要(i,j)那么就用sum[j]-sum[i-1]即可。 代码：123456789101112131415161718192021private int[] sum;public void NumArray(int[] nums) &#123; if(nums.length==0) &#123; return; &#125; sum = new int[nums.length]; sum[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; sum[i] += sum[i - 1] + nums[i]; &#125;&#125;public int sumRange(int i, int j) &#123; if (i == 0) &#123; return sum[j]; &#125; else &#123; return sum[j] - sum[i - 1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 10.矩形覆盖]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2010.%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.html</url>
    <content type="text"><![CDATA[10.矩形覆盖题目我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 比如n=3时，2*3的矩形块有3种覆盖方法： 思路还是斐波那契数列，22的矩阵有两种方法填装，3\2的就是3种方法，n*2的就是n-1和n-2的方法的和 代码1234567891011121314151617181920public static int JumpFloor(int target) &#123; if (target &lt;= 0) &#123; return 0; &#125; if(target==1) &#123; return 1; &#125; if (target==2) &#123; return 2; &#125; int f[] = new int[target + 1]; f[1] = 1; f[2] = 2; for (int i = 3; i &lt;= target; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f[target];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 9.变态跳台阶]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%209.%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.html</url>
    <content type="text"><![CDATA[9.变态跳台阶题目一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路与上题相似，假设要到3级，那么可以从0，1，2级直接到三级，那么f3=f1+f2+1，f2=f1+1，f3=4，找规律。也可以换一种思路，不限制长度，那就是每一级都可以跳，只有选择跳和不跳，那么就是2^(n-1)，结果一样。 代码1234567891011121314151617181920public static int JumpFloor(int target) &#123; if (target &lt;= 0) &#123; return 0; &#125; if(target==1) &#123; return 1; &#125; if (target==2) &#123; return 2; &#125; int f[] = new int[target + 1]; f[1] = 1; f[2] = 2; for (int i = 3; i &lt;= target; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f[target];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 8.跳台阶]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%208.%E8%B7%B3%E5%8F%B0%E9%98%B6.html</url>
    <content type="text"><![CDATA[8.跳台阶题目一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路和斐波那契算是一道题，只要转换一下得到f[i] = f[i - 1] + f[i - 2]即可，因为到达该级可以在前一级一步上来，在前两级两步上来。 代码1234567891011121314151617181920public static int JumpFloor(int target) &#123; if (target &lt;= 0) &#123; return 0; &#125; if(target==1) &#123; return 1; &#125; if (target==2) &#123; return 2; &#125; int f[] = new int[target + 1]; f[1] = 1; f[2] = 2; for (int i = 3; i &lt;= target; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f[target];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 7.斐波那契数列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%207.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html</url>
    <content type="text"><![CDATA[7.斐波那契数列题目大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 思路这就是看下效率的，建议采用迭代，递归的耗时太长了，还有别的方法，比如公式法，比如面向答案编程的打表法。 代码1234567891011121314151617public static int Fibonacci(int n) &#123; int a0 = 0; int a1 = 1; int a2 = 0; if (n == 0) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; for (int i = 2; i &lt;= n; i++) &#123; a2 = a0 + a1; a0 = a1; a1 = a2; &#125; return a2;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 6.旋转数组的最小数字]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%206.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[6.旋转数组的最小数字题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路题目有个坑的地方，就是这里是非递减排序，所以可能相同。直接找就是O(n)，但是这题显然是让人进行二分查找的，所以采用二分查找的格式。与正常二分查找不同，如果左侧等于右侧，就只能一个一个找，到那时候直接用个循环就可以了。 代码12345678910111213141516171819public int minNumberInRotateArray(int[] array) &#123; if (array.length == 0) &#123; return 0; &#125; int left = 0; int right = array.length - 1; while (array[left] &gt;= array[right]) &#123; int mid = (left + right) / 2; if (array[mid] &gt; array[right]) &#123; left = mid + 1; &#125; else if (array[mid] == array[right]) &#123; right--; &#125; else if (array[mid] &lt; array[right]) &#123; right = mid; &#125; &#125; return array[left];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 5.用两个栈实现队列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%205.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html</url>
    <content type="text"><![CDATA[5.用两个栈实现队列题目用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路栈是先进后出，队列是先进先出，两个栈，那么负负得正，就可以得到先进先出。入栈就直接使用第一个栈，栈内关系有序，出栈时，若第二个栈为空，就将第一个栈转移到第二个栈，先进第一个栈后出第一个栈后进第二个栈，先出第一个栈，方向调过来了。若第二个栈不为空，那就输出第二个栈的顶端，顺序一样的。 代码123456789101112131415161718Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();public void push(int node) &#123; stack1.push(node);&#125;public int pop() &#123; if (stack2.empty()) &#123; while (!stack1.empty()) &#123; int temp = stack1.pop(); stack2.push(temp); &#125; &#125; int temp = stack2.peek(); stack2.pop(); return temp;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 4.重建二叉树]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%204.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content type="text"><![CDATA[4.重建二叉树题目输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路这就和二叉树的性质相关了，由前序和中序可以确定一棵树，前序的第一个就是树的根，然后中序找到这个根，在前面的就是左子树，在后面的就是右子树。然后就先不管别的，直接深挖，左子树的前序和中序都有那就能得到左子树的根节点，一层一层，如果长度为0就不存在，为null。这里函数的输入是两个数组，递归的输入还是两个数组，所以截取数组计算，不然可以用索引值，效果一样。 代码123456789101112131415public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if (pre.length == 0 || in.length == 0) &#123; return null; &#125; TreeNode root = new TreeNode(pre[0]); for (int i = 0; i &lt; in.length; i++) &#123; if (pre[0] == in[i]) &#123; root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i)); root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length)); &#125; &#125; return root;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</url>
    <content type="text"><![CDATA[动态规划定义分治法：将问题划分为不相交的子问题,递归的求解子问题,在将它们的解组合起来,求出原问题的解。 动态规划：通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划和递归的最大的区别，就是在碰到重叠子问题时，是否只需要计算一次。 过程 拆分子问题，把整体问题拆成可以用递推或是递归实现的小问题，在某一状态下最佳选择是什么 定义问题和状态之间的关系，寻找到状态转移方程 进行编码 例题(LeetCode746)数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。注意： cost 的长度将会在 [2, 1000]。每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 解法上升到某级(i)有两种方法，从i-1级上一步，从i-2级上两步，那么就可以知道状态转移方程了dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]，顺着这个思路从3开始，最后再输出一下就行。 代码：1234567891011public int minCostClimbingStairs(int[] cost) &#123; int len = cost.length; int dp[] = new int[len + 1]; dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; len; i++) &#123; dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]; &#125; return Math.min(dp[len - 1], dp[len - 2]);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 746. Min Cost Climbing Stairs]]></title>
    <url>%2FLeetCode%20746.%20Min%20Cost%20Climbing%20Stairs.html</url>
    <content type="text"><![CDATA[746. Min Cost Climbing Stairs （使用最小花费爬楼梯）链接https://leetcode-cn.com/problems/min-cost-climbing-stairs 题目数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。注意： cost 的长度将会在 [2, 1000]。每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 思路动态规划题目，上升到某级(i)有两种方法，从i-1级上一步，从i-2级上两步，那么就可以知道状态转移方程了dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]，顺着这个思路从3开始，最后再输出一下就行。 代码：1234567891011public int minCostClimbingStairs(int[] cost) &#123; int len = cost.length; int dp[] = new int[len + 1]; dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; len; i++) &#123; dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]; &#125; return Math.min(dp[len - 1], dp[len - 2]);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE.html</url>
    <content type="text"><![CDATA[数据结构-图定义图是一些顶点的集合，这些顶点通过一些边想连接，顶点用圈表示，边通过线表示，是一个多对多的数据结构。可以拆分，就是点集V和边集E的集合。 特点边可以是有方向的，只能单向前进，也可能是双向的，可以来回运动，也有的边带有权重，模拟为长度什么的物理量。 存储方式 邻接表每一个顶点会存储一个从该节点开始的链表，比如说A可以到BC，那么就是A-&gt;B-&gt;C。 邻接矩阵用一个矩阵来存储，假设A能到B且距离为5，那么m[0][1]=5. 相关术语 有向图：边是有方向的图 无向图：边没有方向，正反都可 简单图：不存在重复边，顶点不能直接到自身 完全图：任意两点都存在边(有向的话要有两条方向相反的边) 子图：点集和边集都是原图的子集，且构成图 顶点的度：以该顶点为一个端点的边的数目]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.html</url>
    <content type="text"><![CDATA[数据结构-树定义树是一种非线性的数据结构，由n(n&gt;0)个有限节点组成，是一个有层次关系的集合，像一棵倒立着的树。 特点 每个节点都只有有限个子节点或无子节点 没有父节点的节点称为根节点 每一个非根节点有且只有一个父节点 除了根节点外，每个子节点可以分为多个不相交的子树 树里面没有环路(cycle) 相关术语 节点：每个元素都叫节点 根节点：树的顶端节点 父子节点：除了根节点以外每个节点都可以找到向上的唯一节点为父节点，下方就是子节点。 兄弟节点：拥有相同父节点的节点 叶节点：没有子树的节点 子树：每个子节点作为根节点所产生的树 节点的度：节点含有子节点的数量 树的度：最大的节点的度 森林：若干棵不相交的树组成的集合 存储结构1234public class tree&#123; private int data; private int parent;&#125; 这里只是简单的写了一下，因为除根外必有一个父节点，所以这里就写了两部分，值域和指针域，一个存放节点的值，一个指向父节点，具体的操作等我复习到二叉树之类再细写。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈和队列]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html</url>
    <content type="text"><![CDATA[数据结构-栈和队列定义栈和队列是两种特殊的线性表。栈(Stack)是一种后进先出的数据结构,可以想象成一个瓶子，先进去的在下层，要后出来。而队列(Queue)则是先进先出，就像排队一样，先进队伍的先出来。 栈的操作 Stack() 创建一个空的栈 void push(T s) 往栈中添加一个新的元素 T pop() 移除并返回最近添加的元素 T peek() 返回最近添加的元素，不删除 boolean isempty() 栈是否为空 int size() 栈中元素的个数 队列操作 Queue() 创建一个空的栈 T Add() 往队列中添加一个新的元素 T remove() 移除最早添加的元素 T element() 返回最早添加的元素，不删除 boolean isempty() 队列是否为空 int size() 队列中元素的个数]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8.html</url>
    <content type="text"><![CDATA[数据结构-线性表定义线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。 线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。 特征 集合中必存在唯一的一个“第一元素”。 集合中必存在唯一的一个 “最后元素” 。 除最后一个元素之外，均有唯一的后继(后件)。 除第一个元素之外，均有唯一的前驱(前件)。 存储方式与优缺点 顺序存储(顺序表) 优点： 1.空间利用率高 2.存取速度快 缺点： 1.插入删除操作较慢 2.初始要定义长度，可能溢出 链式存储(链表) 优点： 1.插入删除操作较快 2.没有空间限制 缺点： 1.空间消耗多 2.存取速度慢 基本操作 求当前元素个数 插入 删除 查找 判断是否为空]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 3.从尾到头打印链表]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%203.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[3.从尾到头打印链表题目输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 思路思路给了两种，一种是递归，先到下一个结点再输出自身的值，但是可能会存在溢出情况。还有一种就是用栈，先进后出，负负得正，就行了。(两个问题，1.牛客网在线评测头文件要自己打，这个真没想到 2.注意空链表的判断) 代码12345678910111213141516171819public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); if (listNode == null) &#123; return arrayList; &#125; while (true) &#123; int temp = listNode.val; stack.push(temp); if (listNode.next == null) &#123; break; &#125; listNode = listNode.next; &#125; while (!stack.isEmpty()) &#123; arrayList.add(stack.pop()); &#125; return arrayList;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 2.替换空格]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%202.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html</url>
    <content type="text"><![CDATA[2.替换空格题目请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路书上的思路，是先记录空格位置，然后从后往前转移字符串，遇到空格就输出%20，但是java的字符串简单了很多，用一个StringBuffer就行了。 代码1234567891011public String replaceSpace(StringBuffer str) &#123; StringBuffer ans = new StringBuffer(); for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) != &apos; &apos;) &#123; ans.append(str.charAt(i)); &#125; else &#123; ans.append(&quot;%20&quot;); &#125; &#125; return ans.toString();&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 1.二维数组中的查找]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%201.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html</url>
    <content type="text"><![CDATA[1.二维数组中的查找题目在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路思路主要是，从左下或者右上两个角落开始比较，找到了自然就不用继续了，找不到的话一次可以排除一行或一列，这里我变量命名有些随意，但应该不影响阅读。 （新坑，剑指offer上面的题目的java解法，用博客记录，每个代码都是牛客网上面能通过的，希望能给大家带来些许帮助） 代码12345678910111213141516public boolean Find(int target, int[][] array) &#123; int x0 = 0, y0 = 0; int x1 = array.length - 1, y1 = array[0].length - 1; boolean ans = false; while (x1 &gt;= x0 &amp;&amp; y1 &gt;= y0) &#123; if (array[x0][y1] == target) &#123; ans = true; break; &#125; else if (array[x0][y1] &lt; target) &#123; x0++; &#125; else &#123; y1--; &#125; &#125; return ans;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不知道来源的题目1]]></title>
    <url>%2F%E4%B8%8D%E7%9F%A5%E9%81%93%E6%9D%A5%E6%BA%90%E7%9A%84%E9%A2%98%E7%9B%AE1.html</url>
    <content type="text"><![CDATA[不知道来源的题目1题目有两个数组 A、B，长度都为 N，值为任意整数，无序，要求，通过交换 A、B 中的元素，使得 A 数组元素之和与 B 数组元素之和之间的差值最小。完成代码的同时，写出数组 [100,99,98,1,2, 3]和[1,2,3,4,5,40]交换后的结果。 思路解法多种多样，但是我真没想出来什么特别合适的，采用了一种比较繁琐的方法。首先计算两个数组的差值，之后尝试交换，只要能让差值减小，就交换，一直到没有这种可能性再结束，理论上这就是要的答案。 代码1234567891011121314151617181920212223242526272829303132333435public static void change(int[] a, int[] b, int n, int before) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int after = before - 2 * (a[i] - b[j]); if (Math.abs(after) &lt; Math.abs(before)) &#123; int temp = a[i]; a[i] = b[j]; b[j] = temp; change(a, b, n, after); return; &#125; &#125; &#125;&#125;public static void main(String[] args) &#123; int[] a = new int[]&#123;100, 99, 98, 1, 2, 3&#125;; int[] b = new int[]&#123;1, 2, 3, 4, 5, 40&#125;; int suma = 0; int sumb = 0; int len = a.length; for (int i = 0; i &lt; len; i++) &#123; suma += a[i]; sumb += b[i]; &#125; change(a, b, len, Math.abs(suma - sumb)); for (int i = 0; i &lt; len; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(); for (int i = 0; i &lt; len; i++) &#123; System.out.print(b[i] + &quot; &quot;); &#125;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap和Hashtable的区别]]></title>
    <url>%2FHashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[HashMap和Hashtable的区别HashMap和Hashtable这两个是集合框架中比较常见的问题，所以我做了些总结便于回顾。 1.继承Hashtable 继承自 Dictiionary 而 HashMap继承自AbstractMap 2.键值要求hashtable不允许空值与空键，但是hashmap允许一个空键和任意数量空值。 3.contains方法hashmap去除了contains方法，改为了containsValue和containsKey，但是hashtable这三个方法都有。 4.线程安全HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable。 5.使用建议正常情况下建议使用hashmap，如果是多线程建议选择concurrentHashMap。源码部分等到我更深入的学习的时候会添加。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[非对称加密-RSA算法]]></title>
    <url>%2F%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-RSA%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[非对称加密-RSA算法非对称传统算法是对称加密，共用密钥，非对称加密就使用了两个秘钥，一个公钥加密，一个私钥解密。 加密过程 随机选取两个质数 p，q 计算公共模数 n = p*q 欧拉函数 φ(n) = (p-1) * (q-1) 计算公钥 e &lt; φ(n),二者互质 计算私钥 d 使得 e * d % φ(n) = 1 公钥使用(e,n)私钥使用(d,n) 公钥加密 c = m^e mod n(m是原文内容，c是加密后的内容) 私钥解密 m = c^d mod n 代码至于RSA算法为什么有效，这些比较专业的我不是太了解，我只了解了大概用法。我这里只写了一个帮助理顺思路的模拟代码，真的要用的话建议使用官方的代码。 12345678910111213141516171819202122232425262728public static void rsa() &#123; int p = 3; int q = 11; int n = p * q; //假装q就是那个符号 int qn = (p - 1) * (q - 1); //公钥私钥 int e = 3; int d = 7; //原文 int m = 9; //加密后的 int c = (int) (Math.pow(m, e) % n); System.out.println(c); //解密后的 int m1 = (int) (Math.pow(c, d) % n); System.out.println(m1); if (m == m1) &#123; System.out.println(&quot;解密成功&quot;); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[递归迭代与斐波那契数列]]></title>
    <url>%2F%E9%80%92%E5%BD%92%E8%BF%AD%E4%BB%A3%E4%B8%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html</url>
    <content type="text"><![CDATA[递归迭代与斐波那契数列概念递归: 程序调用自身的编程技巧称为递归,是函数自己调用自己. 迭代: 利用变量的原值推算出变量的一个新值. 区别如果递归是自己调用自己(A调用A)的话,迭代就是A不停的调用B. 代码这里用了斐波那契数列数列，第一项为0第二项为1，之后每一项都是前两项的和。对于递归反复调用自己，这里其实可以拿一个数组存储答案的。迭代的话一直都是三个变量，一直在循环运算。 1234567891011121314151617181920212223242526272829public static int fic_1(int n) &#123; //递归 if (n == 1) &#123; return 0; &#125; else if (n == 2) &#123; return 1; &#125; else &#123; return fic_1(n - 1) + fic_1(n - 2); &#125;&#125;public static int fic_2(int n) &#123; //迭代 int a2 = 0; if (n == 1) &#123; return 0; &#125; else if (n == 2) &#123; return 1; &#125; else &#123; int a0 = 0, a1 = 1; for (int i = 3; i &lt;= n; i++) &#123; a2 = a0 + a1; a0 = a1; a1 = a2; &#125; return a2; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java大数加法乘法]]></title>
    <url>%2Fjava%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95%E4%B9%98%E6%B3%95.html</url>
    <content type="text"><![CDATA[java大数加法乘法前言正常情况下我们调用加法乘法使用符号就行了，但是如果超出限制了，那就只能调用BigDecimal里面的函数了，但是有的时候oj考察的就是希望自己实现，所以就可以采用别的方法。 加法加法比较简单，直接字符串转置，差的位补0，然后一位一位加，最后注意进位。 1234567891011121314151617181920212223242526272829303132333435363738public static String add(String s1, String s2) &#123; StringBuilder a = new StringBuilder(s1); StringBuilder b = new StringBuilder(s2); a.reverse(); b.reverse(); int m = a.length(); int n = b.length(); int max = Math.max(m, n); if (m &lt; n) &#123; for (int i = m; i &lt; n; i++) &#123; a.append(&apos;0&apos;); &#125; &#125; else &#123; for (int i = n; i &lt; m; i++) &#123; b.append(&apos;0&apos;); &#125; &#125; int[] ans = new int[max + 1]; for (int i = 0; i &lt; max; i++) &#123; ans[i] = (a.charAt(i) - &apos;0&apos;) + (b.charAt(i) - &apos;0&apos;); &#125; for (int i = 0; i &lt; max; i++) &#123; ans[i + 1] += ans[i] / 10; ans[i] %= 10; &#125; StringBuilder result = new StringBuilder(); for (int i = 0; i &lt; max; i++) &#123; result.append(ans[i]); &#125; if(ans[max]!=0) &#123; result.append(ans[max]); &#125; return result.reverse().toString();&#125; 乘法以12*12为例子，第1位的两个2相乘，结果应该放在第1位，是4，然后第一个数的1和第二个数的2相乘是2，应该是第二位，2+2，然后两个1相乘，1应该放在第3位，结果是144，这个没有进位，如果有进位需要遍历一下。 123456789101112131415161718192021222324252627public static String mul(String s1, String s2) &#123; StringBuilder a = new StringBuilder(s1); StringBuilder b = new StringBuilder(s2); a.reverse(); b.reverse(); int m = a.length(); int n = b.length(); int[] ans = new int[m + n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; ans[i + j] += (a.charAt(i) - &apos;0&apos;) * (b.charAt(j) - &apos;0&apos;); &#125; &#125; for (int i = 0; i &lt; ans.length - 1; i++) &#123; ans[i + 1] += ans[i] / 10; ans[i] %= 10; &#125; StringBuilder result = new StringBuilder(); for (int i = 0; i &lt; ans.length - 1; i++) &#123; result.append(ans[i]); &#125; return result.reverse().toString(); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java进制转换]]></title>
    <url>%2Fjava%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[java进制转换前言我们正常使用的是十进制，计算机使用的是二进制，初次之外还有很多不同的进制，但是转换方法都相似，这里就整理一下java的进制转换。 调用函数 十进制转十六进制 Integer.toHexString(int i) 十进制转八进制 Integer.toOctalString(int i) 十进制转二进制 Integer.toBinaryString(int i) 十六进制转十进制(二进制八进制类似) Integer.valueOf(“FFFF”,16).toString() 写的代码这里还写了一段java代码，可以用于进行16进制之内的转换，如果想要增加，只要修改radix数组即可。两个函数，一个是其他进制转十进制的，一个是十进制转任意进制的。用的都是基础算法，按位乘和取余。(话说我没有考虑过输入异常，比如0进制什么的) 1234567891011121314151617181920212223242526272829303132333435static char[] radix = new char[]&#123;&apos;0&apos;,&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;;static int transRadixtoTen(String num, int fromRadix) &#123; StringBuilder s = new StringBuilder(num); int number = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char temp = s.charAt(i); if (temp &lt;= &apos;9&apos; &amp;&amp; temp &gt;= &apos;0&apos;) &#123; number += temp - &apos;0&apos;; &#125; else if (temp &lt;= &apos;z&apos; &amp;&amp; temp &gt;= &apos;a&apos;) &#123; number += temp - &apos;a&apos; + 10; &#125; else if (temp &lt;= &apos;Z&apos; &amp;&amp; temp &gt;= &apos;A&apos;) &#123; number += temp - &apos;A&apos; + 10; &#125; if (i != s.length() - 1) &#123; number *= fromRadix; &#125; &#125; return number;&#125;static String transRadixtoOther(String num, int fromRadix, int toRadix) &#123; int number = transRadixtoTen(num, fromRadix); System.out.println(number); StringBuilder s = new StringBuilder(); while (number != 0) &#123; s.append(radix[number % toRadix]); number = number / toRadix; &#125; return s.reverse().toString();&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 209. Minimum Size Subarray Sum]]></title>
    <url>%2FLeetCode%20209.%20Minimum%20Size%20Subarray%20Sum.html</url>
    <content type="text"><![CDATA[209. Minimum Size Subarray Sum（无重复字符的最长子串）链接https://leetcode-cn.com/problems/minimum-size-subarray-sum 题目给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例: 输入: s = 7, nums = [2,3,1,2,4,3] 输出: 2 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 思路滑动窗口的题目，不过这里是数字，相对简单一点。这里设置了两个指针，left就代表左侧，right代表右侧，如果和大于s，就更新min并且减去最左侧；如果小于s，就增加最右侧，最后输出min。这里有一个坑，就是有可能不存在，所以最后要对于min进行一个判断。 代码123456789101112131415161718public int minSubArrayLen(int s, int[] nums) &#123; int len = nums.length; int sum = 0; int min = Integer.MAX_VALUE; int left = 0; for (int right = 0; right &lt; len; right++) &#123; sum += nums[right]; while (sum &gt;= s) &#123; min = Math.min(min, right - left + 1); sum -= nums[left]; left++; &#125; &#125; if(min== Integer.MAX_VALUE)&#123; return 0; &#125; return min;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3. Longest Substring Without Repeating Characters]]></title>
    <url>%2FLeetCode%203.%20Longest%20Substring%20Without%20Repeating%20Characters.html</url>
    <content type="text"><![CDATA[3. Longest Substring Without Repeating Characters（无重复字符的最长子串）链接https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb” 输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb” 输出: 1 解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew” 输出: 3 解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 思路滑动窗口的题目，做出来不是很难，但是要优化就很麻烦。这里设置了两个指针，同时借助了hashmap来去重。循环比较每一个字符，如果字符不存在就加入，如果存在了，就看在left左还是右，左侧无需在意，右侧更新，最后输出max即可。（这里没有和left比较，而是直接取了较大值，left就代表当前字符串左侧，right代表当前字符串右侧） 代码1234567891011121314151617public static int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if (len == 0) &#123; return 0; &#125; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; int left = 0; for (int right = 0; right &lt; len; right++) &#123; if (map.containsKey(s.charAt(right))) &#123; left = Math.max(left, map.get(s.charAt(right)) + 1); &#125; map.put(s.charAt(right), right); max = Math.max(max, right - left + 1); &#125; return max;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11. Container With Most Water]]></title>
    <url>%2FLeetCode%2011.%20Container%20With%20Most%20Water.html</url>
    <content type="text"><![CDATA[11. Container With Most Water（反转字符串中的元音字母）链接https://leetcode-cn.com/problems/container-with-most-water 题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 思路这题思路也很清晰，就是要求最大值，方法不少，首先就是最简单的穷举，把所有可能值都算出来，也可以采用动态规划的思想，找到最合适的方法。面积取决于两个值，左右距离，和两边的较小值，当两边距离不等的时候，将较小值更换可能获得更大的面积，思路就是这样，一直选择较小的往内移动，直到两边相遇。 代码12345678910111213public int maxArea(int[] height) &#123; int left = 0, right = height.length - 1; int max = 0; while (left &lt; right) &#123; max = Math.max(max, (right - left) * Math.min(height[left], height[right])); if (height[left] &lt; height[right]) &#123; left++; &#125; else &#123; right--; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 345. Reverse Vowels of a String]]></title>
    <url>%2FLeetCode%20345.%20Reverse%20Vowels%20of%20a%20String.html</url>
    <content type="text"><![CDATA[345. Reverse Vowels of a String（反转字符串中的元音字母）链接https://leetcode-cn.com/problems/reverse-vowels-of-a-string 题目编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello” 输出: “holle”示例 2: 输入: “leetcode” 输出: “leotcede”说明:元音字母不包含字母”y”。 思路也是双指针，不过要注意大小写都可以，所以额外增加了一个判断函数判断是否需要反转，别的和344题基本相同。 代码12345678910111213141516171819202122232425public static boolean find(char c) &#123; return !(c == &apos;a&apos; || c == &apos;o&apos; || c == &apos;e&apos; || c == &apos;i&apos; || c == &apos;u&apos; || c == &apos;A&apos; || c == &apos;O&apos; || c == &apos;E&apos; || c == &apos;I&apos; || c == &apos;U&apos;);&#125;public static String reverseVowels(String s) &#123; char[] arr = s.toCharArray(); int left = 0, right = arr.length - 1; while (left &lt; right) &#123; while (left &lt; arr.length &amp;&amp; find(arr[left])) &#123; left++; &#125; while (right &gt;= 0 &amp;&amp; find(arr[right])) &#123; right--; &#125; if (left &gt;= right) &#123; break; &#125; char temp = arr[right]; arr[right--] = arr[left]; arr[left++] = temp; &#125; String result = new String(arr); return result;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 344. Reverse String]]></title>
    <url>%2FLeetCode%20344.%20Reverse%20String.html</url>
    <content type="text"><![CDATA[344. Reverse String（反转字符串）链接https://leetcode-cn.com/problems/reverse-string 题目编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[“h”,”e”,”l”,”l”,”o”] 输出：[“o”,”l”,”l”,”e”,”h”]示例 2： 输入：[“H”,”a”,”n”,”n”,”a”,”h”] 输出：[“h”,”a”,”n”,”n”,”a”,”H”] 思路就硬转呗，双指针，一头一尾直接转换位置，当指针相遇就结束。 代码12345678910public void reverseString(char[] s) &#123; int left = 0, right = s.length - 1; while (left &lt; right) &#123; char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 215. Kth Largest Element in an Array]]></title>
    <url>%2FLeetCode%20215.%20Kth%20Largest%20Element%20in%20an%20Array.html</url>
    <content type="text"><![CDATA[215. Kth Largest Element in an Array（数组中的第K个最大元素）链接https://leetcode-cn.com/problems/kth-largest-element-in-an-array 题目在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 思路一道数组题目，解法多种。最简单的就是直接排序，然后找到那个数，直接完成，就是效率相对较低。这里用的是优先队列建堆，最小堆，小的数字在堆顶，然后一个一个往里面加数字，每当堆的规模大于k，就去除最小的数字（堆顶），数字处理完之后的堆顶就是所需数字。 代码1234567891011public static int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n1 - n2); for (int n : nums) &#123; heap.add(n); if (heap.size() &gt; k) &#123; heap.poll(); &#125; &#125; return heap.poll();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 88. Merge Sorted Array]]></title>
    <url>%2FLeetCode%2088.%20Merge%20Sorted%20Array.html</url>
    <content type="text"><![CDATA[88. Merge Sorted Array（合并两个有序数组）链接https://leetcode-cn.com/problems/merge-sorted-array 题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 思路一道数组题目，解法多种。可以直接合并再排序，也可以两个数组开头慢慢遍历，倒是官方给了一种很cool的题解，直接从数组后方开始。三指针，两个指针指向两个数组最后的数字，一个指针指向数组1的末尾，比较之后将数字放到数组1的末尾，不需要额外空间，最后将数组2未使用的数字（如果存在的话）放到数组1的前面即可。（这题我去年好像做过，还没做出来233333） 代码1234567891011121314151617181920public static void merge(int[] nums1, int m, int[] nums2, int n) &#123; int index = m + n - 1; int m1 = m - 1; int n1 = n - 1; while (m1 &gt;= 0 &amp;&amp; n1 &gt;= 0) &#123; if (nums1[m1] &lt; nums2[n1]) &#123; nums1[index] = nums2[n1]; n1--; &#125; else &#123; nums1[index] = nums1[m1]; m1--; &#125; index--; &#125; while (n1 &gt;= 0) &#123; nums1[index] = nums2[n1]; n1--; index--; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 75. Sort Colors]]></title>
    <url>%2FLeetCode%2075.%20Sort%20Colors.html</url>
    <content type="text"><![CDATA[75. Sort Colors（颜色分类）链接https://leetcode-cn.com/problems/sort-colors 题目给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2]进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 思路一道数组题目，解法多种。说不让用代码库中的排序函数，那自己写一个应该不算违规吧23333.只有三种数字，012，那么可以遍历统计每个数字的数量，之后直接更改。也可以用三指针法，index012，一共三个变量，index0和1初始值是0，index2初始值是nums.length-1.遍历使用index1，发现那个数字为0，就和index0的数交换，为2就和index2的数交换，这里要注意，index2换过来的数还需要再判断一下。 代码123456789101112131415161718192021 public static void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;public void sortColors(int[] nums) &#123; int index0 = 0, index1 = 0, index2 = nums.length - 1; while (index1 &lt;= index2) &#123; if (nums[index1] == 0) &#123; swap(nums, index1, index0); index0++; index1++; &#125; else if (nums[index1] == 2) &#123; swap(nums, index1, index2); index2--; &#125; else &#123; index1++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 581. Shortest Unsorted Continuous Subarray]]></title>
    <url>%2FLeetCode%20581.%20Shortest%20Unsorted%20Continuous%20Subarray.html</url>
    <content type="text"><![CDATA[581. Shortest Unsorted Continuous Subarray（最短无序连续子数组）链接https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray 题目给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例 1: 输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5 解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。说明 : 输入的数组长度范围在 [1, 10,000]。输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。 思路这题方法多种，可以排序之后对比，也可以用别的方法。首先遍历，由前往后由后往前，分别确定两个边界。前向后时寻找右边界，每个数字判断是否小于前方最大值，若小于，就代表这个数需要排序，若大于，就代表这个数可以放在当前位置，若最后全为升序排列那就不用排序，后向前同理。以输入示范，首先max为2，之后往后遍历，6&gt;2,max=6,4&lt;6,需要排序，一直往后，right=5，15大于前方所有数字，无需排序。反向遍历，2小于后方所有数，left=1，5-1+1=5. 代码123456789101112131415161718192021public int findUnsortedSubarray(int[] nums) &#123; int len = nums.length; int max = nums[0]; int min = nums[len - 1]; int left = 0, right = -1; for (int i = 0; i &lt; len; i++) &#123; if (max &gt; nums[i]) &#123; right = i; &#125; else &#123; max = nums[i]; &#125; &#125; for (int i = len - 1; i &gt; -1; i--) &#123; if (min &lt; nums[i]) &#123; left = i; &#125; else &#123; min = nums[i]; &#125; &#125; return right - left + 1;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 20. Valid Parentheses]]></title>
    <url>%2FLeetCode%2020.%20Valid%20Parentheses.html</url>
    <content type="text"><![CDATA[20. Valid Parentheses（有效的括号）链接https://leetcode-cn.com/problems/valid-parentheses 题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()” 输出: true示例 2: 输入: “()[]{}” 输出: true示例 3: 输入: “(]” 输出: false示例 4: 输入: “([)]” 输出: false示例 5: 输入: “{[]}” 输出: true 思路判断括号嘛，我用了最基础的解法，借助栈一个一个找，如果为左括号则入栈，若为右括号且栈顶为对应左括号则出栈，不然直接返回false，一直到遍历结束，如果栈为空就返回true。效率虽然不是很高但是思路很清晰。 代码123456789101112131415161718192021222324252627public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == &apos;)&apos; &amp;&amp; !stack.isEmpty()) &#123; if (stack.peek() == &apos;(&apos;) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; else if (c == &apos;]&apos; &amp;&amp; !stack.isEmpty()) &#123; if (stack.peek() == &apos;[&apos;) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; else if (c == &apos;&#125;&apos; &amp;&amp; !stack.isEmpty()) &#123; if (stack.peek() == &apos;&#123;&apos;) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; else &#123; stack.push(c); &#125; &#125; return stack.isEmpty();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 53. Maximum Subarray]]></title>
    <url>%2FLeetCode%2053.%20Maximum%20Subarray.html</url>
    <content type="text"><![CDATA[53. Maximum Subarray（最大子序和）链接https://leetcode-cn.com/problems/maximum-subarray 题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 思路没尝试分治法，那个有点麻烦，等做到别的分治时候再做。这边有动态规划的思想在里面，从头到尾遍历，如果和小于0，那么直接无视，重新开始，和大于0，就加上之前的和。每次都保留当前最大的和，直到输出。 代码12345678910111213public static int maxSubArray(int[] nums) &#123; int ans = nums[0]; int sum = 0; for (int num : nums) &#123; if (sum &gt;= 0) &#123; sum += num; &#125; else &#123; sum = num; &#125; ans = Math.max(sum, ans); &#125; return ans; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 461. Hamming Distance]]></title>
    <url>%2FLeetCode%20461.%20Hamming%20Distance.html</url>
    <content type="text"><![CDATA[461. Hamming Distance（汉明距离）链接https://leetcode-cn.com/problems/hamming-distance 题目两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例: 输入: x = 1, y = 4 输出: 2 解释: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 思路这题的名词也就是转换一下，需要我们找到二进制位的不同，这时候异或最简单，直接找到不同位，然后可以按位寻找，也可以直接和1进行与运算，然后右移。 代码1234567891011 public static int hammingDistance(int x, int y) &#123; int xor = x ^ y; int num = 0; while (xor != 0) &#123; if ((xor &amp; 1) == 1) &#123; num++; &#125; xor = xor &gt;&gt; 1; &#125; return num;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 448. Find All Numbers Disappeared in an Array]]></title>
    <url>%2FLeetCode%20448.%20Find%20All%20Numbers%20Disappeared%20in%20an%20Array.html</url>
    <content type="text"><![CDATA[448. Find All Numbers Disappeared in an Array（找到所有数组中消失的数字）链接https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array 题目给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例: 输入: [4,3,2,7,8,2,3,1] 输出: [5,6] 思路这题的题意很简单，就是要找到缺失的数字，但是思路很巧妙，对于每个数字，都设置一个位置，就像例子一样，第一个数字为4，就将第四个数字设置为-7，一遍循环之后，数组就成为[-4,-3,-2,-7,8,2,-3,-1],然后第二次遍历，如果数字为正，就代表数组中不存在这个数，记录到答案中即可，这里要注意数组从0开始，而数字从1开始。 代码1234567891011121314 public static List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; for(int i=0;i&lt;nums.length;i++)&#123; int temp = Math.abs(nums[i]); nums[temp-1]=-Math.abs(nums[temp-1]); &#125; List&lt;Integer&gt;ans = new ArrayList(nums.length); for(int i=0;i&lt;nums.length;i++) &#123; if(nums[i]&gt;0)&#123; ans.add(i+1); &#125; &#125; return ans;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[排序算法总结前言 所谓排序算法，即通过特定的算法因式将一组或多组数据按照既定模式进行重新排序。这种新序列遵循着一定的规则，体现出一定的规律，因此，经处理后的数据便于筛选和计算，大大提高了计算效率. 这里我就整理一下几种常用的排序算法，复杂度什么放在最后部分。 [目录] 冒泡排序(BubbleSort) 选择排序(SelctionSort) 插入排序(InsertionSort) 希尔排序(ShellSort) 快速排序(Quicksort) 归并排序(MergeSort) 堆排序(HeapSort) 基数排序(等待更新) 桶排序(等待更新) 计数排序(等待更新) 总结与比较 冒泡排序(BubbleSort)思想两个数比较大小，大的冒泡向后，小的向前，一直到运行结束。 代码1234567891011121314public void BubbleSort(int[] nums) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[i] &gt; nums[j]) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; &#125; &#125; 选择排序(SelctionSort)思想选择排序的思路就是找到最小的，放在数组的最前面，之后找第二小的，放在第二位，这里可以采用交换的方法，减少一点运算量。(也可以找最大的放在最后面，思路相同) 代码123456789101112131415161718public static void SelctionSort(int[] nums) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; int min = nums[i]; int index = i; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] &lt; min) &#123; min = nums[j]; index = j; &#125; &#125; int temp = nums[i]; nums[i] = nums[index]; nums[index] = temp; &#125;&#125; 插入排序(InsertionSort)思想与选择排序相似，对于该数字，找到应该插入的位置，确保数组前方一直保持有序，前方有序后方无序，一个一个插入。(这里我里面循环是从下标1开始的，因为第一个无所谓有序无序) 代码123456789101112131415public static void InsertionSort(int[] nums) &#123; int len = nums.length; for (int i = 1; i &lt; len; i++) &#123; int value = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt; value) &#123; nums[j + 1] = nums[j]; j--; &#125; nums[j + 1] = value; &#125; &#125; 希尔排序(ShellSort)思想希尔排序难度一下子就加大了不少，相似与插入排序，但是这是一下子进行多个插入排序，等到基本有序的时候再缩小范围。这里先设置了一个增量，为长度的一半，假设数组长度为8，那么一开始就是第1个和第5个插入排序，2-6，3-7，4-8.第一圈结束。然后长度为2，就是1-3-5-7和2-4-6-8排序，最后全部排序。这块建议上网找图解，文字版的确不适合理解。 代码12345678910111213141516171819202122public static void ShellSort(int[] nums) &#123; int len = nums.length; int len_sort = len; while (len_sort &gt; 1) &#123; len_sort = len_sort / 2; for (int t = 0; t &lt; len_sort; t++) &#123; for (int i = t + len_sort; i &lt; len; i = i + len_sort) &#123; for (int j = i; j &gt; t; j = j - len_sort) &#123; if (nums[j] &lt; nums[j - len_sort]) &#123; int temp = nums[j]; nums[j] = nums[j - len_sort]; nums[j - len_sort] = temp; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; &#125; 快速排序(Quicksort)思想算是利用分治法，先选出一个key值，然后把小于key的放在左边，大于key的放在右边，然后左右两边都进行这种操作，一直到不能再次分割。这个算是比较重要且常用的排序方法，记住要递归调用，代码虽然复杂但是思路还是比较清晰的。 代码1234567891011121314151617181920212223242526public static void Quicksort(int[] nums, int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int i = l, j = r; int key = nums[l]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt;= key) &#123; j--; &#125; if (i &lt; j) &#123; nums[i] = nums[j]; i++; &#125; while (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123; i++; &#125; if (i &lt; j) &#123; nums[j] = nums[i]; j--; &#125; &#125; nums[i] = key; Quicksort(nums, l, i - 1); Quicksort(nums, i + 1, r);&#125; 归并排序(MergeSort)思想递归分治的思想，将数组分为待排序的子数组，等到子数组排序好了就合并，子数组分到最小的时候进行排序，两两合并，最后有序。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243public static void Merge(int[] nums, int start, int mid, int end) &#123; int i = start; int j = mid + 1; int k = 0; int[] temp = new int[end - start + 1]; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; if (nums[i] &lt; nums[j]) &#123; temp[k] = nums[i]; i++; k++; &#125; else &#123; temp[k] = nums[j]; j++; k++; &#125; &#125; while (i &lt;= mid) &#123; temp[k] = nums[i]; k++; i++; &#125; while (j &lt;= end) &#123; temp[k] = nums[j]; k++; j++; &#125; for (int t = 0; t &lt; temp.length; t++) &#123; nums[start + t] = temp[t]; &#125; &#125; public static void MergeSort(int[] nums, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int mid = start + (end - start) / 2; MergeSort(nums, start, mid); MergeSort(nums, mid + 1, end); Merge(nums, start, mid, end); &#125; 堆排序(HeapSort)思想堆排序借助了堆的性质，假设使用最大堆，那么堆顶就是最大值，取下最大值进行堆的调整，就能得到次大值，直到堆为空，就可以得到排序的结果。可以直接借助数据结构建立一个堆，也可以自己写一个模拟堆的运行。 代码123456789101112131415161718192021222324252627282930313233public static void HeapSort(int[] nums) &#123; int len = nums.length; for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(nums, i, len); &#125; for (int j = len - 1; j &gt; 0; j--) &#123; int temp = nums[j]; nums[j] = nums[0]; nums[0] = temp; adjustHeap(nums, 0, j); &#125;&#125;public static void adjustHeap(int[] nums, int i, int length) &#123; int temp = nums[i]; for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; nums[k] &lt; nums[k + 1]) &#123; k++; &#125; if (nums[k] &gt; temp) &#123; nums[i] = nums[k]; i = k; &#125; else &#123; break; &#125; &#125; nums[i] = temp;&#125; 基数排序(等待更新)思想代码桶排序(等待更新)思想代码计数排序(等待更新)思想代码总结与比较总结有很多种排序方法，我这里只写了一些基础的，还有桶排序，基数排序计数排序什么的我没有写上去，以后有机会在写吧。算法没有绝对的好坏之分，我们要做的是选择当前状况下的最合适的算法。 比较 排序方法 时间复杂度 空间复杂度 稳定性 比较类排序 冒泡排序 O(n2) O(1) 稳定 是 选择排序 O(n2) O(1) 不稳定 是 插入排序 O(n2) O(1) 稳定 是 希尔排序 O(nlogn) O(1) 不稳定 是 快速排序 O(nlogn) O(n) 不稳定 是 归并排序 O(nlogn) O(logn) 稳定 是 堆排序 O(nlogn) O(1) 不稳定 是 基数排序 O(n*k) O(n+k) 稳定 否 桶排序 O(n+k) O(n+k) 稳定 否 计数排序 O(n+k) O(k) 稳定 否 其他这里还做了一个主函数用于排序的，随机生成数组并排序，大家可以试试。 12345678910public static void main(String[] args) &#123; int[] array = new int[20]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = (int) (Math.random() * 1000); &#125; sort(array); for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + &quot; &quot;); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 976. Largest Perimeter Triangle]]></title>
    <url>%2FLeetCode%20976.%20Largest%20Perimeter%20Triangle.html</url>
    <content type="text"><![CDATA[976. Largest Perimeter Triangle（三角形的最大周长）链接https://leetcode-cn.com/problems/largest-perimeter-triangle 题目给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0。 示例 1： 输入：[2,1,2] 输出：5示例 2： 输入：[1,2,1] 输出：0示例 3： 输入：[3,2,3,4] 输出：10示例 4： 输入：[3,6,2,3] 输出：8 提示： 3 &lt;= A.length &lt;= 10000 1 &lt;= A[i] &lt;= 10^6 思路这题偷了个懒，直接用了自带的sort函数，之后就是一共从后向前的循环，每三个为一组，若该组可以构成三角形，返回长度，不然跳出。这里还有一个数学问题，为什么是连续的三个而不是中断的三个，这里假设有四个数字abcd，升序排列，先判断bcd，在判断abc，因为如果b+c&lt;d，无法构成,那么a+c&lt;b+c更无法构成了。 代码123456789public static int largestPerimeter(int[] A) &#123; Arrays.sort(A); for (int i = A.length - 1; i &gt; 1; i--) &#123; if (A[i] &lt; A[i - 1] + A[i - 2]) &#123; return A[i] + A[i - 1] + A[i - 2]; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1295. Find Numbers with Even Number of Digits]]></title>
    <url>%2FLeetCode%201295.%20Find%20Numbers%20with%20Even%20Number%20of%20Digits.html</url>
    <content type="text"><![CDATA[1295. Find Numbers with Even Number of Digits（统计位数为偶数的数字）链接https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits 题目给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。 示例 1： 输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字 位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字示例 2： 输入：nums = [555,901,482,1771] 输出：1 解释： 只有 1771 是位数为偶数的数字。 思路emmm我也不知道算是什么题目，从头到尾判断一下就行了，对于数字的范围判断一下，其实也可以转字符串判断长度，不过没必要。 代码123456789public static int findNumbers(int[] nums) &#123; int count = 0; for (int num : nums) &#123; if ((10 &lt;= num &amp;&amp; num &lt;= 99) || (1000 &lt;= num &amp;&amp; num &lt;= 9999) || num == 100000) &#123; count++; &#125; &#125; return count;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 374. Guess Number Higher or Lower]]></title>
    <url>%2FLeetCode%20374.%20Guess%20Number%20Higher%20or%20Lower.html</url>
    <content type="text"><![CDATA[374. Guess Number Higher or Lower（猜数字大小）链接https://leetcode-cn.com/problems/guess-number-higher-or-lower 题目我们正在玩一个猜数字游戏。 游戏规则如下：我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。每次你猜错了，我会告诉你这个数字是大了还是小了。你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）： -1 : 我的数字比较小 1 : 我的数字比较大 0 : 恭喜！你猜对了！示例 : 输入: n = 10, pick = 6 输出: 6 思路这个也是二分查找，只不过又换了一种问法。这里只需要注意到leftright的更新与guess函数的返回值即可。 代码12345678910111213141516public static int guessNumber(int n) &#123; int left = 1; int right = n; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (guess(mid) == 0) &#123; return mid; &#125; else if (guess(mid) == 1) &#123; left = mid + 1; &#125; else if (guess(mid) == -1) &#123; right = mid - 1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 278. First Bad Version]]></title>
    <url>%2FLeetCode%20278.%20First%20Bad%20Version.html</url>
    <content type="text"><![CDATA[278. First Bad Version（第一个错误的版本）链接https://leetcode-cn.com/problems/first-bad-version 题目你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 思路这个也是二分查找，问题相对来说不是很大，只需要注意几个细节即可，返回值为true表示版本错误，同时注意left和right的顺序，并且mid取值的时候要注意到不能溢出，最后返回left即可。 代码1234567891011121314 public static int firstBadVersion(int n) &#123; int left = 1; int right = n; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (isBadVersion(mid) == true) &#123; right = mid - 1; &#125; else if (isBadVersion(mid) == false) &#123; left = mid + 1; &#125; &#125; return left;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 35. Search Insert Position]]></title>
    <url>%2FLeetCode%2035.%20Search%20Insert%20Position.html</url>
    <content type="text"><![CDATA[35. Search Insert Position（二分查找）链接https://leetcode-cn.com/problems/search-insert-position 题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2示例 2: 输入: [1,3,5,6], 2 输出: 1示例 3: 输入: [1,3,5,6], 7 输出: 4示例 4: 输入: [1,3,5,6], 0 输出: 0 思路二分查找加了一些别的东西，升序数组，找到返回下标，未找到就返回可以加入的位置.代码和正常的二分查找相同，需要注意的是，最后一个返回的应该是left，因为在最后一次循环中，left=right，然后left++，这个位置，就是应该存放的位置。 代码12345678910111213141516171819 public static int searchInsert(int[] nums, int target) &#123; if (nums.length == 0) &#123; return 0; &#125; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; &#125; return left;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[查找算法-二分查找]]></title>
    <url>%2F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
    <content type="text"><![CDATA[查找算法-二分查找标题二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 思路设置两个标签，一个为left一个为right，分别表示左侧与右侧，常见初始值为0，length-1.之后进行while循环，这里注意，判断条件选择left&lt;=right，这里当然可以改变，但是最好是熟练之后再进行改变。循环中定义mid = (left + right) / 2，其实更好的是left+（right-left）/2；这样避免越界。若找到了所需要的值，直接返回，找不到的话，就先判断nums[mid]与目标值的大小关系，重新确立leftright，进行下一步运算。 复杂度O(log2n) 代码12345678910111213141516171819public static int search(int[] nums, int target) &#123; if (nums.length == 0) &#123; return -1; &#125; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 27. Remove Element]]></title>
    <url>%2FLeetCode%2027.%20Remove%20Element.html</url>
    <content type="text"><![CDATA[27. Remove Element（移除元素）链接https://leetcode-cn.com/problems/remove-element 题目给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 思路题目内容清晰，但是要求要用原地算法，不给额外空间，所以直接用双指针法，和前一题思路相同。新建一个index，然后遍历数组，如果发现和val不相同，就存储进来，相同就无视，最后输出index即可。 代码12345678910public static int removeElement(int[] nums, int val) &#123; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != val) &#123; nums[index]=nums[i]; index++; &#125; &#125; return index; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 796. Rotate String]]></title>
    <url>%2FLeetCode%20796.%20Rotate%20String.html</url>
    <content type="text"><![CDATA[796. Rotate String（旋转字符串）链接https://leetcode-cn.com/problems/rotate-string 题目给定两个字符串, A 和 B。 A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = ‘abcde’，在移动一次之后结果就是’bcdea’ 。如果在若干次旋转操作之后，A 能变成B，那么返回True。 示例 1: 输入: A = ‘abcde’, B = ‘cdeab’ 输出: true 示例 2: 输入: A = ‘abcde’, B = ‘abced’ 输出: false注意： A 和 B 长度不超过 100。 思路题目不是很难，但是好的思路可以大大减少所需时间。这里的思路是借鉴的，首先确保AB的长度相同，然后建立A+A，如果这里面包含B的话，就满足条件，因为A+A中随便截取等长的串都可能满足B的条件。 代码1234567public static boolean rotateString(String A, String B) &#123; if (A.length() == B.length() &amp;&amp; ((A + A).contains(B))) &#123; return true; &#125; else &#123; return false; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 26. Remove Duplicates from Sorted Array]]></title>
    <url>%2FLeetCode%2026.%20Remove%20Duplicates%20from%20Sorted%20Array.html</url>
    <content type="text"><![CDATA[26. Remove Duplicates from Sorted Array（删除排序数组中的重复项）链接https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 题目给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 思路题目内容清晰，但是要求要用原地算法，不给额外空间，所以直接用双指针法。新建一个index，然后遍历数组，如果发现二者相同就跳过，不同的话，就在index的下一位更换，这里要注意index的变化顺序，最后输出index+1即可。 代码12345678910public static int removeDuplicates(int[] nums) &#123; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != nums[index]) &#123; index++; nums[index] = nums[i]; &#125; &#125; return index+1;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 704. Binary Search]]></title>
    <url>%2FLeetCode%20704.%20Binary%20Search.html</url>
    <content type="text"><![CDATA[704. Binary Search（二分查找）链接https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array 题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4解释: 9 出现在 nums 中并且下标为 4示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 思路标准的二分查找，升序数组，找到返回下标，未找到就返回-1.首先如果长度为0，直接返回-11，之后确定左端右端，然后借助while循环进行，注意这里我用的是&lt;=判断，然后循环，如果得到答案返回下标，不然直接输出-1. 代码12345678910111213141516171819public static int search(int[] nums, int target) &#123; if (nums.length == 0) &#123; return -1; &#125; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 961. N-Repeated Element in Size 2N Array]]></title>
    <url>%2FLeetCode%20961.%20N-Repeated%20Element%20in%20Size%202N%20Array.html</url>
    <content type="text"><![CDATA[961. N-Repeated Element in Size 2N Array（重复 N 次的元素）链接https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array 题目在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1： 输入：[1,2,3,3] 输出：3示例 2： 输入：[2,1,2,5,3,2] 输出：2示例 3： 输入：[5,1,5,2,5,3,5,4] 输出：5 提示： 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length 为偶数 思路这道题不是很难，就是想找到那个出现次数为N的数字，一共只有2N个数字，如果分布的最开的话，是每个数字之间都插一个数字，这样可以证明一定存在连续的三个数字，使那一个数字出现两次及以上。所以只要从头到尾检查一下，若三个数字中出现两个相同数字，该数字即为所求解，不然就是最后一个数字。 代码123456789public static int repeatedNTimes(int[] A) &#123; int len = A.length; for (int i = 0; i &lt; len - 2; i++) &#123; if (A[i] == A[i + 1] || A[i] == A[i + 2]) &#123; return A[i]; &#125; &#125; return A[len - 1];&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1051. Height Checker]]></title>
    <url>%2FLeetCode%201051.%20Height%20Checker.html</url>
    <content type="text"><![CDATA[1051. Height Checker（高度检查器）链接https://leetcode-cn.com/problems/height-checker 题目学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。 示例： 输入：heights = [1,1,4,2,1,3] 输出：3 提示： 1 &lt;= heights.length &lt;= 100 1 &lt;= heights[i] &lt;= 100 思路不是很懂这题的意义，直接排序然后和原数组比较，每一个不同的就加一，直接输出即可。 代码1234567891011public static int heightChecker(int[] heights) &#123; int[] other = heights.clone(); Arrays.sort(other); int ans = 0; for (int i = 0; i &lt; heights.length; i++) &#123; if (other[i] != heights[i]) &#123; ans++; &#125; &#125; return ans; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 67. Add Binary]]></title>
    <url>%2FLeetCode%2067.%20Add%20Binary.html</url>
    <content type="text"><![CDATA[67. Add Binary（二进制求和）链接https://leetcode-cn.com/problems/add-binary 题目给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1” 输出: “100”示例 2: 输入: a = “1010”, b = “1011” 输出: “10101” 思路做起来比想象中麻烦不少，很多小细节需要注意。这里我直接用了一个StringBuilder来存储答案。从后往前计算，num用于保存进位。若ab该位都存在，则二者加num为计算结果，num只有四种情况0123，01无进位，写入。23有进位，-2后写入，进位则置num为1否则为0，然后参与下一步运算。如果ab都计算完了，num为1，则再产生进位，细节问题较多。 代码12345678910111213141516171819202122232425262728 public static String addBinary(String a, String b) &#123; StringBuilder ans = new StringBuilder(); int len1 = a.length() - 1; int len2 = b.length() - 1; int num = 0; while (len1 &gt;= 0 || len2 &gt;= 0) &#123; if (len1 &gt;= 0) &#123; num += a.charAt(len1) - &apos;0&apos;; len1--; &#125; if (len2 &gt;= 0) &#123; num += b.charAt(len2) - &apos;0&apos;; len2--; &#125; if (num &lt; 2) &#123; ans.insert(0, num); num = 0; &#125; else &#123; ans.insert(0, num - 2); num = 1; &#125; &#125; if (num == 1) &#123; ans.insert(0, 1); &#125; return ans.toString();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 167. Two Sum II - Input array is sorted]]></title>
    <url>%2FLeetCode%20167.%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted.html</url>
    <content type="text"><![CDATA[167. Two Sum II - Input array is sorted（两数之和 II - 输入有序数组）链接https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted 题目给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 思路这道题我是直接双指针做的，由于是升序数组，且前一个一定小于后一个，就可以用两边向中间逼近的方法，若二者和小于答案，则前数向后一位，大于答案，后数向前一位，最后返回数组。 代码12345678910111213141516public static int[] twoSum(int[] numbers, int target) &#123; int start = 0; int end = numbers.length - 1; while (numbers[start] + numbers[end] != target) &#123; if (numbers[start] + numbers[end] &lt; target) &#123; start++; &#125; else &#123; end--; &#125; &#125; int[] res = new int[2]; res[0] = start + 1; res[1] = end + 1; return res;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 189. Rotate Array]]></title>
    <url>%2FLeetCode%20189.%20Rotate%20Array.html</url>
    <content type="text"><![CDATA[189. Rotate Array（旋转数组）链接https://leetcode-cn.com/problems/rotate-array 题目给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4]示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100]说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。 思路题目思路清晰，但是考虑到复杂度，就麻烦了不少。我选择的方法是以前在书上看到的，三次转置，第一次全体转置，第二次转置前k个，第三次转置剩余部分。以例子1解释，1234567，转置全部之后是7654321.转置前三个，再转置后四个，就是5671234，符合条件。由于所有数都转置了两次，所有对于前半部分和后半部分，相对位置是不变的，最开始直接倒序再转置k个，然后就是所需的k个在最前方。 代码1234567891011121314151617public static void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125;&#125;public static void rotate(int[] nums, int k) &#123; int len = nums.length; k = k % len; reverse(nums, 0, len - 1); reverse(nums, 0, k - 1); reverse(nums, k, len - 1);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 965. Univalued Binary Tree]]></title>
    <url>%2FLeetCode%20965.%20Univalued%20Binary%20Tree.html</url>
    <content type="text"><![CDATA[965. Univalued Binary Tree（单值二叉树）链接https://leetcode-cn.com/problems/univalued-binary-tree 题目如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。 只有给定的树是单值二叉树时，才返回 true；否则返回 false。 示例 1： 输入：[1,1,1,1,1,null,1] 输出：true示例 2： 输入：[2,2,2,5,2] 输出：false 提示： 给定树的节点数范围是 [1, 100]。每个节点的值都是整数，范围为 [0, 99] 。 思路题目不难，方法多种，我是选择直接对于每个结点进行一次判断，最后得到结果。也可以直接遍历，把所有的值存放到一个set当中，若set长度为1则成立。 代码123456789101112131415161718192021222324public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public static boolean isUnivalTree(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (root.left != null &amp;&amp; root.left.val != root.val) &#123; return false; &#125; if (root.right != null &amp;&amp; root.right.val != root.val) &#123; return false; &#125; return isUnivalTree(root.left) &amp;&amp; isUnivalTree(root.right); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 111. Minimum Depth of Binary Tree]]></title>
    <url>%2FLeetCode%20111.%20Minimum%20Depth%20of%20Binary%20Tree.html</url>
    <content type="text"><![CDATA[111. Minimum Depth of Binary Tree（二叉树的最小深度）链接https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ 题目给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / 9 20 / 15 7返回它的最小深度 2. 思路二叉树的问题，不过比起最大深度麻烦了不少。首先还是空节点直接返回0；如果左右两个子节点有一个为空，最大深度分别为a和b，那么空的那个就应该等于0，返回另外一个深度+0+1；如果两个都不为空节点，那么返回二者中的较小值+1.（这题我本来的代码对于[1,2]的结果为1，是错误的，之后参考了题解，才发现我对于题目的理解出了问题） 代码123456789101112131415161718192021222324public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public static int minDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return 1; &#125; if (root.left == null || root.right == null) &#123; return minDepth(root.right) + minDepth(root.left) + 1; &#125; return 1 + Math.min(minDepth(root.left), minDepth(root.right));&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 104. Maximum Depth of Binary Tree]]></title>
    <url>%2FLeetCode%20104.%20Maximum%20Depth%20of%20Binary%20Tree.html</url>
    <content type="text"><![CDATA[104. Maximum Depth of Binary Tree（二叉树的最大深度）链接https://leetcode-cn.com/problems/maximum-depth-of-binary-tree 题目给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / 9 20 / 15 7返回它的最大深度 3 。 思路基础题，有多种方法，我选择的是简单的递归，若根为空，那么返回0，不然返回左右子树最大深度加一，然后就没了。 代码123456789101112131415161718public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public static int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下MySQL的安装与配置]]></title>
    <url>%2FWindows%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Windows下MySQL的安装与配置由于某些特殊原因，电脑上的mysql出了些问题，所以我就打算卸载重装一下，顺便记录一下流程。 一、官网下载直接进入官网下载，下载地址https://dev.mysql.com/downloads/mysql/下载第一个即可。（点击下面的No thanks，just start my download）下载完成之后找个位置解压。 二、安装流程1.环境变量计算机中找到环境变量设置，增加环境变量，在path中增加 2.新建文件在解压目录中新建data文件夹，和一个my.ini文件my.ini文件可以用txt改后缀，内容如下（只写了基础，有需要可以自行添加） [mysqld] # mysql根目录 basedir = D:\mysql-5.7.29-winx64 # 放所有数据库的data目录 datadir = D:\mysql-5.7.29-winx64\data3.初始化这部分需要三条指令，先以管理员身份打开cmd，之后依次输入，初始化，安装，启动。 mysqld --initialize --user=mysql --console mysqld –install mysql net start mysql输入第一条指令后会生成随机密码，记得先保存，之后更改，毕竟这个贼难记。 三、配置修改这里也没什么太多的，就把之前的初始密码修改下，有两种方法，一种是借助navicat等工具修改，一种是命令行修改，我采用的是命令行。 1.登录输入登录命令 mysql -uroot -p前面指root用户，后面指password密码，记得u和root是连在一起的，然后输入密码登录。直接输入指令 set password for root@localhost = password(&apos;123456&apos;);将密码修改为123456，这里只是做例子，最好不要用这种密码2333333.修改成功，可以开始使用了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>工具安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 58. Length of Last Word]]></title>
    <url>%2FLeetCode%2058.%20Length%20of%20Last%20Word.html</url>
    <content type="text"><![CDATA[58. Length of Last Word（最后一个单词的长度）链接https://leetcode-cn.com/problems/length-of-last-word 题目给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。 如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。 示例: 输入: “Hello World” 输出: 5 思路字符串题，只要注意到几处细节就不难。我是从最后一位开始的，若最后一位为空格，则提前，提前到非空处，之后再按位查找，直到找到空格或者到字符串的开头为止。在按位查找的过程中增加一个num用于计数，最后输出num即可。 代码123456789101112131415161718public static int lengthOfLastWord(String s) &#123; if (s.length() &lt; 1) &#123; return 0; &#125; int end = s.length() - 1; while (end &gt;= 0 &amp;&amp; s.charAt(end) == &apos; &apos;) &#123; end--; &#125; if (end &lt; 0) &#123; return 0; &#125; int num = 0; while (end &gt;= 0 &amp;&amp; s.charAt(end) != &apos; &apos;) &#123; end--; num++; &#125; return num; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 41. First Missing Positive]]></title>
    <url>%2FLeetCode%2041.%20First%20Missing%20Positive.html</url>
    <content type="text"><![CDATA[41. First Missing Positive（缺失的第一个正数）链接https://leetcode-cn.com/problems/first-missing-positive 题目给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3示例 2: 输入: [3,4,-1,1] 输出: 2示例 3: 输入: [7,8,9,11,12] 输出: 1说明: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 思路比较难的一类数组题目，对于复杂度和空间都有要求，结果就需要多考虑很多东西。首先先设置长度为len，那么优先考虑为1-len范围的数字，每次优先把这些数字放在应该放的位置上swap(nums, i, nums[i] - 1)，之后对于数组进行遍历，如果该位置上的数字不符合条件，那么直接返回该位置应该有的数（数组号+1），如果遍历完了，那么就应该是数组长度+1. 代码1234567891011121314151617181920212223private static void swap(int nums[], int a, int b) &#123; int c = nums[a]; nums[a] = nums[b]; nums[b] = c; &#125; public static int firstMissingPositive(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 1; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[i] != nums[nums[i] - 1]) &#123; swap(nums, i, nums[i] - 1); &#125; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != i + 1) &#123; return i + 1; &#125; &#125; return nums.length + 1; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 283. Move Zeroes]]></title>
    <url>%2FLeetCode%20283.%20Move%20Zeroes.html</url>
    <content type="text"><![CDATA[283. Move Zeroes（移动零）链接https://leetcode-cn.com/problems/move-zeroes 题目给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0]说明: 必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 思路数组操作题，只要思路清晰，难度并不是很大。设置index作为标签，从数组头部开始遍历，index用于标记新数组最后不为0的数字，若不为0，就放入index中，index+1，直到结尾，然后把后面的数字置为0即可。 代码12345678910111213public static void moveZeroes(int[] nums) &#123; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; nums[index] = nums[i]; index++; &#125; &#125; for (; index &lt; nums.length; index++) &#123; nums[index] = 0; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 100. Same Tree]]></title>
    <url>%2FLeetCode%20100.%20Same%20Tree.html</url>
    <content type="text"><![CDATA[100. Same Tree（相同的树）链接https://leetcode-cn.com/problems/same-tree 题目给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \ / 2 3 2 3 [1,2,3], [1,2,3] 输出: true示例 2: 输入: 1 1 / 2 2 [1,2], [1,null,2] 输出: false示例 3: 输入: 1 1 / \ / 2 1 1 2 [1,2,1], [1,1,2] 输出: false 思路遍历呗，先查看是否为空，都为空相同，之后同时比较左结点和右结点，没啥了。 代码123456789101112131415161718192021222324public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public static boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) &#123; return true; &#125; if (p != null &amp;&amp; q != null &amp;&amp; p.val == q.val) &#123; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; else &#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 264. Ugly Number II]]></title>
    <url>%2FLeetCode%20264.%20Ugly%20Number%20II.html</url>
    <content type="text"><![CDATA[264. Ugly Number II（丑数 II）链接https://leetcode-cn.com/problems/ugly-number-ii 题目编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例: 输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。说明: 1 是丑数。 n 不超过1690。 思路比上一题带劲，本来打算打表打个卡的，结果发现了一个三指针法，效果很好。任意丑数都是比这个数小的丑数乘以2，3，5其中之一得到的，要求按照顺序排列，那么就从之前的数中找到未被使用过的数乘一下，然后比较，就可以得到新的数了。首先初始位为1，设三个指针值n2,n3,n5,初始设为0.之后开始循环，每次循环都找到235未乘过的数字乘一下，然后取最小值为新的丑数。之后，若n2n3n5使用过了，那么指针位+1，下次乘下一个数字，如果都可以，那就都加。把数字记录下来最后输出即可。 代码1234567891011121314151617181920public static int nthUglyNumber(int n) &#123; int[] ans = new int[n]; int n2 = 0, n3 = 0, n5 = 0; ans[0] = 1; for (int i = 1; i &lt; n; i++) &#123; int min = Math.min(ans[n2] * 2, Math.min(ans[n3] * 3, ans[n5] * 5)); ans[i] = min; if (min == ans[n2]*2) &#123; n2++; &#125; if (min == ans[n3]*3) &#123; n3++; &#125; if (min == ans[n5]*5) &#123; n5++; &#125; &#125; return ans[n-1]; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 231. Power of Two]]></title>
    <url>%2FLeetCode%20231.%20Power%20of%20Two.html</url>
    <content type="text"><![CDATA[231. Power of Two（2的幂）链接https://leetcode-cn.com/problems/power-of-two 题目给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1 输出: true 解释: 20 = 1示例 2: 输入: 16 输出: true 解释: 24 = 16示例 3: 输入: 218 输出: false 思路位运算，算是做之前不知道咋做，做了后就熟了的题目，代码也都简单，有两个式子。先得知，若为二的幂，转换为二进制之后只有一位数字是1，别的数字都是0. (n &gt; 0) &amp;&amp; ((n &amp; -n) == n)负数补码的存放是取反加一，假设为8，整数为1000，负数-8，为0111+0001=1000(取反加一)，二者&amp;运算，结果为1000，还是8. (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0)同样用8举例，n-1=7为0111，二者&amp;运算，结果为0. 两个式子的运算耗时差距也不是很大，看能想起来哪个吧，主要就是记得二进制是特殊的，适合位运算就行。 代码1234public static boolean isPowerOfTwo(int n) &#123; return (n &gt; 0) &amp;&amp; ((n &amp; -n) == n); // return (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 263. Ugly Number]]></title>
    <url>%2FLeetCode%20263.%20Ugly%20Number.html</url>
    <content type="text"><![CDATA[263. Ugly Number（丑数）链接https://leetcode-cn.com/problems/ugly-number 题目编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 输入: 6 输出: true 解释: 6 = 2 × 3示例 2: 输入: 8 输出: true 解释: 8 = 2 × 2 × 2示例 3: 输入: 14 输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 思路简单的定义题，整除方法，特殊值1，直接if判断1，while判断整除，最后输出结果。 代码12345678910111213141516public static boolean isUgly(int num) &#123; if (num &lt; 1) &#123; return false; &#125; while (num % 5 == 0) &#123; num = num / 5; &#125; while (num % 3 == 0) &#123; num = num / 3; &#125; while (num % 2 == 0) &#123; num = num / 2; &#125; return num == 1; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 136. Single Number]]></title>
    <url>%2FLeetCode%20136.%20Single%20Number.html</url>
    <content type="text"><![CDATA[136. Single Number（只出现一次的数字）链接https://leetcode-cn.com/problems/single-number 题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 思路这题思路有点强的，我本来打算遍历加哈希来检测，之后发现了，这题可以用位运算（我从来没有想过这个问题）。异或计算，如果二者相同则结果为0，不同的话结果为1，再加上异或自带的交换律，最后结果就是0异或单一数，就是要找的数字。 代码1234567public static int singleNumber(int[] nums) &#123; int n = 0; for (int i = 0; i &lt; nums.length; i++) &#123; n = n ^ nums[i]; &#125; return n; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 69. Sqrt(x)]]></title>
    <url>%2FLeetCode%2066.%20Plus%20One.html</url>
    <content type="text"><![CDATA[69. Sqrt(x)（x 的平方根）链接https://leetcode-cn.com/problems/sqrtx 题目实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4输出: 2示例 2: 输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 思路平方根的求法，要么用牛顿迭代法，要么二分法，（遍历也行，但是会超时），设1，x一个开始一个结束，二分法找答案，需要注意的是要采用x/mid&gt;mid,不然会超出范围。2020的第一篇，又是热爱学习的一年。 代码1234567891011121314151617public static int mySqrt(int x) &#123; if (x == 1 || x == 0) &#123; return x; &#125; int start = 0; int end = x ; while (end - start &gt;= 1) &#123; int mid = (start + end) / 2; if (x / mid &gt; mid) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; return start; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 66. Plus One]]></title>
    <url>%2FLeetCode%2069.%20Sqrt(x).html</url>
    <content type="text"><![CDATA[66. Plus One（加一）链接https://leetcode-cn.com/problems/plus-one 题目给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 思路不是很难的题目，只需要注意，给的数组是表示数字的，那么就从后往前加一，如果进位就考虑前一位，不然跳出。如果第一位产生进位，就需要一个新数组，来存放新的第一位。 代码1234567891011121314151617181920212223242526public static int[] plusOne(int[] digits) &#123; if (digits.length == 0) &#123; return null; &#125; int len = digits.length; digits[len - 1] += 1; for (int i = len - 1; i &gt; 0; i--) &#123; if (digits[i] &gt;= 10) &#123; digits[i] -= 10; digits[i - 1] += 1; &#125; &#125; if (digits[0] == 10) &#123; int[] newdigits = new int[len + 1]; newdigits[0] = 1; digits[0] -= 10; for (int i = 0; i &lt; len; i++) &#123; newdigits[i + 1] = digits[i]; &#125; return newdigits; &#125; return digits; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 70. Climbing Stairs]]></title>
    <url>%2FLeetCode%2070.%20Climbing%20Stairs.html</url>
    <content type="text"><![CDATA[70. Climbing Stairs（两数之和）链接https://leetcode-cn.com/problems/climbing-stairs 题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶思路算是一个递归方法，如果只有一阶那么只有一种方法，二阶有两种方法。递归方程 f(n)=f(n-1)+f(n-2) 代码：1234567891011121314public int climbStairs(int n) &#123; if (n &lt; 3) &#123; return n; &#125; int f1 = 1; int f2 = 2; int fn = 0; for (int i = 3; i &lt;= n; i++) &#123; fn = f1 + f2; f1 = f2; f2 = fn; &#125; return fn;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 628. Maximum Product of Three Numbers]]></title>
    <url>%2FLeetCode%20628.%20Maximum%20Product%20of%20Three%20Numbers.html</url>
    <content type="text"><![CDATA[628. Maximum Product of Three Numbers（三个数的最大乘积）链接https://leetcode-cn.com/problems/maximum-product-of-three-numbers/submissions 题目给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1: 输入: [1,2,3] 输出: 6示例 2: 输入: [1,2,3,4] 输出: 24注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 思路简单题，分析一下思路，要求乘积的最大值，那么限定一下范围，只能是三个最大正数相乘，或者两个最小负数相乘再乘最大正数，负负得正。这里采用sort直接排序，偷了个懒，之后算出两种最大值比较输出即可。 代码1234567public static int maximumProduct(int[] nums) &#123; Arrays.sort(nums); int max1 = nums[0] * nums[1] * nums[nums.length - 1]; int max2 = nums[nums.length - 3] * nums[nums.length - 2] * nums[nums.length - 1]; return Math.max(max1, max2);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 13. Roman to Integer]]></title>
    <url>%2FLeetCode%2013.%20Roman%20to%20Integer.html</url>
    <content type="text"><![CDATA[13. Roman to Integer（罗马数字转整数）链接https://leetcode-cn.com/problems/roman-to-integer/ 题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3示例 2: 输入: &quot;IV&quot; 输出: 4示例 3: 输入: &quot;IX&quot; 输出: 9示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3.示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4.思路这题比起之前的整数转罗马数字麻烦了很多，整数转罗马只需要考虑去除差即可，现在需要反向转换，首先可以先从头到尾把全部转化为整数，之后如果发现IV等的组合，就减去两倍的I，别的几个同理，得到正确答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static int romanToInt(String s) &#123; int len = s.length(); int num = 0; for (int i = 0; i &lt; len; i++) &#123; switch (s.charAt(i)) &#123; case &apos;I&apos;: num += 1; break; case &apos;V&apos;: num += 5; break; case &apos;X&apos;: num += 10; break; case &apos;L&apos;: num += 50; break; case &apos;C&apos;: num += 100; break; case &apos;D&apos;: num += 500; break; case &apos;M&apos;: num += 1000; break; default: System.out.println(&quot;default&quot;); break; &#125; if (i != 0) &#123; if (s.charAt(i - 1) == &apos;I&apos;) &#123; if (s.charAt(i) == &apos;V&apos; || s.charAt(i) == &apos;X&apos;) &#123; num -= 2; &#125; &#125; if (s.charAt(i - 1) == &apos;X&apos;) &#123; if (s.charAt(i) == &apos;L&apos; || s.charAt(i) == &apos;C&apos;) &#123; num -= 20; &#125; &#125; if (s.charAt(i - 1) == &apos;C&apos;) &#123; if (s.charAt(i) == &apos;D&apos; || s.charAt(i) == &apos;M&apos;) &#123; num -= 200; &#125; &#125; &#125; &#125; return num; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2016-04-2 俄罗斯方块]]></title>
    <url>%2FCCF%202016-04-2%20%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.html</url>
    <content type="text"><![CDATA[CCF 2016-04-2 俄罗斯方块题目问题描述 俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。 游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。 在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。 具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。 输入格式 输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。 输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。 第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例） 输出格式 输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。 样例输入0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 0 1 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 0 0 0 3样例输出1234567891011121314150 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 1 1 1 1 1 1 10 0 0 0 1 1 0 0 0 0 思路以前的代码，暴力向下计算即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;int main()&#123; int n,i,k,j,t,x; int a[20][11],b[4][4],c[20][11]; for(i=1;i&lt;=15;i++) &#123; for(j=1;j&lt;=10;j++) &#123; cin&gt;&gt;a[i][j]; c[i][j]=a[i][j]; &#125; &#125; for(i=16;i&lt;=19;i++) &#123; for(j=1;j&lt;=10;j++) &#123; a[i][j]=1; c[i][j]=a[i][j]; &#125; &#125; for(i=1;i&lt;=4;i++) &#123; for(j=1;j&lt;=4;j++) &#123; cin&gt;&gt;b[i][j]; &#125; &#125; cin&gt;&gt;k; int po=1; for(i=1;i&lt;=19&amp;&amp;po;i++) &#123; po=1; for(j=4;j&gt;=1&amp;&amp;po&amp;&amp;i+j-4&gt;=1;j--) &#123; for(x=1;x&lt;=4&amp;&amp;po;x++) &#123; c[i+j-4][k+x-1]=a[i+j-4][k+x-1]+b[j][x]; if(c[i+j-4][k+x-1]&gt;1) po=0; &#125; &#125; &#125; i=i-2; for(j=4;j&gt;=1;j--) &#123; for(x=1;x&lt;=4;x++) &#123; a[i+j-4][k+x-1]=a[i+j-4][k+x-1]+b[j][x]; &#125; &#125; for(i=1;i&lt;=15;i++) &#123; for(j=1;j&lt;=10;j++) &#123; cout&lt;&lt;a[i][j]; if(j!=10) cout&lt;&lt;" "; &#125; if(i!=15) cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2016-04-1 折点计数]]></title>
    <url>%2FCCF%202016-04-1%20%E6%8A%98%E7%82%B9%E8%AE%A1%E6%95%B0.html</url>
    <content type="text"><![CDATA[CCF 2016-04-1 折点计数题目问题描述 给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。 给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折点。 为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。 输入格式​ 输入的第一行包含一个整数n。 第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。 输出格式​ 输出一个整数，表示折点出现的数量。 样例输入7 5 4 1 2 3 6 4样例输出12 评测用例规模与约定 所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。 思路遍历一遍，满足条件加一。 代码1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n],i,t=0,j; for(i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(i=2;i&lt;n;i++) &#123; if((a[i]&gt;a[i-1])&amp;&amp;(a[i]&gt;a[i+1])) t++; else if((a[i]&lt;a[i-1])&amp;&amp;(a[i]&lt;a[i+1])) t++; &#125; cout&lt;&lt;t; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1927 防护伞]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1927%20%E9%98%B2%E6%8A%A4%E4%BC%9E.html</url>
    <content type="text"><![CDATA[洛谷 P1927 防护伞链接https://www.luogu.org/problem/P1927 题目题目描述据说 2012 的灾难和太阳黑子的爆发有关。于是地球防卫小队决定制造一个特殊防护 伞，挡住太阳黑子爆发的区域，减少其对地球的影响。由于太阳相对于地球来说实在是太 大了，我们可以把太阳表面看作一个平面，中心定为(0,0)。根据情报，在 2012 年时， 太阳表面上会产生 N 个黑子区域，每个黑子视为一个点。特殊防护伞可以看作一个巨大 的圆面，现在地球防卫小队决定将它的中心定位于某个黑子，然后用伞面挡住其他黑子。 因为制造防护伞的材料成本特别高，所以我们希望伞面尽可能的小。 输入格式第一行：一个整数 N，表示黑子个数。 第 2 到 N-1 行：每行两个整数，表示黑子的坐标（x, y）。 输出格式第一行：一个实数，表示伞的面积。 输入输出样例输入 #1 123430 1 -8 -4 -1 4 输出 #1 1279.6017 说明/提示【数据范围】 对于 50%的数据： 2≤N≤100。 对于 100%的数据： 2≤N≤1000。 -10000≤x,y≤10000。 【注意】 精确到小数点后 4 位 π=3.1415926535 思路水题，遍历一下找到两点间的最远距离，直接公式算结果，控制输出位数即可。 寻找逆序对的话，排序就行，这里的数据量肯定不能冒泡，所以归并（方便统计数量），归并排序的算法不是很难，以后我会补个排序算法集合（鸽德），这里只需要注意两点，一点是sum每次增加mid-left+1，这个1可能会漏；第二点是数据范围，数组要50w的，答案要longlong。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int x[n],y[n]; double len[n][n],minlen[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x[i]&gt;&gt;y[i]; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; len[i][j]=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)); minlen[i]=max(minlen[i],len[i][j]); &#125; &#125; double min=30000; for(int i=0;i&lt;n;i++) &#123; if(minlen[i]&lt;min) min=minlen[i]; &#125; double ans=min*min*3.1415926535; cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(4)&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1843 奶牛晒衣服]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1843%20%E5%A5%B6%E7%89%9B%E6%99%92%E8%A1%A3%E6%9C%8D.html</url>
    <content type="text"><![CDATA[洛谷 P1843 奶牛晒衣服链接https://www.luogu.org/problem/P1843 题目题目背景熊大妈决定给每个牛宝宝都穿上可爱的婴儿装 。 于是 ， 为牛宝宝洗晒衣服就成了很不爽的事情。 题目描述熊大妈请你帮助完成这个重任 。 洗完衣服后 ， 你就要弄干衣服 。 衣服在自然条件下用 1 的时间可以晒干 A 点湿度 。 抠门的熊大妈买了 1 台烘衣机 。使用烘衣机可以让你用 1 的时间使 1 件衣服除了自然晒干 A 点湿度外，还可以烘干 B 点湿度，但在 1 的时间内只能对 1 件衣服使用。N 件衣服因为种种原因而不一样湿 ， 现在告诉你每件衣服的湿度 ， 要你求出弄干所有衣服的最少时间（湿度为 0 为干 ） 。 输入格式第一行 N ， A ， B ；接下来 N 行，每行一个数，表示衣服的湿度（ 1 ≤ 湿度， A ， B ≤ 500000 ， 1 ≤ N ≤ 500000 ） 。 输出格式一行，弄干所有衣服的最少时间。 输入输出样例输入 #1 12343 2 1123 输出 #1 11 说明/提示第 1 个时间内，用机器处理第 3 件衣服，此外，所有衣服自然晒干 。 花费 1 时间全部弄干。 思路每次都用贪心就行了，每天烘干水分最大的衣服，就能最短时间结束。数据较长，借助优先队列排序即可。 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; int ans=0; priority_queue &lt;int&gt; q; for(int i=0;i&lt;n;i++) &#123; int water; cin&gt;&gt;water; q.push(water); &#125; while(q.top()&gt;ans*a) &#123; ans++; int max = q.top(); q.pop(); q.push(max-b); &#125; cout&lt;&lt;ans; return 0; &#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1702 突击考试]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1702%20%E7%AA%81%E5%87%BB%E8%80%83%E8%AF%95.html</url>
    <content type="text"><![CDATA[洛谷 P1702 突击考试链接https://www.luogu.org/problem/P1702 题目题目描述一日，老师决定进行一次突击考试。已知每个学生都有一个考试能力等级，教室里一共有N个课桌，按照顺序排成一列，每张课桌可以坐两个人，第i张课桌坐的两个人的能力等级为（A[i],B[i]）。现在老师决定对能力等级为K的人进行测验。他会从这N排中选择连续的L排进行测验，要求这 L排中的每一排至少有一个人考试能力等级为K。现在我们想知道L的最大值以及对应的等级K。 输入格式第1行：一个整数N； 第2..N+1行：每行两个整数，表示A[i],B[i]。 输出格式两个整数L和K，要求在L最大的条件下K最小。 输入输出样例输入 #1 123433 54 51 3 输出 #1 12 5 说明/提示1≤N≤100,000，1≤A[i],B[i]≤5 思路k的范围很小，直接采用循环做，1-5跑五遍循环就行了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n],b[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; &#125; int ans=0; int max=0; for(int k=1;k&lt;=5;k++) &#123; int num=0; for(int i=0;i&lt;n;i++) &#123; if(a[i]==k || b[i]==k) &#123; num++; &#125; else &#123; num=0; &#125; if(num&gt;max) &#123; max=num; ans=k; &#125; &#125; &#125; cout&lt;&lt;max&lt;&lt;" "&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2016-09-2 火车购票]]></title>
    <url>%2FCCF%202016-09-2%20%E7%81%AB%E8%BD%A6%E8%B4%AD%E7%A5%A8.html</url>
    <content type="text"><![CDATA[CCF 2016-09-2 火车购票题目问题描述 请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。 输入格式 输入的第一行包含一个整数n，表示购票指令的数量。 第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。 输出格式​ 输出n行，每行对应一条指令的处理结果。 对于购票指令p，输出p张车票的编号，按从小到大排序。 样例输入4 2 5 4 2样例输出12341 26 7 8 9 1011 12 13 143 4 样例说明 1) 购2张票，得到座位1、2。 2) 购5张票，得到座位6至10。 3) 购4张票，得到座位11至14。 4) 购2张票，得到座位3、4。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。 思路设置数组大一格，存放其中的空位，找到合适的行，然后在其中输出结果即可。 其实我的代码有问题，那格应该增加一个判断，判断连续空格的，但是，我不想写了，数据难度小，就这样了，以上。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;cmath&gt; using namespace std;int a[21][7];int main()&#123; int n,buy[101]; for(int i=0;i&lt;20;i++) &#123; for(int j=0;j&lt;5;j++) &#123; a[i][j]=0; &#125; a[i][5]=5; //应该放连续空格数的 &#125; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;buy[i]; for(int tip=0;tip&lt;n;tip++) &#123; int order=buy[tip]; int line=0; int pos=-1; while(line!=20) &#123; if(a[line][5]&gt;=order) &#123; pos=line; break; &#125; line++; &#125; if(pos==-1) &#123; for(int i=0;i&lt;20;i++) &#123; for(int j=0;j&lt;5;j++) &#123; if(a[i][j]==0&amp;&amp;order&gt;0) &#123; a[i][j]=1; a[i][5]--; order--; cout&lt;&lt;5*i+j+1&lt;&lt;" "; &#125; &#125; &#125; &#125; else &#123; int num=0; int t=0; a[pos][5]-=order; for(int i=0;i&lt;5;i++) &#123; if(a[pos][i]==0) &#123; num++; if(num==order) &#123; t=i; break; &#125; &#125; else &#123; num=0; &#125; &#125; t=t-order+1; for(int i=0;i&lt;order;i++) &#123; a[pos][t+i]=1; cout&lt;&lt;5*pos+t+i+1&lt;&lt;" "; &#125; &#125; cout&lt;&lt;endl; &#125;/* for(int i=0;i&lt;20;i++) &#123; for(int j=0;j&lt;6;j++) &#123; cout&lt;&lt;a[i][j]; &#125; cout&lt;&lt;endl; &#125;*/ return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2016-09-1 最大波动]]></title>
    <url>%2FCCF%202016-09-1%20%E6%9C%80%E5%A4%A7%E6%B3%A2%E5%8A%A8.html</url>
    <content type="text"><![CDATA[CCF 2016-09-1 最大波动题目问题描述 小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。 输入格式 输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。 第二行包含n个正整数，依次表示每天的收盘价格。 输出格式 输出一个整数，表示这只股票这n天中的最大波动值。 样例输入6 2 5 5 7 3 5样例输出14 样例说明 第四天和第五天之间的波动最大，波动值为|3-7|=4。 评测用例规模与约定 对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。 思路水题，循环一遍找最大值即可。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n,i,k,max=0; cin&gt;&gt;n; int a[n]; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(i=1;i&lt;n;i++) &#123; k=abs(a[i]-a[i-1]); if(k&gt;max) &#123; max=k; &#125; &#125; cout&lt;&lt;max; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1318 积水面积]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1318%20%E7%A7%AF%E6%B0%B4%E9%9D%A2%E7%A7%AF.html</url>
    <content type="text"><![CDATA[洛谷 P1318 积水面积链接https://www.luogu.org/problem/P1318 题目题目描述一组正整数，分别表示由正方体叠起的柱子的高度。若某高度值为x，表示由x个正立方的方块迭起（如下图，0&lt;=x&lt;=5000）。找出所有可能积水的地方（图中蓝色部分），统计它们可能积水的面积总和（计算的是图中的横截面积。一个立方体的位置，为一个单位面积）。 如图：柱子高度变化为 0 1 0 2 1 2 0 0 2 0 图中蓝色部分为积水面积，共有6个单位面积积水。 输入格式两行，第一行n,表示有n个数(3&lt;=n&lt;=10000)。第2行连续n个数表示依次由正方体迭起的高度，保证首尾为0。 输出格式一个数，可能积水的面积。 输入输出样例输入 #1 12100 1 0 2 1 2 0 0 2 0 输出 #1 16 思路我的思路是左右向中间，从下往上。 首先输入，找到最大值，之后从1开始循环，这个j是高度的意思，left和right就是左右达到这个高度的最前一个，之后添加数字，直接判断大小就行，到最后一个结束，输出结果。 （最近心态不好，人很迷茫，估计骚话环节也没了，以上） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int maxn,ans; int num[12580]; int n,left,right; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; maxn=max(maxn,num[i]); &#125; for(int j=1;j&lt;=maxn;j++) &#123; for(int i=2;i&lt;=n-1;i++) &#123; if(num[i]&gt;=j) &#123; left=i; i=n; &#125; &#125; for(int i=n-1;i&gt;=2;i--) &#123; if(num[i]&gt;=j) &#123; right=i; i=1; &#125; &#125; for(int i=left;i&lt;right;i++) &#123; if(num[i]&lt;j) ans++; &#125; &#125; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2016-12-2 工资计算]]></title>
    <url>%2FCCF%202016-12-2%20%E5%B7%A5%E8%B5%84%E8%AE%A1%E7%AE%97.html</url>
    <content type="text"><![CDATA[CCF 2016-12-1 工资计算题目问题描述 小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算： 1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元； 2） A中不超过1500元的部分，税率3%； 3） A中超过1500元未超过4500元的部分，税率10%； 4） A中超过4500元未超过9000元的部分，税率20%； 5） A中超过9000元未超过35000元的部分，税率25%； 6） A中超过35000元未超过55000元的部分，税率30%； 7） A中超过55000元未超过80000元的部分，税率35%； 8） A中超过80000元的部分，税率45%； 例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。 已知小明这个月税后所得为T元，请问他的税前工资S是多少元。 输入格式 输入的第一行包含一个整数T，表示小明的税后所得。所有评测数据保证小明的税前工资为一个整百的数。 输出格式 输出一个整数S，表示小明的税前工资。 样例输入9255样例输出110000 评测用例规模与约定 对于所有评测用例，1 ≤ T ≤ 100000。 思路也是一两年前做的了，直接用了之前的代码，将数字关系全部列出来，直接输出，思路应该很清晰，不过代码不咋地。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;int main()&#123; int s,n,i=34,j,k=1,sum,t; cin&gt;&gt;n; s=n-3500; if(s&lt;=0) cout&lt;&lt;n; else &#123; if(s&lt;=1500-45) &#123; t=s; t=t*100/97; sum=3500+t; &#125; else if(s&lt;=4500-300-45) &#123; t=(s+45-1500)*100/90; sum=3500+1500+t; &#125; else if(s&lt;=9000-900-300-45) &#123; t=(s+45+300-4500)*100/80; sum=3500+4500+t; &#125; else if(s&lt;=35000-6500-900-300-45) &#123; t=(s+45+300+900-9000)*100/75; sum=3500+9000+t; &#125; else if(s&lt;=55000-6000-6500-900-300-45) &#123; t=(s+45+300+900+6500-35000)*100/70; sum=3500+35000+t; &#125; else if(s&lt;=80000-8750-6000-6500-900-300-45) &#123; t=(s+45+300+900+6500+6000-55000)*100/65; sum=3500+55000+t; &#125; else &#123; t=(s+45+300+900+6500+6000+8750-80000)*100/55; sum=3500+80000+t; &#125; cout&lt;&lt;sum; &#125;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2016-12-1 中间数]]></title>
    <url>%2FCCF%202016-12-1%20%E4%B8%AD%E9%97%B4%E6%95%B0.html</url>
    <content type="text"><![CDATA[CCF 2016-12-1 中间数题目问题描述 在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 给定一个整数序列，请找出这个整数序列的中间数的值。 输入格式 输入的第一行包含了一个整数n，表示整数序列中数的个数。 第二行包含n个正整数，依次表示a1, a2, …, an。 输出格式 如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。 样例输入6 2 6 5 6 3 5样例输出15 样例说明 比5小的数有2个，比5大的数也有2个。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。 思路水题，先排序，找到中位数，之后查看左右的相同数字，找到left和right，输出结果即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n, mid, left, right; int num[1010]; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;num[i]; sort(num, num+n); mid = n/2; left = mid; right = n - mid - 1; for(int i=mid-1; i&gt;=0; i--) &#123; if(num[i] == num[mid]) &#123; left--; &#125; else &#123; break; &#125; &#125; for(int i=mid+1; i&lt;n; i++) &#123; if(num[i] == num[mid]) &#123; right--; &#125; else &#123; break; &#125; &#125; if(left == right) &#123; cout&lt;&lt;num[mid]; &#125; else &#123; cout&lt;&lt;"-1"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1348 Couple number]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1348%20Couple%20number.html</url>
    <content type="text"><![CDATA[洛谷 P1348 Couple number链接https://www.luogu.org/problem/P1348 题目题目描述任何一个整数N都能表示成另外两个整数a和b的平方差吗？如果能，那么这个数N就叫做Couple number。你的工作就是判断一个数N是不是Couple number。 输入格式仅一行，两个长整型范围内的整数n1和n2，之间用1个空格隔开。 输出格式输出在n1到n2范围内有多少个Couple number。 注意：包括n1和n2两个数，且n1&lt;n2，n2 - n1 &lt;= 10 000 000。 输入输出样例输入 #1 11 10 输出 #1 17 思路现在这些都是数学题了咋的，这也是一道代码很简单，但是要考虑的数学题。 平方差就是（a+b）*（a-b），左右两部分奇偶性相同，所以结果可能为奇数或者为4的倍数，循环判断即可。 （存在负数情况，所以判断奇数不能用余数为1，要用余数不为0） 代码12345678910111213141516171819#include&lt;iostream&gt; using namespace std;int main()&#123; long long n,m; cin&gt;&gt;n&gt;&gt;m; int num=0; for(long long i=n;i&lt;=m;i++) &#123; if(i%4==0||i%2!=0) &#123; num++; &#125; &#125; cout&lt;&lt;num; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[P1244 青蛙过河]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1244%20%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3.html</url>
    <content type="text"><![CDATA[洛谷 P1244 青蛙过河链接https://www.luogu.org/problem/P1244 题目题目描述有一条河，左边一个石墩(A区)上有编号为1，2，3，4，…，n的n只青蛙，河中有k个荷叶(C区)，还有h个石墩(D区)，右边有一个石墩(B区)，如下图所示。n只青蛙要过河(从左岸石墩A到右岸石墩B)，规则为： (1)石墩上可以承受任意多只青蛙，荷叶只能承受一只青蛙(不论大小)； (2)青蛙可以：A→B(表示可以从A跳到B，下同)，A→C，A→D，C→B，D→B，D→C，C→D； (3)当一个石墩上有多只青蛙时，则上面的青蛙只能跳到比它大1号的青蛙上面。 你的任务是对于给出的h，k，计算并输出最多能有多少只青蛙可以根据以上规则顺利过河? 输入格式两个整数h,k 输出格式一个整数，表示最多能有多少只青蛙可以根据以上规则顺利过河。 输入输出样例输入 #1 12 3 输出 #1 116 思路这道题超出了我的想象。。。。。我没怎么看懂，之后看了别人的博客才搞明白，按道理说用动态规划，但是化简之后的式子就是直接h，k组成的，如果没有石墩，那么只有k+1个，每有一个石墩，数量就增加为（k+1）*2^h，就是每多一个石墩就多了一次周转的机会，然后输出结果就行了。 代码1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int h,k; cin&gt;&gt;h&gt;&gt;k; long long num=k+1; for(int i=0;i&lt;h;i++) &#123; num=num*2; &#125; cout&lt;&lt;num; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1908 逆序对]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1908%20%E9%80%86%E5%BA%8F%E5%AF%B9.html</url>
    <content type="text"><![CDATA[洛谷 P1908 逆序对链接https://www.luogu.org/problem/P1908 题目题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。Update:数据已加强。 输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过10^9 输出格式给定序列中逆序对的数目。 输入输出样例输入 #1 1265 4 2 6 3 1 输出 #1 111 说明/提示对于25%的数据，0n≤2500 对于50%的数据，n≤4×10^4。 对于所有数据，n≤5×10^5 请使用较快的输入输出 应该不会n方过50万吧 by chen_zhe 思路这题。。。难倒是不难，但是我没注意数据范围，re三次。 寻找逆序对的话，排序就行，这里的数据量肯定不能冒泡，所以归并（方便统计数量），归并排序的算法不是很难，以后我会补个排序算法集合（鸽德），这里只需要注意两点，一点是sum每次增加mid-left+1，这个1可能会漏；第二点是数据范围，数组要50w的，答案要long long。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;using namespace std;int n,now[500010],next[500010];long long sum=0;void merge(int l,int r)&#123; if(l==r) return; int mid=(l+r)/2; merge(l,mid); merge(mid+1,r); int left=l,right=mid+1,count=l; while(left&lt;=mid&amp;&amp;right&lt;=r) &#123; if(now[left]&lt;=now[right]) &#123; next[count]=now[left]; left++; count++; &#125; else &#123; next[count]=now[right]; count++; right++; sum+=mid-left+1; &#125; &#125; while(left&lt;=mid) &#123; next[count]=now[left]; count++; left++; &#125; while(right&lt;=r) &#123; next[count]=now[right]; right++; count++; &#125; for(int i=l;i&lt;=r;i++) &#123; now[i]=next[i]; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;now[i]; &#125; merge(0,n-1); cout&lt;&lt;sum; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1192 台阶问题]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1192%20%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[洛谷 P1192 台阶问题链接https://www.luogu.org/problem/P1092 题目题目描述有N级的台阶，你一开始在底部，每次可以向上迈最多K级台阶（最少1级），问到达第N级台阶有多少种不同方式。 输入格式两个正整数N，K。 输出格式一个正整数，为不同方式数，由于答案可能很大，你需要输出ans mod 100003后的结果。 输入输出样例输入 #1 15 2 输出 #1 18 说明/提示对于20%的数据,有N≤10,K≤3; 对于40%的数据，有N≤1000; 对于100%的数据，有N≤100000,K*≤100。 思路算法以前是见过的，但是学名我忘了emmmm，不知道算不算动态规划。 假设要到第3个台阶，最大可以走三阶，我们可以0-1-2-3，也可以0-1-3,0-2-3,0-3，一共有四种方法，第一步到的就是123其中之一： 如果到1，再到3的方法和0-2的方法一样（2种），之后再走一步 到2，再到3和0-1的方法一样（1种） 直接到3，和0-0一样（1种） 就可以得到 1f[i] += f[i-j] 这个式子，之后放到代码中组合，最后得到的f[n]就是我们需要的答案。 代码123456789101112131415161718192021222324#include&lt;iostream&gt; using namespace std;int main()&#123; int n, k; int f[100001] = &#123; 0 &#125;; cin&gt;&gt;n&gt;&gt;k; f[0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=k;j++) &#123; if(i&gt;=j) &#123; f[i] += f[i-j]; f[i] = f[i]%100003; &#125; &#125; &#125; cout&lt;&lt;f[n]; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1029 最大公约数和最小公倍数问题]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1029%20%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[洛谷 P1029 最大公约数和最小公倍数问题链接https://www.luogu.org/problem/P1029 题目题目描述输入2个正整数x0,y0(2≤x0&lt;100000,2≤y*0&lt;=1000000),求出满足下列条件的P,Q的个数 条件: P,Q是正整数 要求P,Q*以x0为最大公约数,以y0为最小公倍数. 试求:满足条件的所有可能的2个正整数的个数. 输入格式2个正整数x0,y*0 输出格式1个数，表示求出满足条件的P,Q的个数 输入输出样例输入 #1 13 60 输出 #1 14 说明/提示P,Q有4种 1、3,602、15,123、12,154、60,3 思路题目就是输入x，y，一为最小公约数，一为最大公倍数，求存在的pq对数。 p=x*k1,q=x*k2,y=x*k1*k2,k1k2互质，这就是总结之后的关系，x*y=p*q,将基于这个公式和辗转相除法来计算。 输入xy，寻找pq乘积为xy的对，之后判断这对pq的最大公约数是不是x，是的话结果就加二（一正一反）。最后，考虑到x=y,比如3,3，若如此，结果加一。 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int gcd(int a,int b)&#123; if(b!=0) return gcd(b,a%b); return a;&#125;int main()&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; int sum=0; for(int i=1;i*i&lt;x*y;i++) &#123; if((x*y)%i==0 &amp;&amp; gcd(i,(x*y)/i)==x) sum++; &#125; sum = sum*2; if(x==y) sum++; cout&lt;&lt;sum; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2017-03-2 学生排队]]></title>
    <url>%2FCCF%202017-03-2%20%E5%AD%A6%E7%94%9F%E6%8E%92%E9%98%9F.html</url>
    <content type="text"><![CDATA[CCF 2017-03-2 学生排队题目问题描述 体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。 例如，下面给出了一组移动的例子，例子中学生的人数为8人。 0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8； 1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8； 2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7； 3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。 小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？ 请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。 输入格式 输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。 第二行包含一个整数m，表示调整的次数。 接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。 输出格式 输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。 样例输入12345833 28 -33 -2 样例输出11 2 4 3 5 8 6 7 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。 思路也是简单的数字操作题，代码我是大一还是大二敲的，就直接放上来了。用数组存储学生，之后输入，找到该学生的位置，之后数组位移一下即可。用结构体可能会方便一点，但是这个计算量没必要。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int main()&#123; int n,i,k,q,w,j,t,x,s; cin&gt;&gt;n&gt;&gt;k; int a[n+1]; for(i=1;i&lt;=n;i++) &#123; a[i]=i; &#125; for(i=1;i&lt;=k;i++) &#123; cin&gt;&gt;q&gt;&gt;w; for(j=1;j&lt;=n;j++) &#123; if(a[j]==q) t=j; &#125; if(w&gt;0) &#123; x=a[t]; for(s=t;s&lt;t+w;s++) a[s]=a[s+1]; a[t+w]=x; &#125; else &#123; x=a[t]; for(s=t;s&gt;t+w;s--) a[s]=a[s-1]; a[t+w]=x; &#125; &#125; for(i=1;i&lt;=n;i++) &#123; cout&lt;&lt;a[i]; if(i!=n) cout&lt;&lt;" "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2017-03-1 分蛋糕]]></title>
    <url>%2FCCF%202017-03-1%20%E5%88%86%E8%9B%8B%E7%B3%95.html</url>
    <content type="text"><![CDATA[CCF 2017-03-1 分蛋糕题目问题描述 小明今天生日，他有n块蛋糕要分给朋友们吃，这n块蛋糕（编号为1到n）的重量分别为a1, a2, …, an。小明想分给每个朋友至少重量为k的蛋糕。小明的朋友们已经排好队准备领蛋糕，对于每个朋友，小明总是先将自己手中编号最小的蛋糕分给他，当这个朋友所分得蛋糕的重量不到k时，再继续将剩下的蛋糕中编号最小的给他，直到小明的蛋糕分完或者这个朋友分到的蛋糕的总重量大于等于k。 请问当小明的蛋糕分完时，总共有多少个朋友分到了蛋糕。 输入格式 输入的第一行包含了两个整数n, k，意义如上所述。 第二行包含n个正整数，依次表示a1, a2, …, an。 输出格式 输出一个整数，表示有多少个朋友分到了蛋糕。 样例输入126 92 6 5 6 3 5 样例输出13 样例说明 第一个朋友分到了前3块蛋糕，第二个朋友分到了第4、5块蛋糕，第三个朋友分到了最后一块蛋糕。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 10000，1 ≤ ai ≤ 1000。 思路不是难题，甚至可以不用数组，直接在输入的时候进行一步判断，sum代表当个人拿到的蛋糕，num代表人数，最后需要判断一下sum是否为0. 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; int a; int num=0; int sum=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; sum+=a; if(sum&gt;=k) &#123; num++; sum=0; &#125; &#125; if(sum&gt;0) &#123; num++; &#125; cout&lt;&lt;num; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1049 装箱问题]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1049%20%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[洛谷 P1049 装箱问题链接https://www.luogu.org/problem/P1049 题目题目描述有一个箱子容量为V（正整数 0≤V≤20000），同时有n个物品（0&lt;n≤30，每个物品有一个体积（正整数）。 要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。 输入格式1个整数，表示箱子容量 1个整数，表示有n个物品 接下来n行，分别表示这n个物品的各自体积 输出格式1个整数，表示箱子剩余空间。 输入输出样例输入 #1 123456782468312797 输出 #1 10 说明/提示NOIp2001普及组 第4题 思路01背包问题，还是最标准的那种，借助一下max就行（想动态规划往上面怼的也可以），先输入数据，之后借助二重循环，外层循环是物品的循环，第一件到最后一件，内层循环是重量，从总重量V到物品重量，之后拿总重量减去结果就得到答案。 （动态规划一定不鸽，有空就写—-鸽德） 代码123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int main()&#123; int V,n; cin&gt;&gt;V&gt;&gt;n; int a[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; int f[20001]=&#123;0&#125;; for(int i=0;i&lt;n;i++) &#123; for(int j=V;j&gt;=a[i];j--) &#123; f[j]=max(f[j],f[j-a[i]]+a[i]); &#125; &#125; cout&lt;&lt;V-f[V]; return 0; &#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1097 统计数字]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1097%20%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[洛谷 P1097 统计数字链接https://www.luogu.org/problem/P1097 题目题目背景警告：数据可能存在加强 题目描述某次科研调查时得到了n个自然数，每个数均不超过1500000000(1.5×109)。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。 输入格式共n+1行。 第一行是整数n，表示自然数的个数； 第2至n+1每行一个自然数。 输出格式共m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。 每行输出2个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。 输入输出样例输入 #1 1234567898242451002100 输出 #1 12342 34 25 1100 2 说明/提示40%的数据满足：1≤n≤1000 80%的数据满足：1≤n≤50000 100%的数据满足：1≤n≤200000，每个数均不超过1500000000(1.5×109) NOIP 2007 提高第一题 思路题目的要求就是统计出现的数字和出现的次数，顺便加个排序。这时候借助数据结构会简单很多。 对于计数，可以用map（数组其实也行），然后就是去重和排序，巧了，set可以满足这些需求，自动去重排序，insert就行。 最后的输出。。。初始化一下才可以，记住格式就行，之后从头输出到尾。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;int main() &#123; map &lt;int,int&gt; newmap; set &lt;int&gt; newset; int n,number; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;number; newmap[number]++; newset.insert(number); &#125; set&lt;int&gt;::iterator iter; for(iter=newset.begin(); iter!=newset.end(); iter++) cout&lt;&lt;*iter&lt;&lt;" "&lt;&lt;newmap[*iter]&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 2017-09-2 公共钥匙盒]]></title>
    <url>%2FCCF%202017-09-2%20%E5%85%AC%E5%85%B1%E9%92%A5%E5%8C%99%E7%9B%92.html</url>
    <content type="text"><![CDATA[CCF 2017-09-2 公共钥匙盒题目问题描述 有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。 钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。 每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。 今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？ 输入格式 输入的第一行包含两个整数N, K。 接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。 保证输入数据满足输入格式，你不用检查数据合法性。 输出格式 输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。 样例输入1235 24 3 32 2 7 样例输出11 4 3 2 5 样例说明 第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。 每个关键时刻后的钥匙状态如下（X表示空）： 时刻2后为1X345； 时刻3后为1X3X5； 时刻6后为143X5； 时刻9后为14325。 样例输入123456785 71 1 143 3 121 15 122 7 203 18 124 21 195 30 9 样例输出11 2 3 5 4 评测用例规模与约定 对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30； 对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50； 对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。 思路这题好像是去年敲的，就偷个懒，用了之前的代码。（如果有空我来把代码重构一下） 主要考虑到数字处理，顺便将时间线缕清，注意时间顺序，先还后取。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;using namespace std;int main()&#123; int n,k,end=0,start=10111,i,j,t,ti; cin&gt;&gt;n&gt;&gt;k; int cl[1010],w[1010],s[1010],c[1010],q[1010]; for(t=1;t&lt;=n;t++) &#123; cl[t]=t; &#125; for(t=1;t&lt;=k;t++) &#123; cin&gt;&gt;w[t]&gt;&gt;s[t]&gt;&gt;c[t]; c[t]=s[t]+c[t]; if(c[t]&gt;end) end=c[t]; if(s[t]&lt;start) start=s[t]; &#125; for(ti=start;ti&lt;=end;ti++) &#123; //huan int huan=0; for(i=1;i&lt;=k;i++) &#123; if(c[i]==ti) &#123; huan++; q[huan]=w[i]; &#125; &#125; for(i=1;i&lt;=huan;i++) &#123; for(j=1;j&lt;=huan;j++) &#123; if(q[i]&lt;q[j]) &#123; int ty=q[i]; q[i]=q[j]; q[j]=ty; &#125; &#125; &#125; for(i=1;i&lt;=huan;i++) &#123; int po=1; for(j=1;j&lt;=n&amp;&amp;po;j++) &#123; if(cl[j]==0) &#123; cl[j]=q[i]; po=0; &#125; &#125; &#125; //qu for(i=1;i&lt;=k;i++) &#123; if(s[i]==ti) &#123; int po=1; for(j=1;j&lt;=n&amp;&amp;po;j++) &#123; if(cl[j]==w[i]) &#123; cl[j]=0; po=0; &#125; &#125; &#125; &#125; &#125; for(i=1;i&lt;=n;i++) &#123; cout&lt;&lt;cl[i]; if(i!=n) cout&lt;&lt;" "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 201709-1 打酱油]]></title>
    <url>%2FCCF%20201709-1%20%E6%89%93%E9%85%B1%E6%B2%B9.html</url>
    <content type="text"><![CDATA[CCF 201709-1 打酱油题目问题描述 小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。 输入格式 输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。 输出格式 输出一个整数，表示小明最多可以得到多少瓶酱油。 样例输入​ 40 样例输出​ 5 样例说明 把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。 样例输入​ 80 样例输出​ 11 样例说明 把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。 思路简单题目，考虑到优先级即可。（如果数字比例不同就有可能需要动态规划，但是这题不需要） 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int sum=0; while(n&gt;=30) &#123; if(n&gt;=50) &#123; n-=50; sum+=7; continue; &#125; if(n&gt;=30) &#123; n-=30; sum+=4; continue; &#125; &#125; sum += n/10; cout&lt;&lt;sum; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1007 独木桥]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1007%20%E7%8B%AC%E6%9C%A8%E6%A1%A5.html</url>
    <content type="text"><![CDATA[洛谷 P1007 独木桥链接https://www.luogu.org/problem/P1007 题目题目背景战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳1个人通过。假如有2个人相向而行在桥上相遇，那么他们2个人将无妨绕过对方，只能有1个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。 题目描述突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为L，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为1，但一个士兵某一时刻来到了坐标为0或L+1的位置，他就离开了独木桥。 每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。 由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。 输入格式第一行：一个整数L，表示独木桥的长度。桥上的坐标为1…L 第二行：一个整数N，表示初始时留在桥上的士兵数目 第三行：有N个整数，分别表示每个士兵的初始坐标。 输出格式只有一行，输出2个整数，分别表示部队撤离独木桥的最小时间和最大时间。2个整数由一个空格符分开。 输入输出样例输入 #1 123421 3 输出 #1 12 4 说明/提示初始时，没有两个士兵同在一个坐标。 数据范围N≤L≤5000。 思路题目还行，思路也比较清晰，唯一需要注意的点就是，两个士兵相遇掉头和他们交错通过是一样的时间，所以只需要修改min为max即可。 代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int l,n; cin&gt;&gt;l&gt;&gt;n; int a[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; int mintime=0; for(int i=0;i&lt;n;i++) &#123; mintime = max(mintime,min(a[i],l+1-a[i])); &#125; int maxtime=0; for(int i=0;i&lt;n;i++) &#123; maxtime = max(maxtime,max(a[i],l+1-a[i])); &#125; cout&lt;&lt;mintime&lt;&lt;" "&lt;&lt;maxtime; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1011 车站]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1011%20%E8%BD%A6%E7%AB%99.html</url>
    <content type="text"><![CDATA[洛谷 P1011 车站链接https://www.luogu.org/problem/P1011 题目题目描述火车从始发站（称为第1站）开出，在始发站上车的人数为a，然后到达第2站，在第22站有人上、下车，但上、下车的人数相同，因此在第2站开出时（即在到达第3站之前）车上的人数保持为a人。从第3站起（包括第3站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第n-1站），都满足此规律。现给出的条件是：共有N个车站，始发站上车的人数为a，最后一站下车的人数是m（全部下车）。试问x站开出时车上的人数是多少？ 输入格式a(≤20)，n(≤20)，m(≤2000)，和x(≤20)， 输出格式从x站开出时车上的人数。 输入输出样例输入 #1 5 7 32 4输出 #1 13图解 站序号(i) 上车(f) 下车(g) 剩余人数(k) 1 a 0 a 2 t t a 3 a+t t 2a 4 a+2t a+t 2a+t 5 2a+3t a+2t 3a+2t 6 0 3a+2t 0 思路总结一下规律(中间几站) 1. 每一站下车人数等于上一站上车人数 2. 每一站上车人数等于前两站上车人数和我们假设第6站就全部下车，可以得到图解中的表格，归纳总结可以发现(s为斐波那契数列，直接可以计算) 1. g(i) = f(i-1) 2. f(i) = f(i-1) + f(i-2) 3. g(n) = f(n-1) + a - t = m 4. f(i) = s(i-2)*a + s(i-1)*t 5. k(i) = f(i) + f(1) - g(2)之后我们就能发现，我们需要的k(x) = f(x) + a - t,推导后只需要两个等式 1. m - [s(n-3) + 1]*a = [s(n-2) - 1]*t 2. k(x) = [s(x-2) + 1]*a + [s(x-1) - 1]*t给了我们m,a,n,我们由公式1算出t，公式2算出k(x)即可。 代码123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; int a,n,m,x,t; cin&gt;&gt;a&gt;&gt;n&gt;&gt;m&gt;&gt;x; int s[n]; s[1]=1; s[2]=1; for(int i=3;i&lt;=n;i++) s[i]=s[i-1]+s[i-2]; t=(m-(s[n-3]+1)*a)/(s[n-2]-1); cout&lt;&lt;(s[x-2]+1)*a+(s[x-1]-1)*t; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1307 数字反转]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1307%20%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC.html</url>
    <content type="text"><![CDATA[洛谷 P1307 数字反转链接https://www.luogu.org/problem/P1307 题目题目描述 给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例2）。 输入格式 一个整数 NN 输出格式 一个整数，表示反转后的新数。 输入输出样例 输入 #1 123 输出 #1 321 输入 #2 -380 输出 #2 -83明/提示 数据范围 -1,000,000,000≤N≤1,000,000,000 noip2011普及组第一题 思路 思路清晰，先判断是否为负数，记录一下，之后反复取尾数，直到结束，输出。 这题真的做过，不过上次是在LeetCode上面做的，用的java。 代码1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;limits.h&gt;using namespace std;int main()&#123; int ans = 0; int x; cin &gt;&gt; x; int num = abs(x); int max = INT_MAX/10; while(num&gt;0) &#123; int t = num % 10; if(ans &gt; max) return 0; ans = ans * 10 + t; num = num / 10; &#125; if(x&gt;0) cout &lt;&lt; ans; else cout &lt;&lt; -ans; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FHello%20World.html</url>
    <content type="text"><![CDATA[这是我在GitHub上的写第一篇博客，希望大家能互相学习，共同进步。 这边的博客因为才开始，所以界面功能也不怎么完善，会慢慢改进。 博客园地址：https://www.cnblogs.com/blogxjc/ 迁移的时候出了点问题，所以8月1日前的博客会存在时间上的问题。 考研初试结束，最近准备春招，这方面的会多一点。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CCF 201712-1 最小差值]]></title>
    <url>%2FCCF%20201712-1%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC.html</url>
    <content type="text"><![CDATA[CCF 201712-1 最小差值题目问题描述给定 n 个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。 输入格式输入第一行包含一个整数 n 。第二行包含 n 个正整数，相邻整数之间使用一个空格分隔。 输出格式输出一个整数，表示答案。 样例输入5 1 5 4 8 20样例输出1样例说明相差最小的两个数是5和4，它们之间的差值是1。 样例输入5 9 3 6 1 3样例输出0样例说明有两个相同的数3，它们之间的差值是0. 数据规模和约定对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。 思路数组处理，来个二重循环找最小值，第一题也不会在时间上面卡人的。 代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int min=10000; int a[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; if(abs(a[i]-a[j])&lt;min) min=abs(a[i]-a[j]); &#125; &#125; cout&lt;&lt;min; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1003 铺地毯]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1003%20%E9%93%BA%E5%9C%B0%E6%AF%AF.html</url>
    <content type="text"><![CDATA[洛谷 P1003 铺地毯链接https://www.luogu.org/problem/P1003 题目题目描述为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n张地毯，编号从 1到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。 地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入格式输入共n+2行 第一行，一个整数n，表示总共有nn张地毯 接下来的n行中，第 i+1行表示编号ii的地毯的信息，包含四个正整数a ,b ,g ,k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标(a,b)以及地毯在x轴和y轴方向的长度 第n+2行包含两个正整数x和y，表示所求的地面的点的坐标(x,y) 输出格式输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1 输入输出样例输入 #1 3 1 0 2 3 0 2 3 3 2 1 3 3 2 2输出 #1 3输入 #2 3 1 0 2 3 0 2 3 3 2 1 3 3 4 5输出 #2 -1说明/提示【样例解释1】 如下图，1号地毯用实线表示，2 号地毯用虚线表示，3号用双实线表示，覆盖点(2,2)的最上面一张地毯是 3 号地毯。 【数据范围】 对于30% 的数据，有 n ≤2 ；对于50% 的数据，0 ≤a, b, g, k≤100；对于100%的数据，有 0 ≤n ≤10,000，0≤a, b, g, k ≤100,000。 noip2011提高组day1第1题 思路本来是打算偷懒的，但是我的devc++好像不能初始化10000*10000的数组，我就换了个方式。 先把所有数据输入，之后倒序查找，查找点是否在最后一张地毯上，在就跳出，不然就查找倒数第二条。 （话说洛谷题目复制，有数字字母会重影，就很浮夸） 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[10001],b[10001],c[10001],d[10001]; int ans; int x,y; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i]&gt;&gt;d[i]; &#125;cin&gt;&gt;x&gt;&gt;y;bool flag=false;for(int i=n;i&gt;0;i--)&#123; if(a[i]&lt;=x&amp;&amp;a[i]+c[i]&gt;=x&amp;&amp;b[i]&lt;=y&amp;&amp;b[i]+d[i]&gt;=y) &#123; ans=i; flag=true; break; &#125;&#125;if(flag) cout&lt;&lt;ans;else cout&lt;&lt;&quot;-1&quot;;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 334. Increasing Triplet Subsequence]]></title>
    <url>%2FLeetCode%20334.%20Increasing%20Triplet%20Subsequence.html</url>
    <content type="text"><![CDATA[334.Increasing Triplet Subsequence（递增的三元子序列）链接https://leetcode-cn.com/problems/increasing-triplet-subsequence/ 题目给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。 数学表达式如下: 如果存在这样的 i, j, k, 且满足 0 ≤ i &lt; j &lt; k ≤ n-1，使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。 示例 1: 输入: [1,2,3,4,5]输出: true示例 2: 输入: [5,4,3,2,1]输出: false 思路O（n）那就从头到尾跑一遍就行，简单易懂，设置最小的数字one，次小的数字two，遍历时记得更新这两个数，如果发现数字比two还大，那么达成目的，返回true，不然就是false。 （这题我好像也做过emmmmmm） 代码1234567891011121314151617181920public boolean increasingTriplet(int[] nums) &#123; if (nums.length &lt; 3) &#123; return false; &#125; int one = Integer.MAX_VALUE; int two = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; two) &#123; return true; &#125; if (nums[i] &lt; one) &#123; one = nums[i]; &#125; if (nums[i] &gt; one &amp;&amp; nums[i] &lt; two) &#123; two = nums[i]; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1583 魔法照片]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1583%20%E9%AD%94%E6%B3%95%E7%85%A7%E7%89%87.html</url>
    <content type="text"><![CDATA[洛谷 P1583 魔法照片链接https://www.luogu.org/problem/P1583 题目题目描述一共有n（n≤20000）个人（以1–n编号）向佳佳要照片，而佳佳只能把照片给其中的k个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值W[i]。然后将初始权值从大到小进行排序，每人就有了一个序号D[i]（取值同样是1–n）。按照这个序号对10取模的值将这些人分为10类。也就是说定义每个人的类别序号C[i]的值为(D[i]-1) mod 10+1，显然类别序号的取值为1–10。第i类的人将会额外得到E[i]的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的k个人，并输出他们的编号。在排序中，如果两人的W[i]相同，编号小的优先。 输入格式第一行输入用空格隔开的两个整数，分别是n和k。 第二行给出了10个正整数，分别是E[1]到E[10]。 第三行给出了n个正整数，第i个数表示编号为i的人的权值W[i]。 输出格式只需输出一行用空格隔开的k个整数，分别表示最终的W[i]从高到低的人的编号。 输入输出样例输入 #1 10 10 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20输出 #1 10 9 8 7 6 5 4 3 2 1思路排序，直接想到sort，每个对象多个元素，想起结构体，成了。 结构体中设置num表示初始序号，w表示权值，d表示取模后的值（不要也可以）；sort函数优先权值排序，其次序号排序，输入，排序，更新，排序，输出，行了。 （好像前几天才做过同类型的题目） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct peo&#123; int num; int w; int d;&#125;p[20001];bool cmp(peo a,peo b)&#123; if(a.w!=b.w) return a.w&gt;b.w; else return a.num&lt;b.num;&#125;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; int e[11]; for(int i=1;i&lt;11;i++) &#123; cin&gt;&gt;e[i]; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i].w; p[i].num=i+1; &#125; sort(p,p+n,cmp); for(int i=0;i&lt;n;i++) &#123; p[i].d = i%10+1; p[i].w += e[p[i].d]; &#125; sort(p,p+n,cmp); for(int i=0;i&lt;k;i++) &#123; cout&lt;&lt;p[i].num&lt;&lt;&quot; &quot;; &#125; &#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1103. Distribute Candies to People]]></title>
    <url>%2FLeetCode%201103.%20Distribute%20Candies%20to%20People.html</url>
    <content type="text"><![CDATA[1103.Distribute Candies to People（分糖果||）链接https://leetcode-cn.com/problems/distribute-candies-to-people/ 题目排排坐，分糖果。 我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。 给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。 然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。 重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。 返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。 示例 1： 输入：candies = 7, num_people = 4输出：[1,2,3,1]解释：第一次，ans[0] += 1，数组变为 [1,0,0,0]。第二次，ans[1] += 2，数组变为 [1,2,0,0]。第三次，ans[2] += 3，数组变为 [1,2,3,0]。第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。示例 2： 输入：candies = 10, num_people = 3输出：[5,2,3]解释：第一次，ans[0] += 1，数组变为 [1,0,0]。第二次，ans[1] += 2，数组变为 [1,2,0]。第三次，ans[2] += 3，数组变为 [1,2,3]。第四次，ans[0] += 4，最终数组变为 [5,2,3]。 提示： 1 &lt;= candies &lt;= 10^9 1 &lt;= num_people &lt;= 1000 思路没啥思路，套一个循环，注意改变数量和及时跳出即可。如果想要更简单一点的，可以通过通项公式直接算出该轮所需糖果，直接分配也行。 代码12345678910111213141516171819202122public int[] distributeCandies(int candies, int num_people) &#123; int[] number = new int[num_people]; int num = 1; int i = 0; while (candies &gt; 0) &#123; number[i] += num; candies -= num; i++; if (i == num_people) &#123; i = 0; &#125; if (candies &gt; num + 1) &#123; num++; &#125; else &#123; number[i] += candies; break; &#125; &#125; return number; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1093 奖学金]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1093%20%E5%A5%96%E5%AD%A6%E9%87%91.html</url>
    <content type="text"><![CDATA[洛谷 P1093 奖学金链接https://www.luogu.org/problem/P1093 题目题目描述某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。 任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分)是: 7 279 5 279 这两行数据的含义是:总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和)，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是: 5 279 7 279 则按输出错误处理，不能得分。 输入格式共n+1行。 第1行为一个正整数n(≤300)，表示该校参加评选的学生人数。 第2到n+1行，每行有3个用空格隔开的数字，每个数字都在0到100之间。第j行的3个数字依次表示学号为j-1的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为1~n（恰好是输入数据的行号减1）。 所给的数据都是正确的，不必检验。 //感谢 黄小U饮品 修正输入格式 输出格式共5行，每行是两个用空格隔开的正整数，依次表示前5名学生的学号和总分。 输入输出样例输入 #1复制 6 90 67 80 87 66 91 78 89 91 88 99 77 67 89 64 78 89 98 输出 #1复制 6 265 4 264 3 258 2 244 1 237输入 #2 8 80 89 89 88 98 78 90 67 80 87 66 91 78 89 91 88 99 77 67 89 64 78 89 98输出 #2 8 265 2 264 6 264 1 258 5 258思路：挺不错的一道题，考虑排序优先级即可。我这里用了结构体来存放学号和成绩，借助sort和cmp设置排序，优先总分，其次语文，最后学号，最后输出前五个即可。 （这里有个坑，排序函数中要注意，学号是小的在前面，分数是大的在前面，我就因为这个错了一次） 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct stu&#123; int num; int c; int m; int e; int score;&#125;s[301];bool cmp(stu a,stu b)&#123; if(a.score!=b.score) &#123; return a.score&gt;b.score; &#125; else if(a.c!=b.c) &#123; return a.c&gt;b.c; &#125; else &#123; return a.num&lt;b.num; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; s[i].num=i+1; cin&gt;&gt;s[i].c&gt;&gt;s[i].m&gt;&gt;s[i].e; s[i].score=s[i].c+s[i].m+s[i].e; &#125; sort(s,s+n,cmp); for(int i=0;i&lt;5;i++) &#123; cout&lt;&lt;s[i].num&lt;&lt;&quot; &quot;&lt;&lt;s[i].score&lt;&lt;&quot; &quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 38. Count and Say]]></title>
    <url>%2FLeetCode%2038.%20Count%20and%20Say.html</url>
    <content type="text"><![CDATA[38.Count and Say（报数）链接https://leetcode-cn.com/problems/count-and-say/ 题目报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1 11 21 1211 1112211 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1 输出: &quot;1&quot; 示例 2: 输入: 4 输出: &quot;1211&quot;思路怎么说呢，一道题目很绕的简单题。思路就是每次得到的都是基于上次的字符串，第三次21，一个2一个1，第四次就是1211，第五次就是11+12+21，以此类推。找到规律之后就是简单的遍历了。 代码12345678910111213141516171819202122232425public String countAndSay(int n) &#123; String str = &quot;1&quot;; for (int i = 2; i &lt;= n; i++) &#123; StringBuilder sb = new StringBuilder(); char old = str.charAt(0); int num = 1; for (int j = 1; j &lt; str.length(); j++) &#123; char one = str.charAt(j); if (one == old) &#123; num++; &#125; else &#123; sb.append(num); sb.append(old); old = one; num = 1; &#125; &#125; sb.append(num); sb.append(old); str = sb.toString(); &#125; return str;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 201803-2 碰撞的小球]]></title>
    <url>%2FCCF%20201803-2%20%E7%A2%B0%E6%92%9E%E7%9A%84%E5%B0%8F%E7%90%83.html</url>
    <content type="text"><![CDATA[CCF 201803-2 碰撞的小球题目问题描述数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。 提示因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。 输入格式输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。 输出格式输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。 样例输入3 10 54 6 8 样例输出7 9 9 样例说明初始时，三个小球的位置分别为4, 6, 8。一秒后，三个小球的位置分别为5, 7, 9。两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。五秒后，三个小球的位置分别为7, 9, 9。 样例输入10 22 30 14 12 16 6 10 2 8 20 18 4样例输出6 6 8 2 4 0 4 12 10 2数据规模和约定对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 &lt; ai &lt; L。L为偶数。保证所有小球的初始位置互不相同且均为偶数。 思路题目挺有意思的，借助碰撞来修改速度，按时间来运动，得到最后结果。 我建立了三个数组，place（小球当前时间点的坐标），speed（小球速度，1正向-1反向），line（线段上面是否有小球）；如果line上存在冲突，二者都反向运动；撞到端点也是，最后输出place即可。 （ccf是不是不能用memset，我连续运行错误三次，偷懒都不行）。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; int place[1002]; int speed[1002]; int line[1002]; int n,l,t; cin&gt;&gt;n&gt;&gt;l&gt;&gt;t; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;place[i]; speed[i]=1; &#125; for(int i=0;i&lt;t;i++) &#123; for(int j=0;j&lt;=l;j++) line[j]=0; for(int j=1;j&lt;=n;j++) &#123; place[j] += speed[j]; if(place[j]==0||place[j]==l) &#123; speed[j] = (-1)*speed[j]; &#125; if(line[place[j]]==0) &#123; line[place[j]] = j; &#125; else &#123; speed[line[place[j]]] = (-1)*speed[line[place[j]]]; speed[j] = (-1)*speed[j]; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;place[i]&lt;&lt;&quot; &quot;; &#125;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 201803-1 跳一跳]]></title>
    <url>%2FCCF%20201803-1%20%E8%B7%B3%E4%B8%80%E8%B7%B3.html</url>
    <content type="text"><![CDATA[CCF 201803-1 跳一跳题目问题描述近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8…）。现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。 输入格式输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。 输出格式输出一个整数，为本局游戏的得分（在本题的规则下）。 样例输入1 1 2 2 2 1 1 2 2 0样例输入22数据规模和约定对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。 思路正常题目，输入考虑一下变化关系，注意+2和归1即可。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt; using namespace std;int main()&#123; int sum=0; int n; int score=1; while(true) &#123; cin&gt;&gt;n; if(n==1) &#123; score=1; sum+=score; &#125; else if(n==2) &#123; if(score==1) &#123; score=2; sum+=score; &#125; else &#123; score+=2; sum+=score; &#125; &#125; else if(n==0) &#123; break; &#125; &#125; cout&lt;&lt;sum; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1603 斯诺登的密码]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1603%20%E6%96%AF%E8%AF%BA%E7%99%BB%E7%9A%84%E5%AF%86%E7%A0%81.html</url>
    <content type="text"><![CDATA[洛谷 P1603 斯诺登的密码链接https://www.luogu.org/problemnew/show/P1603 题目题目背景根据斯诺登事件出的一道水题 题目描述题目描述 2013年X月X日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为FBI的间谍早已获悉他的具体位置—-但这不是最重要的—-最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。 丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：Obama is a twofivezero.（以”.”结束输出，只有6个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈珺骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个C++程序，输入这条句子后立马给出了相对应的密码。陈珺鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现—-程序被粉碎了！飞机抵达华盛顿只剩5分钟，你必须在这5分钟内编写（杜撰）一个程序，免受上司的10000000000%10大板。破译密码的步骤如下： （1）找出句子中所有用英文表示的数字(≤20)，列举在下： 正规：one two three four five six seven eight nine ten eleven twelve thirteenfourteen fifteen sixteen seventeen eighteen nineteen twenty 非正规：a both another first second third （2）将这些数字平方后%100，如00,05,11,19,86,99。 （3）把这些两位数按数位排成一行，组成一个新数，如果开头为0，就去0。 （4）找出所有排列方法中最小的一个数，即为密码。 // 数据已经修正 By absi2011 如果还有问题请联系我 输入输出格式输入格式： 一个含有6个单词的句子。 输出格式： 一个整型变量（密码）。如果没有符合要求的数字出现，则输出0。 输入输出样例输入样例#1： Black Obama is two five zero .输出样例#1： 425思路好久没见到这么lan的题目了，毫无意义，拿两个字符串数组，一个存放单词，一个存放对应数字，之后循环判断一下输出条件，00不输出，0x考虑是否在开头，别的正常输出即可。（那俩数组还是我ctrl+c的） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std; string num[27] = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;,&quot;ten&quot;,&quot;eleven&quot;,&quot;twelve&quot;,&quot;thirteen&quot;,&quot;fourteen&quot;,&quot;fifteen&quot;,&quot;sixteen&quot;,&quot;seventeen&quot;,&quot;eighteen&quot;,&quot;nineteen&quot;,&quot;twenty&quot;,&quot;a&quot;,&quot;both&quot;,&quot;another&quot;,&quot;first&quot;,&quot;second&quot;,&quot;third&quot;&#125;;string sqare[27]=&#123;&quot;01&quot;,&quot;04&quot;,&quot;09&quot;,&quot;16&quot;,&quot;25&quot;,&quot;36&quot;,&quot;49&quot;,&quot;64&quot;,&quot;81&quot;,&quot;100&quot;,&quot;21&quot;,&quot;44&quot;,&quot;69&quot;,&quot;96&quot;,&quot;25&quot;,&quot;56&quot;,&quot;89&quot;,&quot;24&quot;,&quot;61&quot;,&quot;00&quot;,&quot;01&quot;,&quot;04&quot;,&quot;01&quot;,&quot;01&quot;,&quot;04&quot;,&quot;09&quot;&#125;;int main()&#123; string word[6]; string ans[6]; int len = 0; for(int i=0;i&lt;6;i++) cin&gt;&gt;word[i]; for(int i=0;i&lt;6;i++) &#123; for(int j=0;j&lt;26;j++) &#123; if(word[i]==num[j]) ans[len++]=sqare[j]; &#125; &#125; sort(ans, ans+len); if(len == 0) cout&lt;&lt;&quot;0&quot;; else &#123; for(int i=0;i&lt;len;i++) &#123; if(i==0) &#123; if(ans[i]==&quot;00&quot;) continue; else if(ans[i][0]==&apos;0&apos;) cout&lt;&lt;ans[i][1]; &#125; else if(i=0) cout&lt;&lt;ans[i]; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 169. Majority Element]]></title>
    <url>%2FLeetCode%20169.%20Majority%20Element.html</url>
    <content type="text"><![CDATA[169.Majority Element（求众数）链接https://leetcode-cn.com/problems/majority-element/ 题目给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 思路这题很有趣，多种方法都能解决。我一开始想到的是1.哈希表：数据添加后规模最大的一个就是众数。2.排序：快排或归并排序，中位数就是众数。 之后看了别人的解法，发现了一种新的方法：摩尔投票算法。摩尔投票法的基本思想很简单，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素就是目标元素。 初始化 count = 1;number =nums[0];之后遍历，如果数字和number相同，count++，不同，count–，count=0时重置number和count，如果众数数量大于n/2，最后的数就是这个。 代码123456789101112131415public static int majorityElement(int[] nums) &#123; int count = 0; int number = nums[0]; for (int i = 0; i &lt; nums.length; i++) &#123; if (count == 0) &#123; number = nums[i]; count = 1; &#125; else if (number != nums[i]) &#123; count--; &#125; else &#123; count++; &#125; &#125; return number; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1047. Remove All Adjacent Duplicates In String]]></title>
    <url>%2FLeetCode%201047.%20Remove%20All%20Adjacent%20Duplicates%20In%20String.html</url>
    <content type="text"><![CDATA[1047.Remove All Adjacent Duplicates In String（删除字符串中的所有相邻重复项）链接https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/ 题目给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：”abbaca”输出：”ca”解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串“aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。 提示： 1 &lt;= S.length &lt;= 20000S 仅由小写英文字母组成。 思路我这里借助了栈，把字母塞进去，如果下一个和上一个相同就出栈，不然就入栈，最后借助stringbuffer转置一下，生成字符串。内存超过100%，但是时间超过30%，就很烦。 （idea改变了我的代码规范…….） 代码12345678910111213141516171819202122public static String removeDuplicates(String S) &#123; char[] ch = S.toCharArray(); Stack stack = new Stack(); int i = 0; while (i &lt; ch.length) &#123; if (stack.empty()) &#123; stack.push(ch[i]); &#125; else if (stack.peek().equals(ch[i])) &#123; stack.pop(); &#125; else &#123; stack.push(ch[i]); &#125; i++; &#125; StringBuilder sb = new StringBuilder(); while (!stack.empty()) &#123; sb.append(stack.pop()); &#125; return sb.reverse().toString();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 12. Integer to Roman]]></title>
    <url>%2FLeetCode%2012.%20Integer%20to%20Roman.html</url>
    <content type="text"><![CDATA[12.Integer to Roman（整数转罗马数字）链接https://leetcode-cn.com/problems/integer-to-roman/ 题目罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3 输出: &quot;III&quot; 示例 2: 输入: 4 输出: &quot;IV&quot; 示例 3: 输入: 9 输出: &quot;IX&quot; 示例 4: 输入: 58 输出: &quot;LVIII&quot; 解释: L = 50, V = 5, III = 3. 示例 5: 输入: 1994 输出: &quot;MCMXCIV&quot; 解释: M = 1000, CM = 900, XC = 90, IV = 4.思路倒也不是很麻烦，就是分类筛选，对于字符串进行添加操作，1000级和1级需要借助while循环，别的数直接用if进行一次判断即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static String intToRoman(int num) &#123; StringBuilder str = new StringBuilder(); while (num &gt;= 1000) &#123; str.append(&quot;M&quot;); num = num - 1000; &#125; if (num &gt;= 900) &#123; str.append(&quot;CM&quot;); num = num - 900; &#125; if (num &gt;= 500) &#123; str.append(&quot;D&quot;); num = num - 500; &#125; if (num &gt;= 400 &amp;&amp; num &lt; 500) &#123; str.append(&quot;CD&quot;); num = num - 400; &#125; while (num &gt;= 100) &#123; str.append(&quot;C&quot;); num = num - 100; &#125; if (num &gt;= 90) &#123; str.append(&quot;XC&quot;); num = num - 90; &#125; if (num &gt;= 50) &#123; str.append(&quot;L&quot;); num = num - 50; &#125; if (num &gt;= 40 &amp;&amp; num &lt; 50) &#123; str.append(&quot;XL&quot;); num = num - 40; &#125; while (num &gt;= 10) &#123; str.append(&quot;X&quot;); num = num - 10; &#125; if (num &gt;= 9) &#123; str.append(&quot;IX&quot;); num = num - 9; &#125; if (num &gt;= 5) &#123; str.append(&quot;V&quot;); num = num - 5; &#125; if (num &gt;= 4 &amp;&amp; num &lt; 5) &#123; str.append(&quot;IV&quot;); num = num - 4; &#125; while (num &gt;= 1) &#123; str.append(&quot;I&quot;); num = num - 1; &#125; return str.toString(); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1012 拼数]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1012%20%E6%8B%BC%E6%95%B0.html</url>
    <content type="text"><![CDATA[洛谷 P1012 拼数链接https://www.luogu.org/problemnew/show/P1012 题目题目描述设有n个正整数(n≤20)，将它们联接成一排，组成一个最大的多位整数。 例如：n=3时，3个整数13,312,343联接成的最大整数为：34331213 又如：n=4时，4个整数7,13,4,246联接成的最大整数为：7424613 输入输出格式输入格式： 第一行，一个正整数n。 第二行，n个正整数。 输出格式： 一个正整数，表示最大的整数 输入输出样例输入样例#1： 3 13 312 343输出样例#1： 34331213 思路这题如果是第一次做会有点难度，但是我以前做过同类的，借助字典序来算就会简单很多，对于字典序来说1234&lt;3412，那么12和34这两个数就可以通过字典序来比较，这里设置一个比较函数compare，比较a+b和b+a的字典序，这边设置的是34在12的前面，所以要先输出（3412&gt;1234）.之后借助sort函数排序，按照顺序输出即可。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;bool compare(string a,string b)&#123; return a+b&gt;b+a;&#125;int main()&#123; int n; cin&gt;&gt;n; string num[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;num[i]; sort(num,num+n,compare); for(int i=0;i&lt;n;i++) cout&lt;&lt;num[i]; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 201809-2 买菜]]></title>
    <url>%2FCCF%20201809-2%20%E4%B9%B0%E8%8F%9C.html</url>
    <content type="text"><![CDATA[CCF 201809-2 买菜题目问题描述小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，所以也都要装n次车。具体的，对于小H来说有n个不相交的时间段[a1,b1],[a2,b2]…[an,bn]在装车，对于小W来说有n个不相交的时间段[c1,d1],[c2,d2]…[cn,dn]在装车。其中，一个时间段[s,t]表示的是从时刻s到时刻t这段时间，时长为t-s。由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。 输入格式输入的第一行包含一个正整数n，表示时间段的数量。接下来n行每行两个数ai，bi，描述小H的各个装车的时间段。接下来n行每行两个数ci，di，描述小W的各个装车的时间段。 输出格式输出一行，一个正整数，表示两人可以聊多长时间。 样例输入4 1 3 5 6 9 13 14 15 2 4 5 7 10 11 13 14样例输出3数据规模和约定对于所有的评测用例，1 ≤ n ≤ 2000, ai &lt; bi &lt; ai+1，ci &lt; di &lt; ci+1,对于所有的i(1 ≤ i ≤ n)有，1 ≤ai, bi, ci, di ≤ 1000000。 思路简单题，但是不知道为啥我错了几次，真让人悲伤。设定一个数组当做时间轴，初始化为0，之后如果有人装车，那么时间轴在那段时间上+1，如果二人都在那时候装车，那么那个位置的数应该是2，找到2的数量即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int Num = 1000000;int time[1000000];int main()&#123; int n; cin&gt;&gt;n; int max=0; for(int i=0;i&lt;Num;i++) time[i]=0; for(int i=0;i&lt;n;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(b&gt;max) max = b; for(int j=a;j&lt;b;j++) time[j]++; &#125; for(int i=0;i&lt;n;i++) &#123; int c,d; cin&gt;&gt;c&gt;&gt;d; if(d&gt;max) max = d; for(int j=c;j&lt;d;j++) time[j]++; &#125; int sum=0; for(int i = 1;i&lt;max;i++) &#123; // cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;time[i]&lt;&lt;endl; if(time[i] == 2) &#123; sum++; &#125; &#125; cout&lt;&lt;sum; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCF 201809-1 卖菜]]></title>
    <url>%2FCCF%20201809-1%20%E5%8D%96%E8%8F%9C.html</url>
    <content type="text"><![CDATA[CCF 201809-1 卖菜题目问题描述在一条街上有n个卖菜的商店，按1至n的顺序排成一排，这些商店都卖一种蔬菜。第一天，每个商店都自己定了一个价格。店主们希望自己的菜价和其他商店的一致，第二天，每一家商店都会根据他自己和相邻商店的价格调整自己的价格。具体的，每家商店都会将第二天的菜价设置为自己和相邻商店第一天菜价的平均值（用去尾法取整）。注意，编号为1的商店只有一个相邻的商店2，编号为n的商店只有一个相邻的商店n-1，其他编号为i的商店有两个相邻的商店i-1和i+1。给定第一天各个商店的菜价，请计算第二天每个商店的菜价。 输入格式输入的第一行包含一个整数n，表示商店的数量。第二行包含n个整数，依次表示每个商店第一天的菜价。 输出格式输出一行，包含n个正整数，依次表示每个商店第二天的菜价。 样例输入8 4 1 3 1 6 5 17 9样例输出2 2 1 3 4 9 10 13数据规模和约定对于所有评测用例，2 ≤ n ≤ 1000，第一天每个商店的菜价为不超过10000的正整数。 思路：水题，设置数组存放价格，考虑到首尾计算方式不同即可。而且c++本来除法就能去尾，输入输出，行了。 虽然大一就过了ccf，但是还是打算重新刷一遍题，就当写着玩了，会慢慢更题解和思路，但是那种文本处理题八成不会更，太麻烦了。 代码：12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n],b[n]; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;a[i]; &#125; b[0] = (a[0] + a[1])/2; b[n-1] = (a[n-2] + a[n-1])/2; for(int i = 1; i &lt; n-1; i++) &#123; b[i] = (a[i-1] + a[i] + a[i+1])/3; &#125; for(int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1149 火柴棒等式]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1149%20%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F.html</url>
    <content type="text"><![CDATA[洛谷 P1149 火柴棒等式链接https://www.luogu.org/problemnew/show/P1149 题目题目描述给你n根火柴棍，你可以拼出多少个形如”A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0-9的拼法如图所示： ![](https://cdn.luogu.org/upload/pic/49.png)注意： 加号与等号各自需要两根火柴棍 如果A≠B，则A+B=C与B+A=C视为不同的等式(A,B,C&gt;=0) n根火柴棍必须全部用上 输入输出格式输入格式： 一个整数n(n&lt;=24)。 输出格式： 一个整数，能拼成的不同等式的数目。 输入输出样例输入样例#1： 14输出样例#1： 2输入样例#2： 18输出样例#2： 9说明【输入输出样例1解释】 2个等式为0+1=10+1=1和1+0=11+0=1。 【输入输出样例2解释】 9个等式为： 0+4=4 0+11=11 1+10=11 2+2=4 2+7=9 4+0=4 7+2=9 10+1=11 11+0=11 思路思路也挺清晰的，直接遍历，0-9的火车不一样，用数组记录，借助count函数寻找ABC需要的火柴，二重循环遍历找的所有合适的解。 1100：数字随手写的，因为上限只有24，只有20根可以组成数字，按照929分组，只能有四个大于1000的数：7111，1711,1171,1117，这四个数都无法得到等式，所以构成结果的ABC一定都小于1000，所以这里写1000即可。其实可以算出上限还要低一点，不过也没啥大问题，用1000就行。 （最近有点忙，所以没想啥骚操作） 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int num[10] = &#123;6,2,5,5,4,5,6,3,7,6&#125;;int count(int x)&#123; if(x==0) return num[0]; int res=0; while(x) &#123; res = res + num[x%10]; x = x / 10; &#125; return res;&#125;int main()&#123; int n; int sum=0; cin&gt;&gt;n; n=n-4; if(n&lt;=8) &#123; cout&lt;&lt;&quot;0&quot;; return 0; &#125; for(int i=0;i&lt;1100;i++) &#123; for(int j=0;j&lt;1100;j++) &#123; int k = i + j; if(count(i)+count(j)+count(k)==n) sum++; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1042 乒乓球]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1042%20%E4%B9%92%E4%B9%93%E7%90%83.html</url>
    <content type="text"><![CDATA[洛谷 P1042 乒乓球链接https://www.luogu.org/problemnew/show/P1042 题目题目背景国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中1111分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白1111分制和2121分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。 题目描述华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在1111分制和2121分制下，双方的比赛结果（截至记录末尾）。 比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）： WWWWWWWWWWWWWWWWWWWWWWLW在1111分制下，此时比赛的结果是华华第一局1111比00获胜，第二局1111比00获胜，正在进行第三局，当前比分11比11。而在2121分制下，此时比赛结果是华华第一局2121比00获胜，正在进行第二局，比分22比11。如果一局比赛刚开始，则此时比分为00比00。直到分差大于或者等于22，才一局结束。 你的程序就是要对于一系列比赛信息的输入（WLWL形式），输出正确的结果。 输入输出格式输入格式： 每个输入文件包含若干行字符串，字符串有大写的WW、LL和EE组成。其中EE表示比赛信息结束，程序应该忽略E之后的所有内容。 输出格式： 输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是1111分制下的结果，第二部分是2121分制下的结果，两部分之间由一个空行分隔。 输入输出样例输入样例#1： WWWWWWWWWWWWWWWWWWWW WWLWE输出样例#1： 11:0 11:0 1:1 21:0 2:1说明每行至多25个字母，最多有2500行 思路不是很难，读取输入，统计数据，直接输出，只要记得到E结束，char范围给大一点，考虑到0:0的情况就行。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; char a[2600]; int ans = 0; while(true) &#123; char c = getchar(); if(c==&apos;W&apos;||c==&apos;L&apos;) &#123; a[ans]=c; ans++; &#125; if(c==&apos;E&apos;) break; &#125; int w=0; int l=0; for(int i=0;i&lt;ans;i++) &#123; if(a[i]==&apos;W&apos;) w++; if(a[i]==&apos;L&apos;) l++; if((w&gt;=11||l&gt;=11)&amp;&amp;(abs(w-l)&gt;=2)) &#123; cout&lt;&lt;w&lt;&lt;&quot;:&quot;&lt;&lt;l&lt;&lt;endl; w=0; l=0; &#125; else if(i==ans-1) cout&lt;&lt;w&lt;&lt;&quot;:&quot;&lt;&lt;l&lt;&lt;endl; &#125; if(w==0&amp;&amp;l==0) cout&lt;&lt;w&lt;&lt;&quot;:&quot;&lt;&lt;l&lt;&lt;endl; cout&lt;&lt;endl; w=0; l=0; for(int i=0;i&lt;ans;i++) &#123; if(a[i]==&apos;W&apos;) w++; if(a[i]==&apos;L&apos;) l++; if((w&gt;=21||l&gt;=21)&amp;&amp;abs(w-l)&gt;=2) &#123; cout&lt;&lt;w&lt;&lt;&quot;:&quot;&lt;&lt;l&lt;&lt;endl; w=0; l=0; &#125; else if(i==ans-1) cout&lt;&lt;w&lt;&lt;&quot;:&quot;&lt;&lt;l&lt;&lt;endl; &#125; if(w==0&amp;&amp;l==0) cout&lt;&lt;w&lt;&lt;&quot;:&quot;&lt;&lt;l&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 754. Reach a Number]]></title>
    <url>%2FLeetCode%20754.%20Reach%20a%20Number.html</url>
    <content type="text"><![CDATA[754.Reach a Number（到达终点数字）链接https://leetcode-cn.com/problems/reach-a-number/ 题目在一根无限长的数轴上，你站在0的位置。终点在target的位置。 每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。 返回到达终点需要的最小移动次数。 示例 1: 输入: target = 3输出: 2解释:第一次移动，从 0 到 1 。第二次移动，从 1 到 3 。示例 2: 输入: target = 2输出: 3解释:第一次移动，从 0 到 1 。第二次移动，从 1 到 -1 。第三次移动，从 -1 到 2 。注意: target是在[-10^9, 10^9]范围中的非零整数。 思路emmmmmm这是一道数学题，需要找规律（一看这个数就知道不能暴力破解）。 设定目标坐标为target，已经走了n步，坐标为F（n）=（n+1）*n/2，F（n-1）&lt;sum&lt;=F（n）找规律： 如果每一步都往同方向走，最后的坐标是1+2+3+…+n=（n+1）*n/2。这样成立的话，所需步数就是n步，target=sum； 目标值与sum存在差，（sum-target）为偶数 t 。那么，我们只需要在步长为 t/2 的那步反向走就行了，所需要的步数是 n； 如果二者差距为奇数，（sum-target）为奇数k，这时候就有两种可能： n为奇数，将n拆为（n-1）和1，（n-1）为偶数，按照第一类进行，1就多走两步，一正一反就得到差值1，所需步数为n+2 n为偶数，这时候多走一步n+1，差距就为n+1+sum-target（偶数），也按照第一类进行，只需要n+1步。 代码1234567891011121314151617public static int reachNumber(int target) &#123; target = Math.abs(target); //处理负值的情况 int count = 0; int sum = 0; while (sum &lt; target) &#123; count++; sum = sum + count; &#125; if ((sum - target) % 2 != 0) &#123; if (count % 2 == 0) &#123; count = count + 1; &#125; else &#123; count = count + 2; &#125; &#125; return count;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1068 分数线划定]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1068%20%E5%88%86%E6%95%B0%E7%BA%BF%E5%88%92%E5%AE%9A.html</url>
    <content type="text"><![CDATA[洛谷 P1068 分数线划定链接https://www.luogu.org/problemnew/show/P1068 题目题目描述世博会志愿者的选拔工作正在 A市如火如荼的进行。为了选拔最合适的人才，AA市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的150%划定，即如果计划录取m名志愿者，则面试分数线为排名第m×150%（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。 现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。 输入输出格式输入格式： 第一行，两个整数 n,m(5 ≤ n ≤ 5000,3 ≤ m ≤n)n,m(5≤n≤5000,3≤m≤n)，中间用一个空格隔开，其中nn表示报名参加笔试的选手总数，mm表示计划录取的志愿者人数。输入数据保证 m×150%向下取整后小于等于 n 第二行到第 n+1 行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 k(1000 ≤ k ≤9999)k(1000≤k≤9999)和该选手的笔试成绩s(1 ≤ s ≤ 100)s(1≤s≤100)。数据保证选手的报名号各不相同。 输出格式： 第一行，有22个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。 从第二行开始，每行包含22个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。 输入输出样例输入样例#1： 6 3 1000 90 3239 88 2390 95 7231 84 1005 95 1001 88输出样例#1： 88 5 1005 95 2390 95 1000 90 1001 88 3239 88 思路这道题挺不错的，思路清晰，可以用到不少方法。这里用了结构体存储数据，同时用了sort函数进行结构体的排序（有空会详解），让结构体的第一顺序是分数，第二顺序是报名号。之后只需要设置一个line作为分数线，大于等于分数线的都可以进入，根据排好的顺序输出即可。 中间的cmp函数是用于排序的，分数不同按分数排，相同按报名号排，之后一个小循环找到相同分数的，直接输出。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct peo&#123; int num; int score;&#125;a[9001];bool cmp(peo x,peo y)&#123; if(x.score == y.score) return (x.num &lt; y.num); else return (x.score &gt; y.score);&#125;int main()&#123; int m,n; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i].num&gt;&gt;a[i].score; &#125; sort(a,a+n,cmp); int line = m*1.5; while(a[line-1].score==a[line].score&amp;&amp;line&lt;=n) &#123; line++; &#125; cout&lt;&lt;a[line-1].score&lt;&lt;&quot; &quot;&lt;&lt;line&lt;&lt;endl; for(int i=0;i&lt;line;i++) &#123; cout&lt;&lt;a[i].num&lt;&lt;&quot; &quot;&lt;&lt;a[i].score&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 7. Reverse Integer]]></title>
    <url>%2FLeetCode%207.%20Reverse%20Integer.html</url>
    <content type="text"><![CDATA[7.Reverse Integer（整数反转）链接https://leetcode-cn.com/problems/reverse-integer/ 题目给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321示例 3: 输入: 120输出: 21注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 思路简单题，大概有两种思路，一种是直接字符串翻转，怎么翻都行，甚至可以直接整个数组转换。第二种就是数字运算，余数加到上次结果的末尾，直接输出（注意看数字越界了没）。 重点就是数字越界，我这里多加了一个判断，越界归零，虽然这样我还是错了几次。。。。 代码12345678910111213141516171819public static int reverse(int x) &#123; int ans = 0; int num = Math.abs(x); int max = Integer.MAX_VALUE / 10; while (num &gt; 0) &#123; int t = num % 10; if (ans &gt; max) &#123; return 0; &#125; ans = ans * 10 + t; num = num / 10; &#125; if (x &gt; 0) &#123; return ans; &#125; else &#123; return -ans; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 504. Base 7]]></title>
    <url>%2FLeetCode%20504.%20Base%207.html</url>
    <content type="text"><![CDATA[504.Base 7（七进制数）链接https://leetcode-cn.com/problems/base-7/ 题目给定一个整数，将其转化为7进制，并以字符串形式输出。 示例 1: 输入: 100输出: “202”示例 2: 输入: -7输出: “-10”注意: 输入范围是 [-1e7, 1e7] 。 思路没啥思路，直接除7取余，考虑一下正负号。 代码1234567891011121314151617181920public static String convertToBase7(int num) &#123; String res = &quot;&quot;; int flag = 0; if (num == 0) &#123; return &quot;0&quot;; &#125; if (num &lt; 0) &#123; flag = 1; num = -num; &#125; while (num &gt; 0) &#123; res = String.valueOf(num % 7) + res; num = num / 7; &#125; if (flag == 1) &#123; res = &quot;-&quot; + res; &#125; return res;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1598 垂直柱状图]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1598%20%E5%9E%82%E7%9B%B4%E6%9F%B1%E7%8A%B6%E5%9B%BE.html</url>
    <content type="text"><![CDATA[洛谷 P1598 垂直柱状图链接https://www.luogu.org/problemnew/show/P1598 题目题目描述写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过100个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。 输入输出格式输入格式： 四行字符，由大写字母组成，每行不超过100个字符 输出格式： 由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。 输入输出样例输入样例#1： THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG. THIS IS AN EXAMPLE TO TEST FOR YOUR HISTOGRAM PROGRAM. HELLO!输出样例#1： * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z说明每行输出后面不允许出现多余的空格。 思路思路清晰，读取四行数据，检索出现次数，通过数组保存一气呵成，我这里读取输入用的是getline，我觉得会好一点。 （但是这题我debug了半天，最后才发现我少空格。。。。。。） 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int word[27];int main()&#123; int max=0; char a[105]; for(int i=0;i&lt;4;i++) &#123; cin.getline(a,105); int n=strlen(a); for(int j=0;j&lt;n;j++) &#123; if(a[j]&gt;=&apos;A&apos;&amp;&amp;a[j]&lt;=&apos;Z&apos;) word[a[j]-&apos;A&apos;]++; &#125; &#125; for(int i=0;i&lt;26;i++) if(word[i]&gt;max) max=word[i]; for(int i=max;i&gt;=1;i--) &#123; for(int j=0;j&lt;26;j++) &#123; if(word[j]&gt;=i) cout&lt;&lt;&quot;* &quot;; else cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; for(int i=0;i&lt;26;i++) cout&lt;&lt;(char)(&apos;A&apos;+i)&lt;&lt;&quot; &quot;; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2FLeetCode%20153.%20Find%20Minimum%20in%20Rotated%20Sorted%20Array.html</url>
    <content type="text"><![CDATA[153.Find Minimum in Rotated Sorted Array（寻找旋转排序数组中的最小值）链接https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/ 题目假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2]输出: 1示例 2: 输入: [4,5,6,7,0,1,2]输出: 0 思路我觉得，这道题，就是个简单的找最小值，还换了层皮就很浮夸。思路最简单的方法就是从头到尾遍历，找的最小值，效率也不低。我是用的二分法，分到最后head和tail只差一位，找最小值即可。 （话说我这题用时超过了100%的用户，不过内存只超过了41%的用户，有机会可以改进吧） 代码1234567891011121314151617public static int findMin(int[] nums) &#123; int head = 0; int tail = nums.length - 1; int mid = (head + tail) / 2; while (true) &#123; if (tail - head &lt; 2) &#123; break; &#125; if (nums[mid] &lt; nums[tail]) &#123; tail = mid; &#125; else &#123; head = mid; &#125; mid = (head + tail) / 2; &#125; return Math.min(nums[head], nums[tail]); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1059 明明的随机数]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1059%20%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0.html</url>
    <content type="text"><![CDATA[洛谷 P1059 明明的随机数链接https://www.luogu.org/problemnew/show/P1059 题目题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数(N≤100)，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成”去重”与”排序”的工作。 输入输出格式输入格式：输入有两行，第1行为1个正整数，表示所生成的随机数的个数N第2行有N个用空格隔开的正整数，为所产生的随机数。 输出格式：输出也是两行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。 输入输出样例 输入样例#1： 10 20 40 32 67 40 20 89 300 400 15 输出样例#1： 8 15 20 32 40 67 89 300 400思路这个去重就行了，思路清晰（主要是前段时间用过），建议使用set，自动去重，输出的时候借助迭代器输出。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; s; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; int t; cin&gt;&gt;t; s.insert(t); &#125; cout&lt;&lt;s.size()&lt;&lt;endl; set&lt;int&gt;::iterator iter=s.begin(); while(iter!=s.end())&#123; cout&lt;&lt;*iter++&lt;&lt;&apos; &apos;; &#125;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 120. Triangle]]></title>
    <url>%2FLeetCode%20120.%20Triangle.html</url>
    <content type="text"><![CDATA[120.Triangle (三角形最小路径和)链接https://leetcode-cn.com/problems/triangle/ 题目给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [[2],[3,4],[6,5,7],[4,1,8,3]]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 思路简单题，自顶向下或者自底向上方法都行，以第三行的5作为例子，自顶向下值有3,4能移动到它，之后也只能移动到1,8.只需要将能到达该点的两个数取最小的，加入这个数。 自顶向下： 第二行：3-&gt;3+2=5, 4-&gt;4+2=6 第三行：6-&gt;6+5-&gt;11, 5-&gt;5+min(5,6)=10, 7-&gt;7+6=13 第四行：4-&gt;4+11=15, 1-&gt;1+min(11,10)=11, 8-&gt;8+min(10,13)=18, 3-&gt;3+13=16. 最小和为11. 自底向上： 这样可以减少一些需要特殊考虑的地方，思路相同，只不过上下顺序变化，比如第三行的5，可以增加min（1,8），一直到最上层。 （这题思路简单，但是我敲的时候忘了List&lt;List&gt;要怎么用，贼尴尬） 代码12345678910public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; for (int i = triangle.size() - 2; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; triangle.get(i).size(); j++) &#123; int min = Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)); triangle.get(i).set(j, triangle.get(i).get(j) + min); &#125; &#125; return triangle.get(0).get(0);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1047 校门外的树（待完善）]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1047%20%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89.html</url>
    <content type="text"><![CDATA[洛谷 P1047 校门外的树（待完善）链接https://www.luogu.org/problemnew/show/P1047 题目题目描述某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在LL的位置；数轴上的每个整数点，即0,1,2,…,L，都种有一棵树。 由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。 输入输出格式输入格式： 第一行有2个整数L(1≤L≤10000)和 M(1≤M≤100)，L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含2个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。 输出格式： 1个整数，表示马路上剩余的树的数目。 输入输出样例输入样例#1： 500 3 150 300 100 200 470 471输出样例#1： 298思路这题我做的方法一点艺术性没有，建立数组表示树，开始置为1，被砍了就置为0，最后统计数组的总数。数据也不是很大，所以这样也不会超时。 倒是在题解上发现了一些有趣的方法，比如线段树和差分法，这篇博客等有空了我要完善一下，增加新的方法。 代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; int L,M; cin&gt;&gt;L&gt;&gt;M; int a[L+1]; for(int i=0;i&lt;=L;i++) &#123; a[i]=1; &#125; for(int i=0;i&lt;M;i++) &#123; int s,e; cin&gt;&gt;s&gt;&gt;e; for(int j=s;j&lt;=e;j++) a[j]=0; &#125; int sum = 0; for(int i=0;i&lt;=L;i++) &#123; if(a[i]==1) sum++; &#125; cout&lt;&lt;sum; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++万能头文件的内容与优缺点]]></title>
    <url>%2FC%2B%2B%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8E%E4%BC%98%E7%BC%BA%E7%82%B9.html</url>
    <content type="text"><![CDATA[C++万能头文件的内容与优缺点文件内容最近发现了一个C++的头文件bits/stdc++.h，听说这是一个几乎包含了所有C++库函数的头文件，就想更深入的了解一下，下面是头文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// C++ includes used for precompiling -*- C++ -*- // Copyright (C) 2003-2013 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library. This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version. // This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details. // Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation. // You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively. If not, see// &lt;Licenses - GNU Project - Free Software Foundation&gt;. /** @file stdc++.h * This is an implementation file for a precompiled header. */ // 17.4.1.2 Headers // C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt; #if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif // C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt; #if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif 看了别人对于这个头文件的看法，自己也有了更深的认识，包含大量不需要的库的头文件，更适合在oj比赛中使用。如果在软件工程的开发中，我们应该减少包含，控制编译时间和代码大小。 优点 在竞赛中节约时间 减少了编写所有必要头文件的工作量 对于使用的每个函数，不用记住GNU C++的所有STL 缺点： 不属于GNU C++库的标准头文件，在部分情况下可能会失败 使用它将包含许多不必要的东西，并增加编译时间 这个头文件不是C++标准的一部分，因此是不可移植的，应该避免 编译器每次编译翻译单元时都必须实际读取和分析每个包含的头文件，应该减少这类头文件的使用 参考地址https://blog.csdn.net/qq_20240999/article/details/59111606 https://www.geeksforgeeks.org/bitsstdc-h-c/]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1028 数的计算]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1028%20%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97.html</url>
    <content type="text"><![CDATA[洛谷 P1028 数的计算链接https://www.luogu.org/problemnew/show/P1028 题目题目描述我们要求找出具有下列性质数的个数(包含输入的自然数nn): 先输入一个自然数nn(n \le 1000n≤1000),然后对此自然数按照如下方法进行处理: 不作任何处理; 在它的左边加上一个自然数,但该自然数不能超过原数的一半; 加上数后,继续按此规则进行处理,直到不能再加自然数为止. 输入输出格式输入格式： 1个自然数n(n≤1000) 输出格式： 1个整数，表示具有该性质数的个数。 输入输出样例输入样例#1： 6输出样例#1： 6说明满足条件的数为 6，16，26，126，36，136思路题目不难，就是有点没说清楚，也可能是我语文不好emmm。思路就是找的所以可能数的数量，寻找方法是在左侧加入一个小于自身一半的数，加上之后继续寻找，直到那个数为1无法继续添加，而且这个加的数，是上次添加的数的一半。 暴力递归一看就会超时，这种题肯定不能这么做。（如果你打算递归打表那就当我没说） 这边我就先以上限值1000，999，998作为样例。 1000的左侧可以放自身一半以下的数，就是500,499一直到1；f（1000） 999的左侧也是，不过不能放500，只能499到1；f（999） 998的左侧就是499到1，和999相同；f（998）。 综上所述，f（1000）= f（999）+f （500），f（999）= f（998），推广可以找到规律： 当n为偶数时：f（n）= f（n-1） + f（n/2）； 当n为奇数时：f（n）= f（n-1） 所以直接初始化f（0），f（1），之后计算即可。代码1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123; int n, f[1024]; cin&gt;&gt;n; f[0] = 1; f[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; if(i%2==0) f[i] = f[i/2]+f[i-1]; else f[i] = f[i-1]; &#125; cout&lt;&lt;f[n]; return 0;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 217. Contains Duplicate]]></title>
    <url>%2FLeetCode%20217.%20Contains%20Duplicate.html</url>
    <content type="text"><![CDATA[217.Contains Duplicate(存在重复元素)链接 https://leetcode-cn.com/problems/contains-duplicate/ 题目给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1]输出: true示例 2: 输入: [1,2,3,4]输出: false示例 3: 输入: [1,1,1,3,3,4,3,2,4,2]输出: true 思路就是想办法找到重复的数，建议用偷懒的方法减少复杂度。 1.set数据结构，直接把数组中的数装进去，查看两者长度差，得到结果。 2.快排，然后遍历比较前后两个数是否相同，得到结果。 代码1234567891011 public static boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; ans = new HashSet&lt;Integer&gt;(); for (int i : nums) &#123; ans.add(i); &#125; if (ans.size() == nums.length) &#123; return false; &#125; else &#123; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 414. Third Maximum Number]]></title>
    <url>%2FLeetCode%20414.%20Third%20Maximum%20Number.html</url>
    <content type="text"><![CDATA[414.Third Maximum Number （第三大的数）链接https://leetcode-cn.com/problems/third-maximum-number/ 题目给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1: 输入: [3, 2, 1] 输出: 1 解释: 第三大的数是 1.示例 2: 输入: [1, 2] 输出: 2 解释: 第三大的数不存在, 所以返回最大的数 2 .示例 3: 输入: [2, 2, 3, 1] 输出: 1 解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 思路简单题目挖了坑，不能直接用排序函数运算，O（n）就只能遍历一遍，所以设置one，two，three表示第一大第二大第三大三个数，遍历比较即可。这里还有两个坑，第一个是存在相同数字的可能性，这个在开始时比较一下就行了。另外一个是，输入里面有-2147483648，需要考虑一下，加一个flag表示即可。遍历完成，如果数组中不相同的数大于等于3个，那么输出three，不然输出one。 代码1234567891011121314151617181920212223242526272829303132333435363738public static int thirdMax(int[] nums) &#123; if (nums.length == 1) &#123; return nums[0]; &#125; else if (nums.length == 2) &#123; return Math.max(nums[0], nums[1]); &#125; int one = Integer.MIN_VALUE; int two = Integer.MIN_VALUE; int three = Integer.MIN_VALUE; int tnum = 0; boolean flag = true; for (int i = 0; i &lt; nums.length; i++) &#123; if (flag &amp;&amp; nums[i] == Integer.MIN_VALUE) &#123; tnum++; flag = false; &#125; if (one == nums[i] || two == nums[i] || three == nums[i]) &#123; continue; &#125; tnum++; if (nums[i] &gt; one) &#123; three = two; two = one; one = nums[i]; &#125; else if (nums[i] &gt; two) &#123; three = two; two = nums[i]; &#125; else if (nums[i] &gt; three) &#123; three = nums[i]; &#125; &#125; if (tnum &gt;= 3) &#123; return three; &#125; else &#123; return one; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1540 机器翻译]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%20P1540%20%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91.html</url>
    <content type="text"><![CDATA[洛谷 P1540 机器翻译链接https://www.luogu.org/problemnew/show/p1540 题目题目背景小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。 题目描述这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。 假设内存中有M个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过M-，软件会将新单词存入一个未使用的内存单元；若内存中已存入MM个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。 假设一篇英语文章的长度为N个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。 输入输出格式输入格式： 共2行。每行中两个数之间用一个空格隔开。 第一行为两个正整数M,N代表内存容量和文章的长度。 第二行为N个非负整数，按照文章的顺序，每个数（大小不超过1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。 输出格式： 一个整数，为软件需要查词典的次数。 输入输出样例输入样例#1： 3 7 1 2 1 5 4 4 1输出样例#1： 5 思路新建数组a存放输入，ans存放答案，队列q模拟内存和，book记录是否存在。如果单词1在内存中，就将book[1]置为true，移除内存就置为false，每次内存变化ans++，不然直接continue。 水题，用队列可以减少消耗，不过用book存放结果这个思路是别人启发的，比我之前想的查找有效率多了。 （学校开的关于ccf的活动（有空会做），就再开一个洛谷的题解，这部分主要用c++，LeetCode的还是继续用java，也会慢慢更新。暑假要开始996，不过我是不会鸽的） 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int M,N;int a[1005],ans;bool book[1005];queue&lt;int&gt; q;int main()&#123; cin&gt;&gt;M&gt;&gt;N; ans=0; for(int i=0;i&lt;N;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;N;i++) &#123; if(book[a[i]]) continue; else &#123; if(q.size()&lt;M) &#123; q.push(a[i]); ans++; book[a[i]]=true; &#125; else &#123; ans++; book[a[i]]=true; book[q.front()]=false; q.push(a[i]); q.pop(); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 151. Reverse Words in a String]]></title>
    <url>%2FLeetCode%20151.%20Reverse%20Words%20in%20a%20String.html</url>
    <content type="text"><![CDATA[151.Reverse Words in a String（翻转字符串里的单词）链接https://leetcode-cn.com/problems/reverse-words-in-a-string/ 题目给定一个字符串，逐个翻转字符串中的每个单词。 示例 1： 输入: “the sky is blue”输出: “blue is sky the”示例 2： 输入: “ hello world! “输出: “world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。示例 3： 输入: “a good example”输出: “example good a”解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 思路用已有的函数split（” “）去除空格，之后将单词加入新的字符串中，再用trim（）去除首尾空格，成了。 （期末考试基本结束，更新应该有点保障了，估计会更一些深入的东西，尽量不鸽） 代码1234567891011public static String reverseWords(String s) &#123; String[] splitStr = s.split(&quot; &quot;); StringBuffer result = new StringBuffer(&quot;&quot;); for (int i = (splitStr.length - 1); i &gt;= 0; i--) &#123; if (!splitStr[i].equals(&quot;&quot;)) &#123; result.append(splitStr[i]); result.append(&quot; &quot;); &#125; &#125; return result.toString().trim();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 997. Find the Town Judge]]></title>
    <url>%2FLeetCode%20997.%20Find%20the%20Town%20Judge.html</url>
    <content type="text"><![CDATA[997.Find the Town Judge（找到小镇的法官）链接https://leetcode-cn.com/problems/find-the-town-judge/ 题目在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。 如果小镇的法官真的存在，那么： 小镇的法官不相信任何人。 每个人（除了小镇法官外）都信任小镇的法官。 只有一个人同时满足属性 1 和属性 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。 示例 1： 输入：N = 2, trust = [[1,2]] 输出：2示例 2： 输入：N = 3, trust = [[1,3],[2,3]] 输出：3示例 3： 输入：N = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1示例 4： 输入：N = 3, trust = [[1,2],[2,3]] 输出：-1示例 5： 输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] 输出：3提示： 1 &lt;= N &lt;= 1000 trust.length &lt;= 10000 trust[i] 是完全不同的 trust[i][0] != trust[i][1] 1 &lt;= trust[i][0], trust[i][1] &lt;= N 思路这题我觉得挺好的，问题新奇（或许吧），解法有趣（还行）。 这题应该新建一个二维数组，第一维表示小镇的人（从1到N），第二维只需要两个，第一个是相信他人的数量，第二个是被他人相信的数量。法官的要求是不相信任何人，且被其他所有人相信，那就是第二维中第一个为0，第二个为N-1，先统计数组，再遍历即可。 （最近快期末了，更新不稳定，估计到21号恢复正常） 代码123456789101112131415public int findJudge(int N, int[][] trust) &#123; int[][] people = new int[N][2]; for (int i = 0; i &lt; trust.length; i++) &#123; int out = trust[i][0]; int in = trust[i][1]; people[out - 1][0]++; people[in - 1][1]++; &#125; for (int i = 0; i &lt; N; i++) &#123; if (people[i][0] == 0 &amp;&amp; people[i][1] == N - 1) &#123; return i + 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 977. Squares of a Sorted Array]]></title>
    <url>%2FLeetCode%20977.%20Squares%20of%20a%20Sorted%20Array.html</url>
    <content type="text"><![CDATA[977.Squares of a Sorted Array（有序数组的平方）链接https://leetcode-cn.com/problems/squares-of-a-sorted-array/ 题目给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100]示例 2： 输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121]提示： 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 思路非递减顺序，再加上存在负数，可以通过在两端比较：先取head和tail表示两端的位置，比较两个数的平方，平方较大者，放到新数组的靠后位置。 （真要偷懒可以直接用sort，但是这样就没啥意义了） 代码1234567891011121314151617181920public int[] sortedSquares(int[] A) &#123; int len = A.length; int head = 0; int tail = len - 1; int[] B = new int[len]; while (head &lt;= tail) &#123; len--; int i = A[head] * A[head]; int j = A[tail] * A[tail]; if (i &gt; j) &#123; B[len] = i; head++; &#125; else &#123; B[len] = j; tail--; &#125; &#125; // B = B.reverse return B;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 559. Maximum Depth of N-ary Tree]]></title>
    <url>%2FLeetCode%20559.%20Maximum%20Depth%20of%20N-ary%20Tree.html</url>
    <content type="text"><![CDATA[559.Maximum Depth of N-ary Tree（N叉树的最大深度）链接https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/ 题目给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 例如，给定一个 3叉树 : 我们应返回其最大深度，3。 说明: 树的深度不会超过 1000。 树的节点总不会超过 5000。 思路这题只需要遍历即可，如果结点为null，高度不变，结点存在子节点，进入子节点遍历，借助max函数比较得到最大值即可。 代码1234567891011121314151617181920212223242526class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123; &#125; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;public int maxDepth(Node root) &#123; if (root == null) &#123; return 0; &#125; int max = 0; for (Node n : root.children) &#123; max = Math.max(max, maxDepth(n)); &#125; return max + 1;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 836. Rectangle Overlap]]></title>
    <url>%2FLeetCode%20836.%20Rectangle%20Overlap.html</url>
    <content type="text"><![CDATA[836.Rectangle Overlap（矩阵重叠）链接https://leetcode-cn.com/problems/rectangle-overlap/ 题目矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1： 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3] 输出：true示例 2： 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1] 输出：false说明： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。 矩形中的所有坐标都处于 -10^9 和 10^9 之间。 思路以矩阵一为基准，判断矩阵二是否在其中。如果判断有重叠部分的话，需要判断8中条件，所以改为判断无重叠。 rec2[0] &gt;= rec1[2] （代表矩阵二在矩阵一右侧） rec1[0] &gt;= rec2[2] （代表矩阵二在矩阵一左侧） rec2[1] &gt;= rec1[3] （代表矩阵二在矩阵一上方） rec1[1] &gt;= rec2[3]（代表矩阵二在矩阵一下方）这四个条件只要有一个满足就代表二者不重叠。 代码12345678public boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123; if (rec2[0] &gt;= rec1[2] || rec1[0] &gt;= rec2[2] || rec2[1] &gt;= rec1[3] || rec1[1] &gt;= rec2[3]) &#123; return false; &#125; else &#123; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 709. To Lower Case]]></title>
    <url>%2FLeetCode%20709.%20To%20Lower%20Case.html</url>
    <content type="text"><![CDATA[709.To Lower Case（转换为小写字母）链接https://leetcode-cn.com/problems/to-lower-case/ 题目实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。 示例 1： 输入: &quot;Hello&quot; 输出: &quot;hello&quot;示例 2： 输入: &quot;here&quot; 输出: &quot;here&quot;示例 3： 输入: &quot;LOVELY&quot; 输出: &quot;lovely&quot;思路这题怎么说呢，直接判断，大写字母转换即可，但是已经有了轮子了，直接调用函数就行。（函数被我注释了） 代码12345678910111213public static String toLowerCase(String str) &#123; char[] c = str.toCharArray(); String s = &quot;&quot;; for (int i = 0; i &lt; str.length(); i++) &#123; if (c[i] &gt;= 65 &amp;&amp; c[i] &lt;= 90) &#123; s = s + (char) (c[i] + 32); &#125; else &#123; s = s + (char) c[i]; &#125; &#125; return s; // return str.toLowerCase();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 728. Self Dividing Numbers]]></title>
    <url>%2FLeetCode%20728.%20Self%20Dividing%20Numbers.html</url>
    <content type="text"><![CDATA[728.Self Dividing Numbers（自除数）链接https://leetcode-cn.com/problems/self-dividing-numbers/ 题目_自除数 _是指可以被它包含的每一位数除尽的数。 例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。 还有，自除数不允许包含 0 。 给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。 示例 1： 输入： 上边界left = 1, 下边界right = 22 输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]注意： 每个输入参数的边界满足 1 &lt;= left &lt;= right &lt;= 10000。 思路思路一样很清晰，建立一个List存放答案，在边界值中判断是否满足条件。 新建函数用于判断，函数中要给一个新变量用于进行除法，如果存在0即为false，不能整除也为false。 代码123456789101112131415161718192021public static List&lt;Integer&gt; selfDividingNumbers(int left, int right) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for (int i = left; i &lt;= right; i++) &#123; if (isSelf(i)) &#123; result.add(i); &#125; &#125; return result;&#125;public static boolean isSelf(int number) &#123; int num = number; while (num != 0) &#123; int n = num % 10; num = num / 10; if (n == 0 || number % n != 0) &#123; return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 551. Student Attendance Record I]]></title>
    <url>%2FLeetCode%20551.%20Student%20Attendance%20Record%20I.html</url>
    <content type="text"><![CDATA[551.Student Attendance Record I(学生出勤记录 I)链接题目给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： ‘A’ : Absent，缺勤 ‘L’ : Late，迟到 ‘P’ : Present，到场 如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。 你需要根据这个学生的出勤记录判断他是否会被奖赏。 示例 1: 输入: &quot;PPALLP&quot; 输出: True示例 2: 输入: &quot;PPALLL&quot; 输出: False思路这题思路清晰，只要判断两个条件，缺勤次数少于2，连续迟到次数少于3，可以通过遍历来记录缺勤次数，迟到次数就通过contains函数来统计，LLL就代表连续迟到三次。 代码123456789101112131415public static boolean checkRecord(String s) &#123; int num = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;A&apos;) &#123; num++; &#125; if (num &gt;= 2) &#123; return false; &#125; &#125; if (s.contains(&quot;LLL&quot;)) &#123; return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 258. Add Digits]]></title>
    <url>%2FLeetCode%20258.%20Add%20Digits.html</url>
    <content type="text"><![CDATA[258.Add Digits（各位相加）链接https://leetcode-cn.com/problems/add-digits/ 题目给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 输入: 38 输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。进阶:你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 思路。。。不让用循环和递归，那就只能找规律了。 假设原数为 100a + 10b +c，相加后是 a + b +c ，二者差值为 99a + 9b，可以被9整除，行了，每次减少的都是9的倍数，直接 %9即可，剩的数就是个位数。 代码1234567891011public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int number = target - nums[i]; if (map.containsKey(number)) &#123; return new int[]&#123;map.get(number), i&#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 122. Best Time to Buy and Sell Stock II]]></title>
    <url>%2FLeetCode%20122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II.html</url>
    <content type="text"><![CDATA[122.Best Time to Buy and Sell Stock II（买卖股票的最佳时机 II）链接https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 题目给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。思路也是采用动态规划方式，如果当前天的价格大于之前的最小值，那么就在这天出售，利润增加这天价格和最小值的差，最小值重置为当前天。如果当前天的价格小于最小值，那么最小值置为当前天价格。如果连续增长，例如价格为1,2,3.那么思路就是：利润= （2 - 1） + （3 - 2） = 2. （话说我这个耗时有点长，有缘再优化吧） 代码12345678910public static int addDigits(int num) &#123; if (num &gt; 9) &#123; num = num % 9; if (num == 0) &#123; return 9; &#125; &#125; return num;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 121. Best Time to Buy and Sell Stock]]></title>
    <url>%2FLeetCode%20121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock.html</url>
    <content type="text"><![CDATA[121.Best Time to Buy and Sell Stock（买卖股票的最佳时机）链接https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 题目给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。思路老朋友了，动态规划，直接找出状态转移方程： 第 n 天的最大利润 = max（前 n-1 天的最大利润，第 n 天的价格 - 前 n-1 天的最小价格） 第 n 天的最小价格 = min （前 n-1 天的最小价格，第 n 天的价格） 然后遍历到最后一天就行了。 （话说这题有1234四个型号，这段时间我来把都写完） 代码1234567891011public static int maxProfit(int[] prices) &#123; if (prices.length &lt;= 1) &#123; return 0; &#125; int min = prices[0], max = 0; for (int i = 1; i &lt; prices.length; i++) &#123; max = Math.max(max, prices[i] - min); min = Math.min(min, prices[i]); &#125; return max; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 389. Find the Difference]]></title>
    <url>%2FLeetCode%20389.%20Find%20the%20Difference.html</url>
    <content type="text"><![CDATA[389.Find the Difference（找不同）链接https://leetcode-cn.com/problems/find-the-difference/ 题目给定两个字符串 s 和 t ，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例: 输入： s = &quot;abcd&quot; t = &quot;abcde&quot; 输出： e 解释： &apos;e&apos; 是那个被添加的字母。思路这题的方法挺多的，可以排序之后遍历查找，也可以哈希存储之后找到数值不同的存储位，最后还是选了统计字符串的int值的和，二者的差就是多的那个字母的int值，再次转换就行了。（此思路来自评论，真是大佬思路） 代码123456789101112131415public static char findTheDifference(String s, String t) &#123; char ch1[] = s.toCharArray(); char ch2[] = t.toCharArray(); int sum = 0; for (int i = 0; i &lt; ch1.length; i++) &#123; sum = sum + (int) ch1[i]; &#125; for (int i = 0; i &lt; ch2.length; i++) &#123; sum = sum - (int) ch2[i]; &#125; sum = Math.abs(sum); char c = (char) sum; return c;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 899. Orderly Queue]]></title>
    <url>%2FLeetCode%20899.%20Orderly%20Queue.html</url>
    <content type="text"><![CDATA[899.Orderly Queue(有序队列)链接https://leetcode-cn.com/problems/orderly-queue/ 题目给出了一个由小写字母组成的字符串 S。然后，我们可以进行任意次数的 移动 。 在每次移动中，我们选择前 K 个字母中的一个（从左侧开始），将其从原位置移除，并放置在字符串的末尾。 返回我们在任意次数的移动之后可以拥有的按字典顺序排列的最小字符串。 示例 1： 输入：S = &quot;cba&quot;, K = 1 输出：&quot;acb&quot; 解释： 在第一步中，我们将第一个字符（&quot;c&quot;）移动到最后，获得字符串 &quot;bac&quot;。 在第二步中，我们将第一个字符（&quot;b&quot;）移动到最后，获得最终结果 &quot;acb&quot;。示例 2： 输入：S = &quot;baaca&quot;, K = 3 输出：&quot;aaabc&quot; 解释： 在第一步中，我们将第一个字符（&quot;b&quot;）移动到最后，获得字符串 &quot;aacab&quot;。 在第二步中，我们将第三个字符（&quot;c&quot;）移动到最后，获得最终结果 &quot;aaabc&quot;。提示： 1 &lt;= K &lt;= S.length &lt;= 1000` S 只由小写字母组成。 思路这题的设定其实有点迷，当K==1时，就代表前后次序（相对位置）并没有改变，只是在开头的可以移到后端。当K！=1时，就代表可以随意组合，直接计算字典最小的序列即可。 直接分类讨论，=1时，新建S=S+S，从前往后取len位比较即可；！=1时，拆为数组，排序，组合即可。 代码12345678910111213141516171819202122public static String orderlyQueue(String S, int K) &#123; int len = S.length(); if (K == 1) &#123; String word = S; S = S + S; for (int i = 0; i &lt; len; i++) &#123; if (word.compareTo(S.substring(i, i + len)) &gt; 0) &#123; word = S.substring(i, i + len); &#125; &#125; return word; &#125; else &#123; char[] word = S.toCharArray(); Arrays.sort(word); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; S.length(); i++) &#123; sb.append(word[i]); &#125; return sb.toString(); &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 9. Palindrome Number]]></title>
    <url>%2FLeetCode%209.%20Palindrome%20Number.html</url>
    <content type="text"><![CDATA[9.Palindrome Number（回文数）链接：https://leetcode-cn.com/problems/palindrome-number/ 题目判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶: 你能不将整数转为字符串来解决这个问题吗？ 思路正常方法就是对于数进行判断，第一个和最后一个对比，一直对比到中间一个或两个，这种方法采用整数转字符串效率较高。 考虑到进阶，使用转置方法较好，但是这个可能会越界超出int的范围（我真没想到），所以参考了一波别人的思路，只转置一半的数字，就不会越界了（真是个小机灵鬼）。并且数字如果为负数，不会是回文，如果个位是0并且数不为0，也不会回文。并且最后判断的时候，考虑到了奇偶数位，减少了一步判断操作。 代码12345678910111213public static boolean isPalindrome(int x) &#123; if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int num = 0; while (x &gt; num) &#123; num = num * 10 + x % 10; x = x / 10; &#125; return x == num || x == num / 10;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 63. Unique Paths II]]></title>
    <url>%2FLeetCode%2063.%20Unique%20Paths%20II.html</url>
    <content type="text"><![CDATA[63.Unique Paths II（不同路径 II）链接https://leetcode-cn.com/problems/unique-paths-ii/ 题目一个机器人位于一个 _m x n _网格的左上角 （起始点在下图中标记为”Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记 为”Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明： m 和 _n _的值均不超过 100。 示例 1: 输入: [ [0,0,0], [0,1,0], [0,0,0] ] 输出: 2 解释: 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右思路这题和上一题相似，区别在于存在阻碍无法通过，所以不能直接求公式，那么就采用dp算法，建立一个相同大小的数组，存放到达当前格子的路径数量。如果当前格子存在阻碍，那么就始终无法到达，设置为0，如果在第一行或者第一列，如果之前无阻碍就为1（只能通过直线到达），有阻碍就为0。中间的格子也是，有阻碍就为0，没阻碍就是上方格子和左侧格子的和，最后一个格子就是所需的路径数目。 本来我是把第一行第一列提出来先进行运算的，但是这样有点浪费时间，就把这些都放在一起了，好像快了一点点。 代码12345678910111213141516171819202122public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (obstacleGrid[i][j] == 1) &#123; dp[i][j] = 0; &#125; else if (i == 0 &amp;&amp; j == 0) &#123; dp[i][j] = 1; &#125; else if (i == 0 &amp;&amp; j != 0) &#123; dp[i][j] = dp[i][j - 1]; &#125; else if (j == 0 &amp;&amp; i != 0) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[m - 1][n - 1]; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 62. Unique Paths]]></title>
    <url>%2FLeetCode%2062.%20Unique%20Paths.html</url>
    <content type="text"><![CDATA[62.Unique Paths（不同路径）链接https://leetcode-cn.com/problems/unique-paths/ 题目一个机器人位于一个 _m x n _网格的左上角 （起始点在下图中标记为”Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为”Finish”）。 问总共有多少条不同的路径？ 说明： m 和 _n _的值均不超过 100。 示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向右 -&gt; 向下 2. 向右 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向右思路：这题本来想偷个懒，直接计算排列组合公式的，一共要向右走n-1步，向下走m-1步，这就是一个简单的组合问题，m+n-2中任选m-1步向下，计算C（m+n-2,m-1）。但是。。。我发现这样会超出范围，所以还是用了别的方法，数组填数。 到达每个格子有两条路径，从上面下来，从左边过来，如果有x条路径可以到达上方格子，y条路径到达左侧格子，到达这个格子就有x+y条路径，直接循环，最后一个格子的数就是路径数。 C（m+n-2,m-1）直接计算会超时，所以可以考虑到优化算法（日后补上。。。咕咕咕）。 代码：12345678910111213public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[m - 1][n - 1];&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 695. Max Area of Island]]></title>
    <url>%2FLeetCode%20695.%20Max%20Area%20of%20Island.html</url>
    <content type="text"><![CDATA[695.Max Area of Island（岛屿的最大面积）链接https://leetcode-cn.com/problems/max-area-of-island/ 题目给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地)构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的’1’。 示例 2: [[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 思路一看到这道题，我的第一个想法是遍历，全部跑一遍就行，之后考虑到效率问题，选择了使用dfs来进行查找，从第一个格子开始，如果是0那么就换下一个格子，是1就对那个格子进行深度优先搜索，搜索格子上下左右，如果是1就继续搜索，直到跑完全图。 （最近事有点多，等有空了打算建个算法合集方便学习，比如前段时间的动态规划） 代码12345678910111213141516171819202122232425262728public int maxAreaOfIsland(int[][] grid) &#123; int i = 0, j = 0; int m = grid.length; int n = grid[0].length; int area = 0, max = 0; for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; area = dfs(i, j, m, n, grid, 0); max = Math.max(area, max); &#125; &#125; &#125; return max; &#125; private int dfs(int i, int j, int m, int n, int[][] grid, int c_area) &#123; if (grid[i][j] == 0 || i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n) &#123; return c_area; &#125; grid[i][j] = 0; c_area = c_area + 1; c_area = dfs(i + 1, j, m, n, grid, c_area); c_area = dfs(i - 1, j, m, n, grid, c_area); c_area = dfs(i, j + 1, m, n, grid, c_area); c_area = dfs(i, j - 1, m, n, grid, c_area); return c_area; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 125. Valid Palindrome]]></title>
    <url>%2FLeetCode%20125.%20Valid%20Palindrome.html</url>
    <content type="text"><![CDATA[125.Valid Palindrome（验证回文串）链接https://leetcode-cn.com/problems/valid-palindrome/ 题目给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: &quot;A man, a plan, a canal: Panama&quot; 输出: true示例 2: 输入: &quot;race a car&quot; 输出: false思路简单的回文串判断，建立新的StringBuilder用于存放字符串中的字母和数字，之后直接借助reverse（）函数来进行转置，判断是否相同，这里需要用equals（），==判断字符串经常出问题。 代码：1234567891011121314public boolean isPalindrome(String s) &#123; if (s == null) &#123; return true; &#125; s = s.toLowerCase(); char[] word = s.toCharArray(); StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; word.length; i++) &#123; if ((word[i] &gt;= &apos;0&apos; &amp;&amp; word[i] &lt;= &apos;9&apos;) || (word[i] &gt;= &apos;a&apos; &amp;&amp; word[i] &lt;= &apos;z&apos;)) &#123; str.append(word[i]); &#125; &#125; return str.toString().equals(str.reverse().toString()); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 112. Path Sum]]></title>
    <url>%2FLeetCode%20112.%20Path%20Sum.html</url>
    <content type="text"><![CDATA[112.Path Sum（路径组合）链接https://leetcode-cn.com/problems/path-sum/ 题目给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 思路简单的二叉树遍历问题，直接从根节点开始，遍历方式可以自选，递归计算，每次都把所需和减去当前节点值。 代码12345678910111213141516171819202122 public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) &#123; return false; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return sum == root.val; &#125; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 866. Prime Palindrome]]></title>
    <url>%2FLeetCode%20866.%20Prime%20Palindrome.html</url>
    <content type="text"><![CDATA[866.Prime Palindrome(回文素数)链接https://leetcode-cn.com/problems/prime-palindrome/ 题目求出大于或等于 N 的最小回文素数。 回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是 素数 。 例如，2，3，5，7，11 以及 13 是素数。 回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是 回文数。 例如，12321 是回文数。 思路思路还是挺清晰的，从给入数字向上检索，如果既是回文数，又是素数，就直接输出，如果不满足条件，那么就增加数字，继续判断。 这里有一个小问题，就是所有偶数位的回文数，都可以被11整除，至于证明。。。。。咱也不知道，咱也不敢问，所有如果发现这个数是偶数位，那么直接进一位，首数字和尾数字全为1，继续判断。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static int primePalindrome(int N) &#123; if (N &lt;= 2) &#123; return 2; &#125; else if (N &lt;= 3) &#123; return 3; &#125; else if (N &lt;= 5) &#123; return 5; &#125; else if (N &lt;= 7) &#123; return 7; &#125; else if (N &lt;= 11) &#123; return 11; &#125; for (int i = N; ; ) &#123; if (isHui(i) &amp;&amp; isPrime(i)) &#123; return i; &#125; if ((i + &quot;&quot;).length() % 2 == 0) &#123; i = (int) (Math.pow(10, (i + &quot;&quot;).length()) + 1); &#125; else &#123; i++; &#125; &#125;&#125;public static boolean isPrime(int i) &#123; for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; return false; &#125; &#125; return true;&#125;public static boolean isHui(int s) &#123; String str = s + &quot;&quot;; int len = str.length(); for (int j = 0; j &lt; len / 2; j++) &#123; if (str.charAt(j) != str.charAt(len - j - 1)) &#123; return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 51.N-Queens]]></title>
    <url>%2FLeetCode%2051.N-Queens.html</url>
    <content type="text"><![CDATA[51.N-Queens(N皇后)链接https://leetcode-cn.com/problems/n-queens/ 题目n _皇后问题研究的是如何将 _n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给定一个整数 n ，返回所有不同的 _n _皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例: 输入: 4 输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;] ] 解释: 4 皇后问题存在两个不同的解法。思路这题的思路和之前的N皇后II一样，都是运用回溯法，只是输出较难设置，还有一个重点，是其中存放答案的res，需要在每次计算前clear一下，要不然就无法ac。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private static boolean col[];private static boolean line1[];private static boolean line2[];private static int answer[];private static List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;();public static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; col = new boolean[n]; line1 = new boolean[2 * n - 1]; line2 = new boolean[2 * n - 1]; answer = new int[n]; res.clear(); putQueen(n, 0); return res;&#125;private static void putQueen(int n, int index) &#123; if (index == n) &#123; List&lt;String&gt; item = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; answer.length; i++) &#123; StringBuilder sb = new StringBuilder(); for (int j = 0; j &lt; answer.length; j++) &#123; if (answer[i] != j) &#123; sb.append(&apos;.&apos;); &#125; else &#123; sb.append(&apos;Q&apos;); &#125; &#125; item.add(sb.toString()); &#125; res.add(item); &#125; for (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !line1[i - index + n - 1] &amp;&amp; !line2[i + index]) &#123; answer[index] = i; col[i] = true; line1[i - index + n - 1] = true; line2[i + index] = true; col[i] = false; line1[i - index + n - 1] = false; line2[i + index] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 52.N-Queens II]]></title>
    <url>%2FLeetCode%2052.N-Queens%20II.html</url>
    <content type="text"><![CDATA[52.N-Queens II（N 皇后 II）链接：https://leetcode-cn.com/problems/n-queens-ii/ 题目n _皇后问题研究的是如何将 _n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给定一个整数 n ，返回 n 皇后不同的解决方案的数量。 示例: 输入: 4 输出: 2 解释: 4 皇后问题存在如下两个不同的解法。 [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;] ]思路这题思路较清晰，先在第一行第一列放置皇后，之后第二行寻找可以放皇后的地方，一行一行放置，如果哪一行不能放置，那么就回溯到上一行，如果放置到了最后一行，那么就代表这种情况成立，计数加一，返回之前一步。 图解从左上角开始，line1是正对角线，line2是斜对角线，col是竖列。 代码1234567891011121314151617181920212223242526272829303132333435363738//列private static boolean col[];//正对角线 x-y+n-1private static boolean line1[];//斜对角线 x+yprivate static boolean line2[];public static int totalNQueens(int n) &#123; col = new boolean[n]; line1 = new boolean[2 * n - 1]; line2 = new boolean[2 * n - 1]; return putQueen(n, 0);&#125;private static int putQueen(int n, int index) &#123; int flag = 0; if (index == n) &#123; return 1; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !line1[i - index + n - 1] &amp;&amp; !line2[i + index]) &#123; col[i] = true; line1[i - index + n - 1] = true; line2[i + index] = true; flag = flag + putQueen(n, index + 1); col[i] = false; line1[i - index + n - 1] = false; line2[i + index] = false; &#125; &#125; return flag;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 804. Unique Morse Code Words]]></title>
    <url>%2FLeetCode%20804.%20Unique%20Morse%20Code%20Words.html</url>
    <content type="text"><![CDATA[804.Unique Morse Code Words(唯一摩尔斯密码词)链接https://leetcode-cn.com/problems/unique-morse-code-words/ 题目国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: &quot;a&quot; 对应 &quot;.-&quot;, &quot;b&quot;对应&quot;-...&quot;, &quot;c&quot; 对应 &quot;-.-.&quot;, 等等。 为了方便，所有26个英文字母对应摩尔斯密码表如下： [&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..–…”，(即 “-.-.” + “-…” “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。 返回我们可以获得所有词不同单词翻译的数量。 例如: 输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;] 输出: 2 解释: 各单词翻译如下: &quot;gin&quot; -&gt; &quot;--...-.&quot; &quot;zen&quot; -&gt; &quot;--...-.&quot; &quot;gig&quot; -&gt; &quot;--...--.&quot; &quot;msg&quot; -&gt; &quot;--...--.&quot; 共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.注意: 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 思路这道题的思路比较清晰，对于每一个word，将之转换为摩斯电码，使用hashset存储，最后统计这个散列表里面的值即可。 代码123456789101112131415public static int uniqueMorseRepresentations(String[] words) &#123; String[] codes = &#123;&quot;.-&quot;, &quot;-...&quot;, &quot;-.-.&quot;, &quot;-..&quot;, &quot;.&quot;, &quot;..-.&quot;, &quot;--.&quot;, &quot;....&quot;, &quot;..&quot;, &quot;.---&quot;, &quot;-.-&quot;, &quot;.-..&quot;, &quot;--&quot;, &quot;-.&quot;, &quot;---&quot;, &quot;.--.&quot;, &quot;--.-&quot;, &quot;.-.&quot;, &quot;...&quot;, &quot;-&quot;, &quot;..-&quot;, &quot;...-&quot;, &quot;.--&quot;, &quot;-..-&quot;, &quot;-.--&quot;, &quot;--..&quot;&#125;; HashSet&lt;String&gt; hashset = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; String word = words[i]; StringBuilder sc = new StringBuilder(&quot;&quot;); for (int j = 0; j &lt; word.length(); j++) &#123; sc.append(codes[word.charAt(j) - 97]); &#125; hashset.add(sc.toString()); &#125; return hashset.size();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 712. Minimum ASCII Delete Sum for Two Strings]]></title>
    <url>%2FLeetCode%20712.%20Minimum%20ASCII%20Delete%20Sum%20for%20Two%20Strings.html</url>
    <content type="text"><![CDATA[712.Minimum ASCII Delete Sum for Two Strings（两个字符串的最小ASCII删除和） 链接https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/ 题目给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。 示例 1: 输入: s1 = &quot;sea&quot;, s2 = &quot;eat&quot; 输出: 231 解释: 在 &quot;sea&quot; 中删除 &quot;s&quot; 并将 &quot;s&quot; 的值(115)加入总和。 在 &quot;eat&quot; 中删除 &quot;t&quot; 并将 116 加入总和。 结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。注意: 0 &lt; s1.length, s2.length &lt;= 1000。所有字符串中的字符ASCII值在[97, 122]之间。 思路与前段时间的最小编辑距离相似，这题一看就觉得应该用动态规划，缺什么就定义什么，这边需求最小和，那么就设定数组step[][]，和sc1[]，sc2[]。后两个是输入字符串转换而来，减少运算时间。step[i][j]数组是用于存放s1中前i 个字母和s2中前 j 个字母的最小删除和 。 首先进行初始化，原点的值为0，之后行列就是将前n为清空所需的最小删除和，之后进行二维计算。 此时对于s1中的第 i+1 个字母，和s2中的第 j+1 个字母，进行判断： 如果二者相同，则无需变化，直接 step[ i+1 ][ j+1 ] = step[ i ][ j ] ； 二者不同，就要考虑是删除s1的新字母还是删除s2的新字母，当然，还有两种都删除， 即为 step[ i+1 ][ j+1 ] = Min(num1，num2，num3); 最后得到的step[ i ][ j ]就是最小删除和。 图解红色加大部分是e，相同，即为左上格子的值；黑色加大是不同的，三选一，找到最小值。 代码1234567891011121314151617181920212223242526272829303132public static int minimumDeleteSum(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); char[] sc1 = s1.toCharArray(); char[] sc2 = s2.toCharArray(); int[][] step = new int[len1 + 1][len2 + 1]; step[0][0] = 0; for (int i = 1; i &lt;= len1; i++) &#123; step[i][0] = step[i - 1][0] + sc1[i - 1]; &#125; for (int j = 1; j &lt;= len2; j++) &#123; step[0][j] = step[0][j - 1] + sc2[j - 1]; &#125; for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; if (sc1[i - 1] == sc2[j - 1]) &#123; step[i][j] = step[i - 1][j - 1]; &#125; else &#123; step[i][j] = Math.min(Math.min(step[i - 1][j] + sc1[i - 1], step[i][j - 1] + sc2[j - 1]), step[i - 1][j - 1] + sc1[i - 1] + sc2[j - 1]); &#125; &#125; &#125; return step[len1][len2];&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1021. Remove Outermost Parentheses]]></title>
    <url>%2FLeetCode%201021.%20Remove%20Outermost%20Parentheses.html</url>
    <content type="text"><![CDATA[1021.Remove Outermost Parentheses（删除最外层的括号）链接https://leetcode-cn.com/problems/remove-outermost-parentheses/ 题目有效括号字符串为空 (&quot;&quot;)、&quot;(&quot; + A + &quot;)&quot; 或 A + B，其中 A 和 B 都是有效的括号字符串，+代表字符串的连接。例如，&quot;&quot;，&quot;()&quot;，&quot;(())()&quot; 和 &quot;(()(()))&quot; 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例 1： 输入：&quot;(()())(())&quot; 输出：&quot;()()()&quot; 解释： 输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;， 删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;。示例 2： 输入：&quot;(()())(())(()(()))&quot; 输出：&quot;()()()()(())&quot; 解释： 输入字符串为 &quot;(()())(())(()(()))&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;， 删除每隔部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;。示例 3： 输入：&quot;()()&quot; 输出：&quot;&quot; 解释： 输入字符串为 &quot;()()&quot;，原语化分解得到 &quot;()&quot; + &quot;()&quot;， 删除每个部分中的最外层括号后得到 &quot;&quot; + &quot;&quot; = &quot;&quot;。提示： S.length &lt;= 10000 S[i] 为 &quot;(&quot; 或 &quot;)&quot; S 是一个有效括号字符串 思路这个题目以前做过的，设定一个flag位为0，对于字符串进行遍历，遇到左括号flag增加，遇到右括号flag减少，当flag重新为0即代表括号到达最外层，满足消去条件，直到检索完字符串。 （这题我本来使用的是s.charAt（），之后发现性能较差，于是改变使用StringBuilder，用字符数组解决） 代码1234567891011121314151617181920public static String removeOuterParentheses(String S) &#123; StringBuilder password = new StringBuilder(); char[] word = S.toCharArray(); int val = 0; for (int i = 0; i &lt; word.length; i++) &#123; if (word[i] == &apos;(&apos;) &#123; val++; if (val != 1) &#123; password.append(word[i]); &#125; &#125; else &#123; val--; if (val != 0) &#123; password.append(word[i]); &#125; &#125; &#125; return password.toString(); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 931. Minimum Falling Path Sum]]></title>
    <url>%2FLeetCode%20931.%20Minimum%20Falling%20Path%20Sum.html</url>
    <content type="text"><![CDATA[72.Minimum Falling Path Sum（下降路径最小和）链接https://leetcode-cn.com/problems/minimum-falling-path-sum/ 题目给定一个方形整数数组 A，我们想要得到通过 A 的 下降路径 的最小和。 下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。 示例： 输入：[[1,2,3],[4,5,6],[7,8,9]] 输出：12 解释： 可能的下降路径有： * [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] * [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] * [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]和最小的下降路径是 [1,4,7]，所以答案是 12。 思路从第二行开始，上方下落路径至多三条，左上，上，右上，如果是两侧只有两条路径。直接在上方数字中找到最小数值，加上本身数值，这就是到达该点的和最小的下降路径。 接下来一行一行向下，直到计算到最后一行，遍历最后一行，找到最小值即可。 图解红色是计算式，左上角是本来数组的值。 代码123456789101112131415161718192021public static int minFallingPathSum(int[][] A) &#123; int min = 9999; int len = A.length; for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; if (j == 0) &#123; A[i][j] = A[i][j] + Math.min(A[i - 1][j], A[i - 1][j + 1]); &#125; else if (j == len - 1) &#123; A[i][j] = A[i][j] + Math.min(A[i - 1][j], A[i - 1][j - 1]); &#125; else &#123; A[i][j] = A[i][j] + Math.min(A[i - 1][j], Math.min(A[i - 1][j - 1], A[i - 1][j + 1])); &#125; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; if (min &gt; A[len - 1][i]) &#123; min = A[len - 1][i]; &#125; &#125; return min;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1. Two Sum]]></title>
    <url>%2FLeetCode%201.%20Two%20Sum.html</url>
    <content type="text"><![CDATA[1.Two Sum（两数之和）链接https://leetcode-cn.com/problems/two-sum/ 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路简单的遍历即可，考虑到复杂度可以借助hashmap，只需要图的基本操作即可。 代码：代码一（时间消耗量较大）12345678910111213public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) map.put(nums[i], i); for (int i = 0; i &lt; nums.length; i++) &#123; int number = target - nums[i]; if (map.containsKey(number)&amp;&amp;map.get(number)!=i) &#123; return new int[] &#123; map.get(number), i &#125;; &#125; &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; 代码二（优化之后）123456789101112public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int number = target - nums[i]; if (map.containsKey(number)) &#123; return new int[] &#123; map.get(number), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 72. Edit Distance]]></title>
    <url>%2FLeetCode%2072.%20Edit%20Distance.html</url>
    <content type="text"><![CDATA[72.Edit Distance（编辑距离）链接https://leetcode-cn.com/problems/edit-distance/ 题目给定两个单词 word1 和 word2 ，计算出将 word1 转换成 _word2 _所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 思路多次选择试图得到最优解，那么考虑动态规划。 先假设word1有len1位，word2有len2位，建立数组step，step[i][j]就代表我们要将word1前 i 位转换为word2前 j位的最少数量。 此时word1查找到第 i+1 位字母a，word2查找到第 j+1 位字母b，我们直接比较这两个字母，能得到两种情况： 1.a=b：那么就不需要操作，此时word1前 i+1 位替换为word2前 j+1 位只需要step[i][j]步 即为 step[ i+1 ][ j+1 ] = step[ i ][ j ] 2.a!=b：就要在给定的三种操作方式中选择最优解，再增加一步操作即可 即为 step[ i+1 ][ j+1 ] = Min(num1，num2，num3); 最后得到的step[ i ][ j ]就是最短编辑距离。 图解首先建立数组，将红色部分赋值，之后开始按照顺序计算，从word1转换为word2，step[ i ][ j ]就是最短编辑距离，step[ i-1][ j]就是插入，step[ i ][ j-1 ]就是删除，step[ i-1 ][ j-1]就是修改，如果不相同就从三种决策中寻找最小值加一，相同就直接添加，值等于step[ i-1 ][ j-1 ]。 例如AB-&gt;ABC（大号红色字体），B和C不同，左侧（AB-&gt;AB）0次，左上（A-&gt;AB）1次，上方(A-&gt;ABC)2次，选择三种情况最小值，再进行一步操作（左侧AB-&gt;AB-&gt;ABC），只需要1次。 或者ABDC-&gt;ABC(大号蓝色字体)，C与C相同，直接进行左上（ABD-&gt;AB-ABC）,也只需要1次。 代码12345678910111213141516171819202122232425262728293031323334public static int minDistance(String word1, String word2) &#123; int len1 = word1.length(); int len2 = word2.length(); int[][] step = new int[len1 + 1][len2 + 1]; for (int i = 0; i &lt;= len1; i++) &#123; step[i][0] = i; &#125; for (int j = 0; j &lt;= len2; j++) &#123; step[0][j] = j; &#125; for (int i = 1; i &lt;= len1; i++) &#123; char letter1 = word1.charAt(i - 1); for (int j = 1; j &lt;= len2; j++) &#123; char letter2 = word2.charAt(j - 1); if (letter1 == letter2) &#123; //若字母相同，即直接添加，不增加步数 step[i][j] = step[i - 1][j - 1]; &#125; else &#123; int ReNum = step[i - 1][j - 1] + 1; //修改 int InNum = step[i - 1][j] + 1; //插入 int DeNum = step[i][j - 1] + 1; //删除 int min = Math.min(ReNum, Math.min(InNum, DeNum)); step[i][j] = min; &#125; &#125; &#125; return step[len1][len2];&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令行发送SMTP协议邮件（163邮箱）]]></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%91%E9%80%81SMTP%E5%8D%8F%E8%AE%AE%E9%82%AE%E4%BB%B6%EF%BC%88163%E9%82%AE%E7%AE%B1%EF%BC%89.html</url>
    <content type="text"><![CDATA[命令行发送SMTP协议邮件（163邮箱）这里我们用163邮箱为例子，借助命令行发送smtp邮件 1连接服务器在终端上输入：telnet smtp.163.com 25 回车，然后就连接了服务器的25端口，成功会输出 220 163.com Anti-spam GTfor Coremail System (163com[20141201]) 2表明身份需要输入：helo 163.com 回车，顺利的话会出现 250 OK 3. 登录认证输入：auth login 回车，成功返回 334 dXNlcm5hbWU6 4. 登录输入账号（不需要之后的@163.com），账号需要进行base64加密，输入加密后的字符。返回 334 UGFzc3dvcmQ6 5. 输入授权码这里可以说有点小坑，需要登录网页版的邮箱查看，可以关闭smtp再开启，记住自己的授权码，同样base64加密，输入加密后的字符，返回 235Authentication successful 6. 邮件正文发件邮箱：mail from:&#x73;&#101;&#110;&#x64;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109; 返回 250 Mail OK 收件邮箱：rcpt to:&#x72;&#101;&#x63;&#101;&#105;&#118;&#x65;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109; 返回 250 Mail OK 输入：data 返回 354 End data with . 输入：subject:hello 这里需要注意，要两次回车 邮件正文：这里就随便写了 结束符号：这里要输入 . 表示邮件结束了，之后回车，发送成功会有250开头的返回 打开邮箱，发送成功。]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[商品销量分析及预测系统测试心得]]></title>
    <url>%2F%E5%95%86%E5%93%81%E9%94%80%E9%87%8F%E5%88%86%E6%9E%90%E5%8F%8A%E9%A2%84%E6%B5%8B%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E5%BF%83%E5%BE%97.html</url>
    <content type="text"><![CDATA[商品销量分析及预测系统测试心得测试内容商品销量分析及预测系统Web登录模块与Web其他模块。 测试描述我之前的工作主要是在安卓App端，所以测试阶段就转到了Web端，希望能以用户的视角发现一些问题。 测试结果在Web登录模块，文本框会出现长度过长的问题,导致界面变形，同样的问题在忘记密码界面也有。 在Web其他模块中的TensorFlow参数修改上发现了bug，只能修改特定范围数字的文本框，可以不输入数字直接修改。 测试心得一开始进行测试的时候，只是觉得Web端有些变扭，这个是界面自适应没有做好的问题，修改预测模块参数的时候，我随手按了下空格，结果可以保存，这是数据判断的问题。 这次的测试，让我们发现了项目的很多不足，debug的过程，也让我们更加认识到了测试的重要性。所以，开发任务中需要每次迭代都带上一次测试，这样可以大大减少bug的数量。]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[商品销量预测 第一次迭代总结]]></title>
    <url>%2F%E5%95%86%E5%93%81%E9%94%80%E9%87%8F%E9%A2%84%E6%B5%8B%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[商品销量预测 第一次迭代总结思考总结设想和目标 我们的软件要解决什么问题？是否定义得很清楚？是否对典型用户和典型场景有清晰的描述？ 问题：我们的软件从设计开始就是为了商家在线查看门店的销量情况，细化到各种种类商品的销量情况，并且能预测商品接下来的一段时间的销量情况并生成图表。 典型用户：商店的经营者以及管理者，部分供货商也可能使用。 典型场景：查看当前销售情况，预测之后的销售情况。 我们达到目标了么（原计划的功能做到了几个？ 按照原计划交付时间交付了么？ 原计划达到的用户数量达到了么? 第一次迭代的开发目标都完成了，交付时间正常，用户数量没有增长。 用户量, 用户对重要功能的接受程度和我们事先的预想一致么? 我们离目标更近了么? 用户量和预想中一致，接收程度大致相同，离目标更近了。 有什么经验教训? 如果历史重来一遍, 我们会做什么改进? 小组组员的任务分配不够合理，浪费了大量时间在模块拼装上。如果再来一次，会选择相对适合我们的项目。 计划 是否有充足的时间来做计划? 做计划的时间很长，足够充足。 团队在计划阶段是如何解决同事们对于计划的不同意见的？ 讨论，得到一个起码在当前情况下最合理的安排。 你原计划的工作是否最后都做完了? 如果有没做完的，为什么? 基本完成，但是完成的质量不够高。安卓界面设计想要达到原型设计的效果难度很大，还需要学习。 有没有发现你做了一些事后看来没必要或没多大价值的事? 过多的制定了计划，应该在编码前只指定大致计划，随编码进度进行细化。 是否每一项任务都有清楚定义和衡量的交付件? 没有，不过在编码过程中基本每天都会有备份。 是否项目的整个过程都按照计划进行，项目出了什么意外？有什么风险是当时没有估计到的，为什么没有估计到? 按照计划进行了，但是没有估计到安卓界面想要达成原型效果这么繁琐，所以界面比起原型差了不少。 在计划中有没有留下缓冲区，缓冲区有作用么? 没有，应该保留缓冲区避免项目出现问题。 将来的计划会做什么修改？（例如：缓冲区的定义，加班） 应该确保每天的编码工作量，避免最后几天熬夜。 我们学到了什么? 如果历史重来一遍, 我们会做什么改进? 团队开发合作的经验。给自己足够的编码测试时间，换一个更适合我们团队的项目。 资源 我们有足够的资源来完成各项任务么? 人力比想象的缺乏一些。 各项任务所需的时间和其他资源是如何估计的，精度如何? 时间主要是自己根据工作量大致估计，精度不是很高。 测试的时间，人力和软件/硬件资源是否足够? 对于那些不需要编程的资源 (美工设计/文案)是否低估难度? 测试时间不是很够，完成之后进行了一些测试。 人力略有不足，软件硬件资源足够。 对于美工/文案本来认为很简单，现在发现如果要做好很难。 你有没有感到你做的事情可以让别人来做（更有效率）? 界面拼装。 有什么经验教训? 如果历史重来一遍, 我们会做什么改进? 应该找到更适合做界面的人来帮忙进行界面设计的。 变更管理 每个相关的员工都及时知道了变更的消息? 基本都及时知道了消息。 我们采用了什么办法决定 “推迟”和”必须实现”的功能? 首先先要实现销量的分析预测，这是核心功能，别的美观方面和额外功能都没有这个重要。 项目的出口条件（Exit Criteria - 什么叫”做好了”）有清晰的定义么? 暂时没有。 对于可能的变更是否能制定应急计划? 起初做了准备，之后发现准备可能不够充足。 员工是否能够有效地处理意料之外的工作请求？ 能够做到。 设计/实现 设计工作在什么时候，由谁来完成的？是合适的时间，合适的人么？ 项目初期共同制定的，时间合适，人选合适。 设计工作有没有碰到模棱两可的情况，团队是如何解决的？ 有，进行讨论找到了相对合理且难度较低的解决方法。 团队是否运用单元测试（unit test），测试驱动的开发（TDD）、UML, 或者其他工具来帮助设计和实现？这些工具有效么？ 比较项目开始的 UML文档和现在的状态有什么区别？这些区别如何产生的？是否要更新 UML 文档？ 有使用，很有效果。原来的UML较为虚浮，现在修改了，比之前完整了很多。有的之前只是提了一下，现在大大细化了。 什么功能产生的Bug最多，为什么？在发布之后发现了什么重要的bug? 为什么我们在设计/开发的时候没有想到这些情况? 安卓App与服务器的信息传递。目前还没有发布。因为之前没有安卓App的开发经验。 代码复审（Code Review）是如何进行的，是否严格执行了代码规范？ 分块每个组员都进行了复审。执行了。 测试/发布 团队是否有一个测试计划？为什么没有？ 暂时没有，因为编码过程中就保留了测试。 是否进行了正式的验收测试？ 第一次迭代验收。 团队是否有测试工具来帮助测试？ 暂时没有。 团队是如何测量并跟踪软件的效能的？从软件实际运行的结果来看，这些测试工作有用么？应该有哪些改进？ 自行进行了数据的测试。有用，因为检查出来了很多bug。 在发布的过程中发现了哪些意外问题？ 尚未发布。 团队的角色，管理，合作 团队的每个角色是如何确定的，是不是人尽其才？ 自行商议，以个人意愿为主。 团队成员之间有互相帮助么？ 有。 当出现项目管理、合作方面的问题时，团队成员如何解决问题？ 查询资料，互相帮助，共同解决。 总结 你觉得团队目前的状态属于 CMM/CMMI 中的哪个档次? 属于CMMI一级，完成级。 你觉得团队目前处于 萌芽/磨合/规范/创造 阶段的哪一个阶段? 规范阶段。 你觉得团队在这个里程碑相比前一个里程碑有什么改进? 之间合作更为快捷方便，更有效率。 你觉得目前最需要改进的一个方面是什么? 界面需要进行美化。]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[结对编程项目之队友代码分析]]></title>
    <url>%2F%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E9%A1%B9%E7%9B%AE%E4%B9%8B%E9%98%9F%E5%8F%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[结对编程项目之队友代码分析阅读了队友的代码，觉得他的代码有很多值得学习的地方，也有不少可以改进的地方，虽然和我的代码用的语言不同，但是思路大同小异。 优点： 修改用户和命令较为方便：采用了字符串数组来存储账号密码和各种命令，如果需要修改，直接更改存储的元素即可。 1234 const string Userchart[3][3]=&#123;&quot;张三1 123&quot;,&quot;张三2 123&quot;,&quot;张三3 123&quot;, &quot;李四1 123&quot;,&quot;李四2 123&quot;, &quot;李四3 123&quot;, &quot;王五1 123&quot;,&quot;王五2 123&quot;,&quot;王五3 123&quot;&#125;; 可以方便改进生成文件的路径：字符数组存储路径，，如果需要对之进行修改，可以直接对之进行修改。 命名较标准比如对于括号的判断变量，用了judgebackets，让代码更加容易理解。就以其中的括号生成部分为例，一目了然。123456789101112judgebackets=rand()%3; if (judgebackets==0) &#123; //考虑同时有多个括号的情况 while (judgebackets==0&amp;&amp;((operatenumber-j)&gt;backetsnumber)) &#123; judgebackets=rand()%3; backetsnumber++; ofile&lt;&lt;&apos;(&apos;; &#125;; ofile&lt;&lt;rand()%100+1&lt;&lt;g_Operatechar[rand()%4]; &#125; 缺点 去重：可能由于时间问题，去重函数只写了一个伪代码，并未具体实现。所以我就简单说一下我自己的思路。我采用了先搜索原文件夹，按顺序打开文件，之后按行读取。我之前先是生成了一个字符串，之后一行一行搜索查重，相同的话（尽管概率较小），就重新生成，不然就写入文本，这样就可以实现去重的要求。 生成文件文件名时间较为麻烦，他是采用了一种繁琐的方法做的，虽然这样编辑较为方便，但是略显冗杂。 123456789101112131415161718192021222324252627void Creattime()//获取当前系统时间，用g_timenow来表示&#123; SYSTEMTIME sys; //利用windowsAPI获取系统时间 GetLocalTime(&amp;sys); g_timenow[0]=sys.wYear/1000+&apos;0&apos;; g_timenow[1]=(sys.wYear/100)%10+&apos;0&apos;; g_timenow[2]=(sys.wYear/10)%10+&apos;0&apos;; g_timenow[3]=sys.wYear%10+&apos;0&apos;; g_timenow[4]=&apos;-&apos;; g_timenow[5]=sys.wMonth/10+&apos;0&apos;; g_timenow[6]=sys.wMonth%10+&apos;0&apos;; g_timenow[7]=&apos;-&apos;; g_timenow[8]=sys.wDay/10+&apos;0&apos;; g_timenow[9]=sys.wDay%10+&apos;0&apos;; g_timenow[10]=&apos;-&apos;; g_timenow[11]=sys.wHour/10+&apos;0&apos;; g_timenow[12]=sys.wHour%10+&apos;0&apos;; g_timenow[13]=&apos;-&apos;; g_timenow[14]=sys.wMinute/10+&apos;0&apos;; g_timenow[15]=sys.wMinute%10+&apos;0&apos;; g_timenow[16]=&apos;-&apos;; g_timenow[17]=sys.wSecond/610+&apos;0&apos;; g_timenow[18]=sys.wSecond%10+&apos;0&apos;;&#125; 可能会生成双重括号，经常会出现在两个操作数外围同时出现两对括号，对于题目的简洁造成了影响。这里我觉得可以采用一种判断方式，如果两个前括号已经在一起，那么两个后括号就不能在一起，强制将后一个后括号向后移位，如果已经是最后一位就重新生成题目；或者如果检索到双重括号就直接重新生成。]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java的三种随机数生成方式]]></title>
    <url>%2Fjava%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[java的三种随机数生成方式随机数的产生在一些代码中很常用，也是我们必须要掌握的。而java中产生随机数的方法主要有三种： 第一种：new Random() 第二种：Math.random() 第三种：currentTimeMillis() 第一种第一种需要借助java.util.Random类来产生一个随机数发生器，也是最常用的一种，构造函数有两个，Random()和Random(long seed)。第一个就是以当前时间为默认种子，第二个是以指定的种子值进行。产生之后，借助不同的语句产生不同类型的数。 种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关。以代码为例。 123456789public static void main(String[] args)&#123; Random r = new Random(1); for(int i=0 ; i&lt;5 ; i++) &#123; int ran1 = r.nextInt(100); System.out.println(ran1); &#125;&#125; 在我的编译器下产生的五个数均为85,88,47,13,54，如果采用Random r = new Random()，产生的随机数就不同，这就是确定种子导致的结果。 第二种而第二种方法返回的数值是[0.0,1.0）的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了，代码如下。 123456public static void main(String[] args)&#123; int max=100,min=1; int ran2 = (int) (Math.random()*(max-min)+min); System.out.println(ran2);&#125; 第三种至于第三种方法虽然不常用，但是也是一种思路。方法返回从1970年1月1日0时0分0秒（这与UNIX系统有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数。 12345678public static void main(String[] args)&#123; int max=100,min=1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum%(max-min)+min); System.out.println(ran3); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
